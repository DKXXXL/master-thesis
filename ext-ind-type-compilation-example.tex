\begin{figure}
\lstset{
    basicstyle=\fontsize{8}{8.5}\ttfamily,
% numbers=left,
}

\begin{minipage}{\textwidth}
\begin{multicols}{2}

\definecolor{codecomment-color}{HTML}{FF007F}

\begin{lstlisting}
Family STLC.[@\tanc{Ext-Ind-Cmp-start}@]
 FInductive tm : Set := tm_var : [@\dadada@] 
 FScheme tm_prec PRecT about self__STLC.tm.
 FScheme Comp about self__STLC.tm_prec.
 (* Generate Partial Recursor 
    and the computational axiom *)
 Family subst_internal. 
  Final Field tm_var : [@\dadada@]
  := fun s x t => 
    if (eqb x s) 
    then t else (tm_var s).
 (* [@\dadada@] other three cases *)
 EndFamily.
 FRecursor subst 
  about tm 
  motive (fun _ => id → tm → tm)
  using subst_internal
  by _rec.
(* Field test := (subst (tm_var 0) 0 (tm_var 0)). *)
(*  *)
EndFamily.
Family STLC_bool extends STLC.
(* [@\dadada@] *)
 Extend FInductive tm : Set :=
  | tm_true : tm [@\dadada@]
 Extend Family subst_internal.
  Final Field tm_true : [@\dadada@]
   := fun x t => tm_true.
  (* [@\dadada@] *)
 EndFamily. 
 Inherits subst.
(* [@\dadada@] *)
EndFamily.[@\tanc{Ext-Ind-Cmp-end}@]
\end{lstlisting}

\makeline[0pt]{Ext-Ind-Cmp-start}{Ext-Ind-Cmp-end}[codecomment-color!50]

\columnbreak

\definecolor{codecomment-color}{HTML}{0DA3FF}

\begin{lstlisting}
Module Type STLC_Interface.[@\tanc{Cmp-Result-start}@]
  Parameter (tm : Set).
  Parameter (tm_var : id → tm).
  Parameter (tm_abs : id → tm → tm).
  (* [@\dadada@] and all the fields for inductive type [@\dadada@] *)
End STLC_Interface.
(* Collect eliminator to Set for tm *)
Module tm_rec_type (STLC: STLC_Interface).
  Definition __recursor_type_tm_rec :=
    forall P : STLC.tm -> Set,
    (forall n : id, P (STLC.tm_var n)) ->
    (forall (n : id) (i : STLC.tm),
    P i -> P (STLC.tm_abs n i)) ->
    [@\dadada@] -> forall i : STLC.tm, P i.
End tm_rec_type.
(* Compiled Field STLC.subst_internal.tm_var *)
Module tm_var_handle (self__STLC: STLC_Interface)
  (self__subst_internal: EmptySig_84).
Definition tm_var :
  forall (s : ident) (x : ident) (t : self__STLC.tm), self__STLC.tm :=
  fun s x t => if eqb x s then t else self__STLC.tm_var s.
End tm_var_handle. (* [@\dadada@] and more *)
(* Assembling STLC.subst_internal when compilation *)
Module subst_internal_410 (STLC: STLC_Interface). 
  Module subst_internal.
  Include tm_var_handle STLC. Include tm_abs_handle STLC.
  Include tm_app_handle STLC. Include tm_unit_handle STLC.
  End subst_internal.
End subst_internal_410.
Module do_tc (STLC: STLC_Interface).
(* Intermediate Module solely for type checking *)
  Include tm_rec_type STLC.
  Parameter (recursor_for_type_checking : __recursor_type_tm_rec).
  Definition term_for_type_checking :=
    recursor_for_type_checking (fun _  ⇒ id → STLC.tm → STLC.tm)
      subst_internal_410.tm_var [@\dadada@] .
End do_tc.
(* Ctx that expose concrete inductive type *)
Module Type ctx_subst_113.
Inductive __internal_tm : Set := [@\dadada@] 
Include subst_internal_410. (* [@\dadada@] and more inclusion *)
End ctx_subst_113.
(* Compilation of recursor, not reusable
    when inductive type extended due to the ctx *)
Module subst_128 (self__STLC: ctx_subst_113).
Include __motive_of_subst_107 self__STLC.
Definition subst :=
  self__STLC.__internal_tm_rec __motiveTsubst
	self__STLC.subst_internal.tm_var [@\dadada@] .
End subst_128.
(* Assembling the whole STLC *)
Module STLC.
Include tm_5. Include tm_prec_72. Include tm_prectm_81.
Include subst_internal_410. Include subst_128.
End v_129.
(* Assembling STLC_bool.subst_internal via reusing 
    most of the former compilation results *)
Module subst_internal_248 (STLC_bool: STLC_Interface).
Include tm_true_197 STLC_bool. Include [@\dadada@]
(* The Reused Compilation result *)
Include tm_var_handle STLC_bool. Include [@\dadada@]
End v_248. [@\tanc{Cmp-Result-end}@]

\end{lstlisting}

\makeline[.5\textwidth+9pt]{Cmp-Result-start}{Cmp-Result-end}[codecomment-color!50]

\vspace{-5pt}

\end{multicols}
\end{minipage}

\caption{Exemplar STLC Code, especially about Inductive Type}\label{fig:plugin-example2}
\end{figure}