\begin{figure}
\begin{minipage}{\textwidth}
\begin{multicols}{2}

\lstset{
  basicstyle=\fontsize{8}{8.5}\ttfamily,
}

\begin{lstlisting}[numbers=left]
Family STLC.

FInductive ty : Set :=[@\hfill\codecomment{Types}@]
| ty_unit  : ty
| ty_arrow : ty -> ty -> ty.

FInductive tm : Set :=[@\hfill\codecomment{Terms}@]
| tm_var  : id -> tm
| tm_unit : tm
| tm_abs  : id -> tm -> tm
| tm_app  : tm -> tm -> tm.[@\label{line:tm-app}@]

Field env : Type := id -> option ty.
Field empty : env := \lambda _, None.

FInductive hasty : env -> tm -> ty -> Prop :=
| ht_var  : [@\dadada@]  | ht_unit : [@\dadada@][@\hfill\codecomment{Typing rules}@]
| ht_abs  : [@\dadada@]  | ht_app  : [@\dadada@].

FInductive value : tm -> Prop :=[@\hfill\codecomment{Value forms}@]
| v_unit : value tm_unit
| v_abs  : \forall x e, value (tm_abs x e).

FRecursion subst on tm[@\hfill\codecomment{Substitution function}@] 
motive \lambda(_ : tm), id -> tm -> tm.
Case tm_var := \lambda y x e,
  if (eqb x y) then e else (tm_var y).
Case tm_unit := \lambda x e, tm_unit.
Case tm_abs := \lambda y e' IHe' x e, [@\dadada@].
Case tm_app := \lambda e1 IHe1 e2 IHe2 x e,
  tm_app (IHe1 x e) (IHe2 x e).
End subst.

FInductive step : tm -> tm -> Prop :=
| st_app1 : [@\dadada@][@\hfill\codecomment{Reduction rules}@]
| st_app2 : [@\dadada@]
| st_beta : \forall x e v, value v ->
  step (tm_app (tm_abs x e) v) (subst e x v).

Field steps := clos_refl_trans step.

FInduction weakening on hasty[@\hfill\codecomment{Weaken.\ lemma}@]
motive \lambda G e T (_ : hasty G e T),
  \forall G', includedin G G' -> hasty G' e T.
Case ht_var.  [@\dadada@] Qed.[@\hfill@]Case ht_unit. [@\dadada@] Qed.
Case ht_abs.  [@\dadada@] Qed.[@\hfill@]Case ht_app.  [@\dadada@] Qed.
End weakening.

FInduction substlemma on hasty[@\hfill\codecomment{Subst.\ lemma}@]
motive \lambda G' e T (_ : hasty G' e T),
  \forall G x e' T', G' = extend G x T' ->
  hasty empty e' T' -> hasty G (subst e x e') T.
Case ht_var.  [@\dadada@] Qed.[@\hfill@]Case ht_unit. [@\dadada@] Qed.
Case ht_abs.  [@\dadada@] Qed.[@\hfill@]Case ht_app.  [@\dadada@] Qed.
End subst_lemma.

FInduction preserve on hasty[@\hfill\codecomment{Preserv.\ theorem}@]
motive \lambda G e T (_ : hasty G e T),
  G = empty -> \forall e', step e e' -> hasty empty e' T.
Case ht_var.  [@\dadada@] Qed.[@\hfill@]Case ht_unit. [@\dadada@] Qed.
Case ht_abs.  [@\dadada@] Qed.[@\hfill@]Case ht_app.  [@\dadada@] Qed.
End preserve.

FInduction progress on hasty[@\hfill\codecomment{Progress theorem}@]
motive \lambda G e T (_ : hasty G e T),
  G = empty -> value e \/ \exists e', step e e'.
Case ht_var.  [@\dadada@] Qed.[@\hfill@]Case ht_unit. [@\dadada@] Qed.
Case ht_abs.  [@\dadada@] Qed.[@\hfill@]Case ht_app.  [@\dadada@] Qed.
End progress.

Field typesafe :[@\hfill\codecomment{Type-safety theorem}@]
  \forall e e' T, steps e e' -> hasty empty e T ->
  value e' \/ \exists e'', step e' e''.
Proof. [@\dadada@] Qed.

End STLC.
\end{lstlisting}
\medskip

\hrule
\hrule
\medskip

\begin{lstlisting}[numbers=left,firstnumber=77]
Family STLC_fix extends STLC.

FInductive tm : Set +=
| tm_fix : id -> tm -> tm.

FInductive hasty : env -> tm -> ty -> Prop +=
| ht_fix : \forall G x e T, hasty (extend G x T) e T ->
  hasty G (tm_fix x e) T.

FRecursion subst on tm motive \lambda _, id -> tm -> tm.
Case tm_fix := [@\dadada@].
End subst.

FInductive step : tm -> tm -> Prop +=
| st_fix : \forall x e,
  step (tm_fix x e) (subst e x (tm_fix x e)).

FInduction weakening on hasty motive [@\dadada@].
Case ht_fix. [@\dadada@] Qed.
End weakening.

FInduction substlemma on hasty motive [@\dadada@].
Case ht_fix. [@\dadada@] Qed.
End subst_lemma.

FInduction preserve on hasty motive [@\dadada@].
Case ht_fix. [@\dadada@] Qed.
End preserve.

FInduction progress on hasty motive [@\dadada@].
Case ht_fix. [@\dadada@] Qed.
End progress.

End STLC_fix.
\end{lstlisting}

\end{multicols}
\end{minipage}
\caption{Using our plugin to mechanize STLC and the fixpoints extension,
as envisioned in \cref{fig:stlc-nonmechanized}.}
\label{fig:stlc-mechanized}
\end{figure}




\ifShowOldWriting

\begin{figure}
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC.
 FInductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
 FInductive term : Set := 
  | tm_var : id -> term 
  | tm_abs : id -> term -> term ...
 Family subst_internal.
  Final Field tm_var := ..
  Final Field tm_abs := ..
   ...
 EndFamily.
 FRecursor subst
  about tm motive ..
  using subst_internal.
 ...
 FInductive has_type 
  : context -> term -> type := ...
 FTheorem subst_lemma 
  about has_type 
  motive ...
 Proof.  ...
 Qed.
 FInductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC_bool extends STLC.
 Extend FInductive ty : Set :=
  | bool : ty.

 Extend FInductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
 Extend Family subst_internal.
  Final Field tt := ..
  Final Field ff := ..
  Final Field tif := ..
 EndFamily. (* Automatic inheriting others 
              from STLC.subst_internal *)
 Inherit subst.
(* Plugin will redo exhaustiveness check, in case 
 subst_internal is not extended correctly *)
 Extend FInductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
 Extend FTheorem subst_lemma. Proof.
  ... (* Need to prove extra cases *)
 Qed.


 Extend FInductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example STLC and its extension, in designed syntax}\label{fig:STLC-example2}
\end{figure}

\fi