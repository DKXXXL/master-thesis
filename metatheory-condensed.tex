To formalize our metatheory, we follow the formulation of~\citet{altkap2016}, which provides a declarative and intrinsic style of the predicative \textit{Martin-Lof Type Theory} (MLTT)~\cite{martin1982constructive},
using \textbf{Quotient Inductive Inductive Type}(QIIT)\footnote{Inductive Inductive Type(IIT) is a generalization of mutual inductive type where (indexed-)types \mintinline{Coq}{A : Type, B : A -> Type} can be defined mutually. QIIT further enhances IIT by allowing equality constructor (i.e. mathematical quotient).}, \textbf{explicit substitution} and \textbf{debruijn indices} as the main tool. 
Generally speaking, we \textbf{use each QIIT type to represent each kind of judgements, and thus a term will represent a derivation of a judgement}. The classical formulation of dependent type theory requires a lot of \textit{presupposition} and quotient afterwards, causing a lot of duplicacy. Both issues can be concisely solved by using QIIT expressing intrinsically typed syntax instead. What's more, working \textbf{in a type-theoretical setting} using QIIT makes checking of the pen-and-paper proof easier. However, we will follow conventional notation and thus the reader might not notice the usage of QIIT explicitly.\EDJ{We might be able to remove QIIT in the main text totally. Let's try to do it later.}

$$
\Rule[name=Subst]
{\goodType{\Delta}{T}{j} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{j}},
\Rule[]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
\quad
\Rule[name=Dbj Indices]
{\goodSub{\Gamma}{\gamma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_1 \gamma}{\Delta}},
\Rule[]
{\goodSub{\Gamma}{\gamma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_2 \gamma}{A[\pi_1 \gamma]}}
$$

% Explicit substitution
Instead of meta-level substitution, we use \textbf{explicit substitution}, i.e., substitution itself is a expression in the program and will be done in the runtime. Thus substitution has its own judgement $\goodSub{\Gamma}{\gamma}{\Delta}$. We can apply substitution to types and terms\footnote{The type judgement is the form $\goodType{\Gamma}{T}{}$. The term judgement is the form $\goodTerm{\Gamma}{t}{T}$} in MLTT via \ruleref{Subst}. We also have an identity substitution $\goodSub{\Gamma}{"id"}{\Gamma}$.
% Debruijn Indices
Contrary to named variables, \textbf{debruijn indices} refer to the variable in the context like operating a stack. For example, we can get the very first variable in the context $\Gamma, x : T \vdash x : T$ by $\goodTerm{\Gamma, T}{\pi_2 "id"}{T[\pi_1"id"]}$. Similarly, to get the second and above variables, we only need to apply a sequence of $\pi_1$s. 


Now, we will mainly focus on the newly introduced typing rules, and illustrate their connection to the plugin implementation. For those curious about the complete meta-theory formulation, we refer to our appendices or \citet{altkap2016, kaposi2017type} or maybe those not using QIIT \cite{coquand2018canonicity, sterling2019algebraic}. Our metatheory is in an extensional setting. 

% linkage, signature and compilation and seal
$$
\Rule[name=Ept Sig]
{}
{\goodSig{\Gamma}{\nu\cdot}{0}}\quad
\Rule[name=Lnkg Type/Compile]
{\goodSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\cL \sigma}{i}
\quad \goodType{\Gamma}{\cC \sigma}{}}
\quad
\Rule[name=Lnkg Compile]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
}
{
  \goodTerm{\Gamma}{\cCt o}{\cC \sigma}
}
$$
$$
\Rule[name=Sig Add]
{\goodSig{\Gamma}{\sigma}{n} 
 \quad \goodType{\Gamma}{A}{}
 \quad \goodSeal{\Gamma}{f}{\sigma}{A}
 \quad \goodType{\Gamma, A}{T}{i}}
{\goodSig{\Gamma}{(\nu^+ \ \sigma \ \{f\} \ T)}{n+1}}
\quad
\Biggl( \boxed{\goodSeal{\Gamma}{s}{\sigma}{A}} 
:= \boxed{\goodTerm{\Gamma, \cC\sigma}{s}{A[\pi_1]}} \Biggr)
$$
$$
\Rule[name=Ept Lnkg]
{}
{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot}}
\quad
\Rule[name=Lnkg Add]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
\quad \goodType{\Gamma}{A}{}
\quad  {\goodSeal{\Gamma}{f}{\sigma}{A}}
 \quad \boxed{\goodTerm{\Gamma, A}{t}{T}}
}
{\goodTerm{\Gamma}{(\mu^+ \ o \ \{f\} \ t)}{\cL(\nu^+ \ \sigma \ \{f\} \ T)}}
$$
We start with signature (in a brand new judgement $\goodSig{\Gamma}{\sigma}{n}$). A signature is a list of types contained by a \textit{linkage}\footnote{Following the convention by \citet{zm2017}, we name the meta-theoretical correspondents of \textit{family} as \textit{linkage}.}, tracking the length as superscript.   We will use $\{a : T_1, b : T_2, ..\}$ as a shorthand for signature with type $T_1, T_2, ..$ for readability. 

Adding new types into signature \ruleref{Sig Add} requires a \textit{sealing judgement} $\goodSeal{\Gamma}{f}{\sigma}{A}$, which is an alias of a term judgement. Intuitively, when programming using meta-theory, sealing is a convenient device \textit{to indicate whether each field is overridable(extensible) or non-overridable (thus definitionally exposed)}. For example, if a field is overridable, we abstract that to its type; if a field has exposed its definition, we abstract it into the singleton type containing it instead.  Sealing $\goodSeal{\Gamma}{f}{\sigma}{A}$ is useful when the surrounding interface is $\sigma$ and we want to construct the new field based on $A$.

However, there is subtle difference compared to the plugin implementation---$(\mu^+ ~o~\{f\}~t)$ reads as \textit{``$t$ is a new well-typed field when we abstract the \textbf{prior} fields using $f$''}. In other words, every field in meta-theory has the right to choose how they perceive and abstract the prior fields. While in the plugin, "Overridable" keyword will decide how the current defining field is percived by the following fields.

We can now point out how "Overridable" and "pins" is modeled. Despite the fact we have a complicated dynamic of invisibility between overridable and normal fields in the plugin, every field can be elaborated into the (pseudo)-syntax form \\ \mintinline{Coq}{Field hiding {x, y, z ...} newfield := t...}  where every former field x,y,z,...  hide its definition when type-check t, and remaining former fields have their definition exposed in t.
This above elaborated "hiding" syntax directly corresponding to the $f$ in $(\mu^+ ~o~\{f\}~t)$, where each fields decides the abstraction of the prior.


Given a signature $\sigma$, we have the linkage type $\cL\sigma$ inhabited the linkages; and the \textit{compilation type} $\cC\sigma$ of the linkage type. The compilation type corresponds to how we compile a context into a \mintinline{Coq}{Module Type} in the plugin implementation---in metatheory, $\cC\sigma$ will be a nested sigma type. For example, $\cC\{a : \cU, b : a \to \bot \} = \Sigma(a : \cU).\Sigma (b : a \to \bot). \top$.


The difference between compilation type and linkage types lies in their introduction rules. The compilation types are just syntactic sugar for sigma types. However, the intro rules for the linkage types gives it the power of late-binding (also the fundation of inheritance and overriding). More concretely, the boxed premise in \ruleref{Lnkg Add} is making $t$ parametric on $A$, contrary to how in sigma type, the $t$ will be about a concrete $a : A$. This parametricity makes $t$ inheritable and the earlier stuff about $A$ late-bound.

% The sealing judgement provides a witness $f$ that a context $\Gamma, \cC\sigma$ can be abstracted into an \textit{interface} $\Gamma, A$ for a type $\goodType{\Gamma}{A}{}$. For example, sealing judgement can abstract an inductive type with constructors into an arbitrary type with functions (but without eliminators). Then any later fields $\goodTerm{\Gamma, A}{t}{T}$ relies only on the \textit{interface} $A$ can be inherited to other contexts (e.g. using extended inductive type), as long as the targeting contexts can be abstracted into the surrounding \textit{interface} for $t$ (i.e. $\Gamma, A$)  as well.

The importance of the compilation type lies in its difference from the linkage type. First we have a singleton type $"s A" : S(T) \iff "A" \equiv T$, i.e. a type of one single term.  We can see that we have a term $x : \cC\{A : S(\bot), B : A \to \bot \} \vdash h_1 : \cC\{A : \cU, B:A \to \bot \}$ which is equivalent to $x : \Sigma (A: S(\bot)). A \to \bot \vdash h_1 : \Sigma (A: \cU). A \to \bot$. This can be considered as using seal to do an abstraction on $A:S(\bot)$.

But we can never have a term $x : \cL\{a : S(\bot), b : a \to \bot \} \vdash h_2 : \cL\{a : \cU, b : a \to \bot \}$, as we know $\cL\{a : S(\bot), b : a \to \bot \}$ is inhabited and that leads to a close term of $\cL\{a : \cU, b : a \to \bot \}$ due to the nature of late-binding of $\cL\sigma$---once we override $a$ with $\top$ we will have inconsistency using $b$. This example illustrates the programming difference between the sigma type and linkage type.  

However, this form of abstracting a type is very important when programming in our metatheory---as later we will show inductive type of different constructors locates in different type (universe), and to make later fields inheritable we need to work on an interface of abstracted type. Thus the compilation type is indispensible.



% Looking closely, the sealing judgement helps to model most machinaries about abstraction in plugin implementation.

% Inductive type and recursor and handlers

$$
\Rule[]
{}
{\goodWSig{\Gamma}{w\cdot}{0}}
\quad
\Rule[name=WSig-Add]
{\goodWSig{\Gamma}{\tau}{n}
  \quad \goodType{\Gamma}{A}{i}
  \quad \goodType{\Gamma, A}{B}{i}}
{\goodWSig{\Gamma}{w^+ \  \tau \  A \  B}{n+1}}
\quad
\Rule[name=Ind-Univ]
{\goodWSig{\Gamma}{\tau}{n}}
{\goodType{\Gamma}{\bW \tau}{i}
}
$$
$$
\Rule[name=Ind-Term]
{\goodTerm{\Gamma}{T}{\bW \tau}
  \quad \goodTerm{\Gamma}{a}{\pi^j_1\tau}
  \quad \goodTerm{\Gamma, \pi^j_2\tau[(id, a)]}{b}{El~("W"~T)}}
{\goodTerm{\Gamma}{"Wsup"~T~a~b}{El~("W"~T)} }
$$
$$
\Rule[name=Hdler]
{\goodType{\Gamma}{A}{}
\quad \goodType{\Gamma, A}{B}{}
\quad \goodType{\Gamma}{R}{}
}
{\goodType{\Gamma}{"RecSig1"~A~B~R \equiv (\Pi A (\Pi (\Pi B (R[\pi_1\circ\pi_1])) R[\pi_1\circ\pi_1]) )}{}}
\quad 
\Rule[name=Hdlers]
{\goodWSig{\Gamma}{\tau}{n}
\quad \goodType{\Gamma}{R}{}
}
{\goodSig{\Gamma}{"RecSig"~\tau~R}{n}}
$$
$$
\Rule[name=Hdler-Proj]
{ \goodWSig{\Gamma}{\tau}{N}
\quad \goodTerm{\Gamma}{o}{\cL("RecSig"~\tau~R)}
\quad j < N
}
{\goodTerm{\Gamma}{"prjR"~j~o}{("RecSig1"~(\pi_1^j \tau)~(\pi_2^j \tau)~R)[\pi_1]}}
$$
$$
\Rule[name=Rec-Constr]
{ \goodWSig{\Gamma}{\tau}{N}
\quad \goodTerm{\Gamma}{T}{\bW \tau}
\quad \goodType{\Gamma}{R}{}
\quad \goodTerm{\Gamma}{r}{\cL("RecSig"~\tau~R)}
\quad \goodTerm{\Gamma}{w}{El~("W"~T)}
}
{\goodTerm{\Gamma}{"Wrec"~r~w}{R}}\YZ{
(1) Use \tau for inductive types and \sigma for linkage signatures.
(2) Try using the same metavariables (j and n) as in the rules on W-types.
(3) In Rec-Constr, no checking of \Gamma \vdash T : \bW \tau?
(4) Why are RecSig1, RecSig, Wrec, prjR not listed in the syntax figure?
}\EDJreply{Thx. Working on it. I seem to forgot to add inheritance as well.}\EDJreply{Done. Please Check.}
$$


Our formulation of (extensible) inductive type is close to W-type (\ruleref{WSig-Add} requires a pair of types $A \vdash B$ as well), but with mulitple constructors. Thus we have a brand new judgement ${\goodWSig{\Gamma}{\tau}{n}}$ indicating signature of inductive type by its constructors. Unconventionally, a signature can induce a "universe" of types $\bW\tau$---in other words, $T : \bW\tau$ will be the inductive type instead of $\bW\tau$ itself. "Wsup" is used to construct a specific term of a given inductive type.


When programming via meta-theory, we usually seal the inductive type, only expose its constructors (as a mundane function member) and hide the eliminator by abstracting $T : \bW\tau$ into $"W"~T : \cU$. Then the later fields---those only rely on this interface with $\cU$---can be inherited to other contexts (e.g. using enriched inductive type), as long as the targeting contexts can be abstracted into this {interface} again. 

Similar to plugin implementation, we delegate handlers (and their reuse) for recursion to linkages (and their inheritance). We use "RecSig1" to compute the type of a single handler and "RecSig" for the complete family of handlers for all constructors. \ruleref{Rec-Constr} uses "RecSig" to achieve exhaustiveness checking on elimination. The partial recursors and the computational axioms are treated as normal fields as expected, since we know they are provable in the plugin implementation.

$$
\Rule[name=Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma}{l}{\cL \sigma_1}
}
{\goodTerm{\Gamma}{("inh" \ h \ l)}{\cL \sigma_2}},
\Rule[name=Inh-Id]
{}
{\goodInh{\Gamma}{"inhid"}{\sigma}{\sigma}},
\Rule[name=Inh-Ext]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma, A_2}{t}{T}}
{\goodInh{\Gamma}{"inhext" \ h \ t}{\sigma_1}{(\nu^+ \  \sigma_2\  T)}}
$$

% Inhertance judgement
In the plugin implementation, "Family"s are second class objects like Coq's "Module". What's more, a "Family" (with or without "extends" clause) can be considered as a standalone piece of code trying to \textit{inherit} an existent (but maybe empty) family. Thus we model them using \textit{inheritance judgement} $\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}$ instead of considering them as first class terms. The only way to use $h$ is by \ruleref{Inh} and transforming a linkage of signature $\sigma_1$ to another linkage of $\sigma_2$. Inheritance judgement can be inductively constructed via inheriting operations, overriding operations, extending operations and etc, corresponding to "Inherit", "Override" and "Extend" command  in our plugin implementation.


In this way, we will consider the program in our metatheory similar to those vanilla MLTT program, except there are meta variables denoting inheirtance judgement (i.e. "Family"), of which the only usage is to apply \ruleref{Inh}. We don't yet consider non-trivial equality between derivations of inheritance judgements.


\subsection{Syntactic Translation that removes Linkages}
To further provide the intuition why our core calculus is sound, we provide a syntactic translation from our core calculus to the subpart where linkages are absent. This can justify the \textit{consistency} and \textit{canonicity} modulo the quirky (but apparent) formulation of our inductive type. To be complete, we also provide a consistency and canonicity proof for our complete core calculus in the appendix.

\newcommand{\denotesT}[1]{{{\llbracket {#1} \rrbracket}_T}}
\newcommand{\Sigr}[2]{{ "Sig"^r~{#1}~{#2} }}

Thanks to QIIT formulation, syntactic translation becomes a function between QIIT type, which by definition respects all the judgemental equalities. We will now sketch this translation $\denotesT{\_}$, which keeps most parts untouched except for the linkages related. We omit most of the inheritance translation.



\begin{align*}
  \text{We first define a new type }& \goodType{\Gamma}{\Sigr{\Gamma}{n}}{}  \text{ when } \goodCtx{\Gamma}{}  \text{ is well-formed and } n \in \mathbb{N} \\
  \denotesT{\goodSig{\Gamma}{\_}{n}},\ &({\Sigr{\Gamma}{n}}), \text{ and } \ \denotesT{\cC} \text{ are mutually recursive, } \\
  & \text{defined by induction on the signature length} \\  
  \denotesT{\goodSig{\Gamma}{\_}{n}} &= (\goodTerm{\Gamma}{\_}{\Sigr{\Gamma}{n}}) \text{, and thus } \denotesT{\goodSig{\Gamma}{\sigma}{n}} \text{defined} \iff \goodTerm{\Gamma}{\denotesT{\sigma}}{\Sigr{\Gamma}{n}} \\ 
  {\Sigr{\Gamma}{(n+1)}} &= 
    \Sigma~(\Sigr{\Gamma}{n})
          ~(\Sigma~\cU
                  ~(\Sigma~(\Pi(\cC (\pi_2[\pi_1]))(El~\pi_2[\pi_1]))~\cU)) \\
  \Sigr{\Gamma}{0} &= \top \\
  \denotesT{\goodType{\Gamma}{\cC \sigma}{}}, \denotesT{\goodType{\Gamma}{\cL\sigma}{}} &\text{ defines upon } \denotesT{\sigma} 
  \text{ and inductively on the signature length} \\
  \denotesT{\goodType{\Gamma}{\cC \sigma}{}} &= \denotesT{\goodType{\Gamma}{\cL\sigma}{}} = \top \quad
      \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}} \\ 
  \denotesT{\goodType{\Gamma}{\cC \sigma}{}} &= 
    \Sigma~\denotesT{\cC ("pjl"~\sigma)}~(El \ ("app"~("pjr"^3~\sigma))[(\pi_1, "app"~("pjl"~("pjr"^2~t)))]) \\
      &\text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}} \\
  \denotesT{\goodType{\Gamma}{\cL\sigma}{}} &=
  \denotesT{\cL("pjl"~\sigma)} \times \Pi(El~("pjl"~("pjr"~\sigma)))(El~("app"~("pjr"^3~\sigma))) \\
  \denotesT{\goodSig{\Gamma}{\nu^+~\sigma~f~T}{n+1}} &= (\sigma, "c"~A, "lam"~f, "lam"~("c"~T)) \\ 
  \denotesT{\goodTerm{\Gamma}{\mu^+~m~t}{\cL(\nu^+~\sigma~T)}} &= (m, "lam"~t) \\ 
  \denotesT{\goodTerm{\Gamma}{\cCt m}{\cC\sigma}} & \text{ is defined upon } \denotesT{m} \text{ and inductively on the signature length} \\ 
  \denotesT{\goodTerm{\Gamma}{\cCt m}{\cC\sigma}} &= 
  (\denotesT{\cCt o}, t["sf"~f][("id", \denotesT{\cCt o})]) \\
  & \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}}, \text{ where } o = "pjl"~m, t = "app"~("pjr"~m), f = p_f\nu~\sigma \\ 
  \denotesT{\goodTerm{\Gamma}{\cCt m}{\cC \sigma}} &= () \quad \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}}
\end{align*}
\begin{align*}
  \denotesT{\goodInh{\Gamma}{\_}{\sigma_1}{\sigma_2}} &= \goodTerm{\Gamma, \cL\sigma_1}{\_}{\cL\sigma_2[\pi_1]} \\ \text{ and thus } \denotesT{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}} &\iff  \goodTerm{\Gamma, \cL\sigma_1}{h}{\cL\sigma_2[\pi_1]} \\
  \denotesT{\goodInh{\Gamma}{"inhinh"~h~T~\uparrow^s}{(\nu^+ \  \sigma_1 \  T)}{(\nu^+ \  \sigma_2 \  T[(\pi_1, \uparrow^s)])}} &= \mu^+~(h[(\pi_1,\pi_1\mu~\pi_2)])\\ &\quad \quad \{f_2[\pi_1]\}~(p_2\mu'~\pi_2)[(\pi_1, \uparrow^s[\pi_1^{\uparrow}])] \\
\end{align*}



