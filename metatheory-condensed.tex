We contribute \TT, a core type theory that extends
%\underline{f}a\underline{m}i\underline{l}y polymorphism
%\underline{M}artin-\underline{L}√∂f dependent \underline{t}ype \underline{t}heory (MLTT)~\cite{martin1982constructive}
\citeauthor{martin1982constructive} dependent type theory (MLTT)
with facilities to express family polymorphism
while maintaining consistency and canonicity.
%\NA{maybe you can give an overview of the salient points of the design and what they're trying to achieve? What is the core aspect modeled by the theory?}
%

For accessibility of the main text, \cref{sec:metatheory2} presents \TT using
named variables and meta-level substitution.
For clarity of proof details, the technical appendix supplementing
\cref{sec:metatheory2} instead uses de Bruijn indices and explicit substitution.
%
We acknowledge that the presentation is dense for an audience
unacquainted with MLTT, so we summarize the salient points first.

\noindentparagraph{Summary.}

\TT is intended as a foundational model. So unlike our programmer-facing plugin,
%typing is structural rather than nominal\EDJ{I don't actually know what do you mean by structural here. I think surface syntax (Coq) is pretty structual as well.}, and
fields automatically axiomatized by the plugin require explicit definitions in \TT.
%
\TT provides MLTT-style constructs that can be used to express families and
family polymorphism. %rather than building it in directly.
%
Most notably, it extends MLTT with what we call \emph{linkages}.
Linkages are a namesake of the theoretical device through which \citet{zm2017} model
family polymorphism in an OO setting, but the technical details differ significantly from the prior work.

\begin{itemize}
[labelsep=*,leftmargin=1pc,itemsep=3pt]
\item 
Linkages model families; they are like tuples composed of fields,
with field names represented by variable bindings.
But there is a twist: linkages support late binding.
Unlike dependent tuples where a later component is \emph{existentially}
quantified over the earlier ones, a linkage component is \emph{universally}
quantified over---and thus polymorphic to---the components preceding it.\Zhixuan{explain the intuition behind the (typing rule of) linkages, and try to connect it to the ``family'' in the earlier section/surface syntax}\EDJreply{I am not sure if more is needed because the section ``Family polymorphism via linkages'' is trying to do this. Maybe I should estabilish connection between Rule l/add with the compilation process of fam poly?}

\item
\TT features \emph{linkage transformers}, which model how a family can be
inductively constructed by inheriting fields from another family,
adding new fields, and overriding existing fields.
\item
Inductive types are modeled as W-types~\cite{martin1984intuitionistic} and their
extension as overriding.

\item
Consistency and canonicity of \TT are proved by giving semantic interpretations to the syntactic typing judgments.
\end{itemize}

%\TT supports extending inductive types through
%formation rules that enable the encoding of the further binding of W-types~\cite{martin1984intuitionistic} in linkages.

%Also unlike our plugin, \TT does not feature automations such as
%the generation of propositional equalities and partial recursors,
%but it is expressive enough to encode their definitions.

% \input{mltt-selected.tex}
\input{mltt-selected-named.tex}
\input{fmltt-selected-named.tex}

\noindentparagraph{Brief review of MLTT.}

\cref{fig:mltt-selected} presents the syntax and selected typing rules of MLTT %(predicative) MLTT
(and \cref{fig:fmltt-selected} \TT).
Dependent function types \nTyPi{x}{A}{B},
dependent pair types \nTySigma{x}{A}{B}, and
identity types \TyId{t_1}{t_2} are standard.
So are their introduction and elimination forms.
Capture-avoiding substitution is notated $\bullet[\bullet/x]$.
A singleton type $\TyS{t}$ helps expose the definition of a term~$t$
in its type (rule \ruleref{tm/s})~\cite{aspinall1995singleton,stone2000}.
Definitional equalities have the forms %(for each judgement)
\goodCtx{\Gm_1 \equiv \Gm_2}{},
\goodType{\Gm}{T_1 \equiv T_2}{},
\goodTerm{\Gm}{t_1 \equiv t_2}{T},
etc.
Following \citet{altkap2016}, we regard our (intrinsically typed) syntax
as being quotiented by these equalities.
Quotienting facilitates coercion along equalities---given
\goodCtx{\Gm_1 \equiv \Gm_2}{} and
\goodType{\Gm_1}{T_1 \equiv T_2}{},
the derivation of \goodTerm{\Gm_1}{t}{T_1} is considered definitionally equal to
a derivation of \goodTerm{\Gm_2}{t}{T_2}.\YZ{Is this accurate?}
%\YZ{should there be a convertibility rule?}\EDJreply{in this style, the quotient by judgemental equality is applied, so A is equal to B even in meta-logic, which means t : A is the same as t : B. Maybe this is something require emphasis? Because it is usually handled by LF (like QIIT) but now we are using bare hands so.... maybe we need to emphasize this}
%For each derivation (of each judgment)\YZ{I don't get what 'each derivation' or 'each judgment' means}\EDJreply{(G |- t : T), which looks like (t : Tm G T) in QIIT/Agda is the derivation; so basically the term is the derivation (or proof), the types (Tm G T) is the judgement. It applies to each kind of judgement, for example, (G |- ), which looks like (G : Con), (G |-) is the derivation and (_ |- )is the judgement \\ 
%Note that without referring to QIIT/Agda, the definition of judgement and derivation is still clear -- (G |- _ : T) is a judgement and a concrete proof/derivation we get for t like (G |- t : T) is the derivation. Similar for ( _ |- ) vs. (G |-) and (G |- _ ) vs (G |- T). \\ 
%I think in intrinsic typing, knowing t and knowing (G |- t : T) is exactly the same (i.e. there are no two different derivations lead to the same t; for each t, there is only one derivation for it). This is not true for extrinsic typing. \\
%If this prequisite knowledge is too involved, feel free to delete this sentence, I think I just want to say there are equality/quotient everywhere between all kinds of derivations(proof?data?) -- equality between terms, types, substitutions, contexts, linkage signatures ...\\
%I think this is something standard from Martin Lof, since Martin Lof is the first guy talk about judgement.
%}

Following \citet{kaposi2019gluing}, we use \emph{Universe √† la Coquand} \cite{coquand2013presheaf}. Unlike Russell-style ones, Coquand universes are not inhabited by types directly but rather by the \emph{codes} of types
and arguably behave better due to its closedness to Tarski-style ones~\cite{luo2012notes}. 
% and compatibility with our algebraic formulation of MLTT~\cite{coquand2018canonicity}. % I am not sure if I want this sentence or not
Term $\codety{T}$ encodes type~$T$ (\ruleref{tm/c}) and thus inhabits universe~$\cU$.
Type $\El{t}$ decodes term~$t$ (\ruleref{ty/el}).
%\footnote{By contrast,  Russel-style universes are inhabited by types directly.  Tarski-style universes are ``semantically more fundamental'' \cite{luo2012notes} and friendlier to our meta-theoretical reasoning.}
There is an infinite hierarchy of universes;
we omit universe levels in the presentation to avoid clutter.
%\rA{Why is W(t) a term and not a type?}\YZreply{I think the reviewer is wondering what is gained by encoding and decoding types, compared to types directly inhabiting universes.}

% We use intrinsically typed syntax \cite{church1940}---terms and types are well-formed by construction.
For concision, typing rules omit obvious premises required for well-formedness.
For example, \ruleref{tm/lam} implicitly requires $\goodCtx{\Gm}{}$
(i.e., that the context be well-typed).

%We briefly review the base MLTT fragment first.
%
% In keeping with the recent trend~\cite{altkap2016,coquand2018canonicity,gratzer-sterling-birkedal-2019}\YZ{Does coquand2018canonicity really use explicit subst?}\EDJreply{Yes it is. Look at Section 2.1. When he starts reasoning, he actually deals with category with family (instead of the typing rules), where he consider morphism between contexts, which is substitution. But I agree it can be a bit ambiguous to see (because he literally show two version of MLTT without connecting them---one classical typing rule version, the other directly works on Category with Family (CwF)) but since his proof is mainly on Category with Family, so it counts as explicit substitution. But if you are concerned, we can change to Andras Kovacs "Generalized Universe Hierarchies and First-Class Universe Levels". or Andreas Abel's "Decidability of Conversion for Type Theory in Type Theory". The former one directly work on CwF, the latter one include substitution as part of the raw syntax.}
% in MLTT presentations, we use \emph{explicit substitutions}~\cite{substcalculus,abadi1989subst}:
% substitutions~$\gm$ and their applications (e.g., \sub{T}{\gm}) are part
% of the syntax rather than meta-operations.
%
% Variables are in the form of \citeauthor{debruijn1964} indices:
% \var{n} is the variable bound by the $n$-th closest enclosing binder.
% For example, $\lambda x.\,\lambda y.\,x$ is $\lam{\lam{\var{1}}}$.
%
% Substitutions are typed with the form 
%\EDJ{It seems to me G |- g : D is a judgement not a rule. Rules usually have two parts (premises + conclusion). Judgment is a standard terminology invented by Martin Lof (https://ncatlab.org/nlab/show/judgment see reference here). I will suggest saying 'Formation rules for substitution lead to a judgement G |- g : D' sth like this. In pen-and-paper, the formation rule (corresponding to QIIT well-typed-ness of judgement) is called presuppose (can be found in Modal MLTT paper) }
% $\goodSub{\Gm}{\gm}{\Dl}$.
% The idea is that applying~$\gm$ to terms valid in the context~$\Dl$
% yields terms valid in~$\Gm$ (\ruleref{tm/sub} and \ruleref{ty/sub}).
% %
% The two main forms of substitutions are weakening (\ruleref{sub/wk}) and extension (\ruleref{sub/ext}):
% \sub{t}{\SubstWeak{n}} introduces $n$ free variables into the context of $t$, and
% \sub{t}{\SubstExt{\gm}{t'}} substitutes~$t'$ for~$\var{0}$ in~$t$ and
% then applies~$\gm$.
% For example, rule \ruleref{tm/snd} states that if $t$ is a dependent pair
% that has type $\TySigma{A}{B}$, then $\snd{t}$ has type
% $\sub{B}{\SubstExt{\SubstWeak{0}}{\fst{t}}}$,
% where $\SubstId$ is the identity substitution (\ruleref{sub/id}).

\noindentparagraph{Introducing and eliminating inductive types.}

% TODO: Remove mentioning conventional Wtype here

W-types~\cite{martin1984intuitionistic} are a succinct way to model
inductive types in MLTT.
Together with the identity type, they can express a
whole host of inductive types~\cite{hugunin2021not}.
%
In our formulation, a W-type is given by a W-type signature $\goodWSig{\Gm}{\wsig}{n}$ 
composed of $n$ pairs of types (\ruleref{wsig/empty} and \ruleref{wsig/add}).\Zhixuan{Page 14: I don't see the necessity of introducing "enhanced W-types". Since there are already boolean types and Œ£ types, Fin types can be defined. Using Fin, ordinary W types suffice to define trees with n constructors. So it might be clearer to just define 'enhanced W-types' as syntactic sugar.}\YZreply{I concur.}\EDJreply{This following sentence has been replied to Zhixuan and he doesn't has further response: 1. We have to have enhanced W-type at FMLTT, that's for sure. Otherwise we (a). are too far away from the surface syntax because W-type itself only has one constructor all the time (b) this suggested encoding or syntactic sugar, since it interact with other connective like linkage (the Wrec is the interaction), so Wrec part is mostly unchanged  (c) since they will look the same, the encoding itself will look like an extra equality judgement in the syntax... which is not helpful for the complexity at all ... and even more complex  \\
2. so to me the problem you guys really have is around the content in the appendix -- I think Zhixuan mean he doesn't think this is more expressive. But my point is, it is hard to really write out the above syntactic sugar, formally. I think the issue here is similar to other reviewer saying "syntax translation". It is very hard to write out the encoding of Fin already, and then encode it again into W-type. (Just ask my agda mechanization). Of course, some hand-waiving can be done. For example, the part Zhixuan says I think it okay to hand-wave. But the destruction part -- the part Wrec interact with this encoding, I don't believe handwaving is enough. \\
3. But how do I say this to the audience? I mean the main reason I didn't choose syntactic translation/syntax sugar is basically ``doing encoding is harder than directly working in ambient logic.'' }
%
Each pair models a constructor of the inductive type.
The $i$-th pair, projected from the signature~$\wsig$ using the forms
$\goodType{\Gm}{\wsigproj{i}{1}{\wsig}}{}$ and
$\goodType{\Gm,x : \wsigproj{i}{1}{\wsig}}{\wsigproj{i}{2}{\wsig}}{}$,
defines the $i$-th constructor.
That is, given two arguments $\goodTerm{\Gm}{t_1}{\wsigproj{i}{1}{\wsig}}$ and
$\goodTerm{\Gm, x : \nsub{\wsigproj{i}{2}{\wsig}}{x}{t_1}}{t_2}{\El{\wcode{\wsig}}}$,
we can construct a term $\Wsup{i}{\wsig}{t_1}{x.t_2}$ of the W-type (\ruleref{tm/wsup}).
$\wcode{\wsig}$ gives the code of the
W-type (\ruleref{tm/w}).

W-types are eliminated with the form $\Wrec{\wsig}{\lkg}{t}$, where $t$ is of a
W-type $\El{\wcode{\wsig}}$, and $\lkg$ is essentially an $n$-tuple of
case handlers for the $n$ constructors in~$\wsig$ (\ruleref{tm/wrec}).
Each case handler has a type of form $\CaseSig{A}{B}{T}$, where
$T$ is the motive of the recursion (\ruleref{tyeq/casety});
for simplicity, we model non-dependent motives for recursion.
The collection of case handlers~$\lkg$ encodes those defined and inherited
by an \lsti{FRecursion} command in our plugin.
We choose to type it with a linkage type $\TyLkg{\RecSig{\wsig}{T}}$
to avoid introducing non-dependent $n$-tuples, which linkages generalize.



% \begin{figure}
%   \begin{tabular}{llll}
%     \hline
%     \multicolumn{1}{|l}{\cellcolor[HTML]{C0C0C0}surface syntax} &
%       \multicolumn{1}{l|}{Equivalent Type} &
%        &
%       \multicolumn{1}{l|}{} \\
%     \multicolumn{1}{|l}{\cellcolor[HTML]{C0C0C0}| unit : tm} &
%       \multicolumn{1}{l|}{$\bbone \times (\bbzero \to tm) \to tm$} &
%       \multicolumn{1}{c}{$\tau'$} &
%       \multicolumn{1}{l|}{$\coloneqq\WSigAdd{\WSigEmp}{\bbone}{\bbzero}$} \\
%     \multicolumn{1}{|l}{\cellcolor[HTML]{C0C0C0}| app  : tm -\textgreater tm -\textgreater tm} &
%       \multicolumn{1}{l|}{$\bbone \times (\bbtwo \to tm) \to tm$} &
%       \multicolumn{1}{c}{$\tau$} &
%       \multicolumn{1}{l|}{\cellcolor[HTML]{FFFFC7}$\coloneqq\WSigAdd{\tau'}{\bbone}{\bbtwo}$} \\ \hline
%     \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}unit} &
%       $\coloneqq \Wsup{1}{\tau}{\unit}{"elim-"\bbzero}$ &
%       \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}app unit unit} &
%       $\coloneqq\Wsup{0}{\tau}{\unit}{"unit"}$ \\ \hline
%     \cellcolor[HTML]{ECF4FF}$\lsig' = \LSigAdd{\LSigEmp}{\pi_2}{\TyS{\wcode{\tau'}}}$ &
%       $o' = \LkgAdd{\LkgEmp}{\wcode{\tau'}}$ &
%       \cellcolor[HTML]{ECF4FF}$\lsig = \LSigAdd{\LSigEmp}{\pi_2}{\TyS{\wcode{\tau}}}$ &
%       $o = \LkgAdd{\LkgEmp}{\wcode{\tau}}$ \\
%     \cellcolor[HTML]{ECF4FF}$\lsig'^+ = \LSigAdd{\lsig'}{s'}{..}$ &
%       $o'^+ = \LkgAdd{o'}{t}$ &
%       \cellcolor[HTML]{ECF4FF}$\lsig^+ = \LSigAdd{\lsig}{s}{..}$ &
%       $o^+ = \LkgAdd{o}{\lkgproj{2}{o'^+}}$ \\
%     \multicolumn{2}{l}{$A = \TySigma{\cU}{\El{\pi_2} \to \El{\pi_2}} $} &
%       \multicolumn{2}{l}{$t = \goodTerm{\cdot , A}{\snd{\pi_2}}{\El{\fst{\pi_2}} \to \El{\fst{\pi_2}} }$} \\
%     $\goodTerm{\cdot , \TyTkg{\lsig'}}{s'}{\sub{A}{\pi_1}}$ &
%        &
%       $\goodTerm{\cdot , \TyTkg{\lsig}}{s}{\sub{A}{\pi_1}}$ &
      
%     \end{tabular}
%   \caption{W-type encoding of "tm \{unit, app\}"}
%   \label{fig:Wtype-example}
% \end{figure}


% We illustrate one concrete example in \cref{fig:Wtype-example} of a "tm" with only two constructors, 
% also as a review for how W-type encodes a given inductive type. The key insight 
% is, to encode one constructor into a pair $(\wsigproj{i}{1}{\wsig}, \wsigproj{i}{2}{\wsig})$, the non-recursive part will be stored in $\wsigproj{i}{1}{\wsig}$ 
% while the ``arity'' of the  recursive part stores in $\wsigproj{i}{2}{\wsig}$. 
% For example, $"app" : ("tm" \to "tm" \to "tm")$ 
% $\cong ((\bbtwo \to "tm") \to "tm")$, saying the ``arity'' of the recursive part is $\bbtwo$ 
% (or boolean type, as a type with two elements). Similarly, the ``arity'' of recursive part of "unit" is 0. 
% Both constructors don't store other information thus $\bbone$. We hightlight $\tau$ as the 
% signature of our "tm" and showcase the meta-theoretic encoding of "unit" and "app~unit~unit". $"elim-"\bbzero$ indicates the elimination of the bottom type $\bbzero$ in the context. Generally speaking, the expressiveness of W-types comes from the ``arity'', as it encodes the case when recursive structure stores as the output of a function, mirroring the strict positivity of Inductive type.


Rules \ruleref{tm/wsup} and \ruleref{tm/wrec} require access to~$\wsig$:
the W-type is exhaustively generated by its constructors, and
its elimination must exhaustively handle all the constructors in
its signature.

In contrast, $\wsig$ should be hidden from the typing context of any
term that does not invoke $\Wsup{}{\wsig}{\cDot}{\cDot}$ or $\Wrec{\wsig}{\cDot}{\cDot}$, so that
the term can be reused---without being rechecked---for a different
W-type signature~$\wsig'$ that extends~$\wsig$ with additional
constructors.
Moreover, the typing of the term should be made parametric to
the definitions of those fields that invoke $\texttt{Wsup}$ or $\texttt{Wrec}$,
so that the term can be reused---without being rechecked---when those fields
are overridden to support the extended signature~$\wsig'$.
%
Such abstraction required by family polymorphism is supported via linkages,
which we discuss next.


\noindentparagraph{Family polymorphism via linkages.}

Family polymorphism requires late binding.
In \TT, families are expressed through linkages, and late binding of
field references is achieved by requiring that typing be polymorphic to
the definition of that field.

Well-formed \emph{linkage signatures} have the judgment form
$\goodSig{\Gm}{\lsig}{n}$.
As rules \ruleref{lsig/empty} and \ruleref{lsig/add} show, a linkage
signature is a list of $n$~types.
%
Well-formed \emph{linkages} have the judgment form $\goodTerm{\Gm}{\lkg}{\TyLkg{\lsig}}$,
where $\TyLkg{\lsig}$ is a type formed by~$\lsig$.
As rules \ruleref{l/empty} and \ruleref{l/add} show, a linkage is a list
of $n$~terms, each representing a field of the family modeled by the linkage.

In rule \ruleref{l/add}, the second premise $\goodTerm{\Gm, \mathit{self} : A}{t}{T}$ is
responsible for late binding.
Here, $A$ abstracts the context of the current field~$t$, controlling
how the types of the fields prior to~$t$ are exposed to the typing of~$t$.
Crucially, %unlike the second field in a dependent pair (\ruleref{tm/pair}),
the premise $\goodTerm{\Gm, \mathit{self} : A}{t}{T}$ makes clear that
the typing of~$t$ in \ruleref{l/add} is \emph{universally} quantified---%
rather than \emph{existentially} quantified as is in \ruleref{tm/pair}---%
over how the fields in $t$'s context are defined.
Late binding enables reuse.
A different linkage~$\ell'$ that overrides fields in $t$'s context (and thus models a derived family)
can reuse~$t$---without retyping it---by first
projecting~$t$ from $\LkgAdd{\lkg}{t}$ and then appending it to~$\lkg'$.
%\EDJ{I suggest change this sentence to `by projecting it out of parent linkage and adding it in the derived linkage'}.

%recorded by the first premise $\goodTerm{\Gm}{\lkg}{\TyLkg{\lsig}}$
The type~$A$ in \ruleref{l/add} and \ruleref{lsig/add},
abstracting the types of the prior fields, does not necessarily contain the same types as those recorded by~$\TyLkg{\lsig}$,
%\EDJ{Suggest changing to ``not necessarily the same as those recorded by lsig in the prior fields''},
because a field defined as the code $\wcode{\wsig}$ of a W-type has to
expose different types to different fields that come after it.
Later fields that invoke
$\Wsup{}{\wsig}{\cDot}{\cDot}$ or $\Wrec{\wsig}{\cDot}{\cDot}$
should see the concrete signature~$\wsig$, as rules \ruleref{tm/wsup}
and \ruleref{tm/wrec} stipulate.
By contrast, $\wsig$ should be hidden
from all other fields, so that they can be reused
in a different context where the W-type signature~$\wsig$ is replaced by an extended one~$\wsig'$.

\definecolor{A-color}{HTML}{E7EFC5}
\definecolor{T-color}{HTML}{FFF1D0}
\definecolor{t-color}{HTML}{FAE0E4}

\input{stlc-linkage-typing-named.tex}

We use \cref{fig:stlc-linkage-typing} to illustrate.
On the left is code excerpted from \cref{fig:stlc-mechanized}, and on the right
is how the corresponding fields are modeled and typed in \TT.
%
$\lkg_i$ is the linkage that adds the $i$-th field~$t_i$ with the typing
$\goodTerm{%
\tikzmarkin[disable rounded corners=true,set fill color=A-color,set border color=A-color]{A-i}(-0.02,-0.10)(-0.02,0.28)
\mathit{self}_i : A_i%
\tikzmarkend{A-i}%
}{%
\tikzmarkin[disable rounded corners=true,set fill color=t-color,set border color=t-color]{t-i}(-0.02,-0.10)(-0.02,0.28)%
t_i%
\tikzmarkend{t-i}%
}{%
\tikzmarkin[disable rounded corners=true,set fill color=T-color,set border color=T-color]{T-i}(-0.02,-0.10)(-0.02,0.28)%
T_i%
\tikzmarkend{T-i}%
}$.
%
For readability, we use a notation with explicit names
in this typing judgment:
we name the context as $\mathit{self}$ (cf.~\cref{fig:stlc-compiled})
and write its type~$A_i$, which is a dependent tuple type, as a
dependent record type with labels.
%
\begin{itemize}
% [leftmargin=4ex,itemsep=.5ex]
  [labelsep=*,leftmargin=1pc,itemsep=3pt]

\item 
The first field $t_1$ is defined as $\wcode{\wsig_{\texttt{tm}}}$
and given the singleton type $\TyS{\wcode{\wsig_{\texttt{tm}}}}$, where $\wsig_{\texttt{tm}}$
is the W-type signature for \lsti{tm}.
This typing is recorded by $\lsig_1$ and is thus available in all $\lsig_i$'s.

\item We illustrate the structure of W-type signature (as a list) here. $\wsig_{\texttt{tm}}^0, \wsig_{\texttt{tm}}^1$ are (the subparts of) the signatures of constructors \{"tm\_unit"\} and \{"tm\_unit","tm\_app"\} respectively. Each item in this W-type signature, having two types, corresponds to one constructor, where the first type stores the non-recursive part of the constructor and the second type stores the ``arity'' of the  recursive part. For example, the type of $"app" : ("tm" \to "tm" \to "tm")$ $\cong (\bbone \times (\bbtwo \to "tm") \to "tm")$, corresponds to the premise of rule \ruleref{tm/wsup} (where $\wsigproj{0}{1}{\wsig_{\texttt{tm}}^1} = \bbone, \wsigproj{0}{2}{\wsig_{\texttt{tm}}^1} = \bbtwo$). This type means there is no information on non-recursive part (thus use unit type $\bbone$) and the ``arity'' of the recursive part is $\bbtwo$ and thus $\wsig_{\texttt{tm}}^1 = \WSigAdd{\wsig_{\texttt{tm}}^0}{\bbone}{\bbtwo}$.  The story is similar for $\wsig_{\texttt{tm}}^0$, where there is no recursive part at all and thus the ``arity'' is zero.

Generally speaking, the expressiveness of W-types comes from the ``arity'', as it encodes the case when recursive structure stores as the output of a function, mirroring the strict positivity of Inductive type.
\item 
The next four fields model the four constructors of~\lsti{tm}.
Constructor \lsti{tm_unit} is modeled as $\Wsup{}{\wsig_{\texttt{tm}}}{\top}{\bot}$
and typed with $\El{\mathit{self}.\texttt{tm}}$, where $\mathit{self}$ stands for
the typing context containing the first field~\lsti{tm}.
The W-type signature $\wsig_{\texttt{tm}}$ is exposed in
this typing context; that is, \lsti{tm} has type $\TyS{\wcode{\wsig_{\texttt{tm}}}}$.
So $\El{\mathit{self}.\texttt{tm}}$ and $\El{\wcode{\wsig_{\texttt{tm}}}}$ can be equated,
as required by rule \ruleref{tm/wsup}.

\item
Similarly, $\wsig_{\texttt{tm}}$ is exposed in the typing context of
$t_{10}$, which models the recursive function \lsti{subst} by invoking
the recursor $\Wrec{\wsig_{\texttt{tm}}}{\cDot}{\cDot}$.
%
Like \lsti{subst}, partial recursors in \Lang are axiomatized by the plugin
(\cref{sec:latebind,sec:prec}), and they can similarly be defined in \TT
using $\texttt{Wrec}$.

\item
By contrast, $\wsig_{\texttt{tm}}$ is hidden from the typing of all other fields.
Their typing should depend on the knowledge that \lsti!tm! has type~$\cU$,
rather than \TyS{\wcode{\wsig_{\texttt{tm}}}},
so that they can be reused in a context where
\lsti!tm! is defined as $\wcode{\wsig'_{\texttt{tm}}}$,
where $\wsig'_{\texttt{tm}}$ extends~$\wsig_{\texttt{tm}}$ with additional constructors.
%
For example, in \cref{fig:stlc-linkage-typing}, the typing of the case handlers of
\lsti{subst} (e.g., $t_6$) is oblivious to the definition of \lsti!tm!---it sees only $\text{\lsti!tm!}:\cU$---so
the case handlers can be reused by a linkage modeling \lsti{STLCFix}.

\end{itemize}

The third premise
$\goodTerm{\Gm,x : \TyTkg{\lsig}}{\seal}{A}$
in rules \ruleref{l/add} and \ruleref{lsig/add} is
responsible for hiding W-type signatures.
Here, $\TyTkg{\lsig}$ is a dependent tuple type (rule \ruleref{tyeq/pk/add})
that packages the types of all fields preceding the current field~$t$,
and $\seal$ is the term turning the tuple $\Tkg{\lkg}$ of type
$\TyTkg{\lsig}$ (rule \ruleref{tmeq/pk/add}) into a new tuple of type~$A$
that hides W-type signatures behind $\cU$, if necessary.
%
It is straightforward to find the~$\seal$ that fits the bill, though this process
is not automated in \TT.
In particular, when no hiding is needed, $\seal$ is $\var{0}$
%\EDJ{$\var{0}$ is not identity (substitution), but the first variable, right? Or you meant to say it is identity ``sealing''?}\YZreply{Yes, I meant identity sealing. I cannot say 'sealing' because the paper currently does not use the word sealing anywhere.}\EDJreply{What about just remove the parenthesis and ``the identity''}
and $A$ is $\TyTkg{\lsig}$.
In \cref{fig:stlc-linkage-typing}, $\seal_1$, $\seal_2$, and $\seal_{10}$ are $\var{0}$,
and $\seal_6$ is from
\begingroup
\fontsize{9}{9}\selectfont%
$\big[\texttt{tm} : \TyS{\wcode{\wsig_{\texttt{tm}}}},\ \texttt{tm\_unit} : \El{\texttt{tm}},\ \dadada\big]$
\endgroup
to
\begingroup
\fontsize{9}{9}\selectfont%
$\big[\texttt{tm} : \cU,\ \texttt{tm\_unit} : \El{\texttt{tm}},\ \dadada\big]$%
\endgroup
.

When a family is concluded (e.g., \lsti!End!~\lsti!STLC!),
a linkage~$\lkg$ containing all the fields is available
(e.g., $\lkg_{53}$ in \cref{fig:stlc-linkage-typing}).
Fields of the family can then be accessed by projecting them out of the tuple
$\Tkg{\lkg}$.


\noindentparagraph{Linkage transformers.}

Inheritance and code reuse can already be expressed through the projection
of fields out of linkages and their inclusion into new linkages.
To make common patterns of linkage manipulations more convenient,
\TT provides a ``library'' of \emph{linkage transformers}, whose well-formedness judgments
have form $\goodInh{\Gm}{h}{\lsig_1}{\lsig_2}$. The idea is that
applying~$h$ to a linkage of type~$\TyLkg{\lsig_1}$ yields a linkage of
type~$\TyLkg{\lsig_2}$ (\ruleref{tm/inh}).
%Linkage transformers are second-class; the only way to use them is to
%apply them to linkages to form new linkages.

Derived families can be modeled as linkage transformers inductively
constructed from the introduction forms
$\small\InhId$, $\small\InhExt{h}{x.t}$, $\small\InhOv{h}{x.t}$, $\small\InhInh{h}$, etc.
\cref{fig:fmltt-selected} shows the $\beta$-rule of an exemplary transformer,
\ruleref{tmeq/ov/beta}.
It states that applying the transformer $\small\InhOv{h}{\mathit{self}_2.t_2}$ to
a linkage of form $\LkgAdd{\lkg}{\mathit{self}_1.t_1}$
overrides the linkage's last field~$t_1$ with~$t_2$.
For instance, the construction below shows that 
$\small\InhOv{\InhId}{\wcode{\wsig'_{\texttt{tm}}}}$
is used as the first step in creating a linkage transformer modeling a derived family that
overrides $\wsig_{\texttt{tm}}$ with an extended
signature~$\wsig'_{\texttt{tm}}$:
\vspace{.9ex}

\noindent
\input{stlcfix-linkage-typing.tex}

\noindent
\ifreport \cref{sec:lt-in-action}
\else A supplemental appendix
\fi
sketches how the other introduction forms of linkage transformers
can be used to model the construction of a derived family as a linkage transformer.

\noindentparagraph{The complete formalization.}

% The definitive version containing all the rules in \TT is stated in
% terms of a meta\-language supporting quotient inductive-inductive types
% (QIITs)~\cite{nordvall2010inductive,altkap2016}.
% QIITs support equality constructors, which facilitate the expression of
% conversion rules (e.g., \ruleref{tmeq/sub/id}).
% The formalization is available as a supplemental file in Agda syntax,
% though it is not checked by Agda because Agda does not support QIITs
% natively.
% An effort to mechanize the formalization is underway, using Agda's
% \lsti{REWRITE} pragma to replace the limited uses of equality reflection.

The definitive version containing all the rules in \TT is stated in
\ifreport \cref{sec:complete-fmltt}.
\else a supplemental appendix.
\fi
using de Bruijn indices and explicit substitution.
An effort to mechanize the formalization is underway, by following  \citet{altkap2016} 
to use quotient inductive-inductive types as 
the logical framework to state the syntax and using Agda's
\lsti{REWRITE} pragma to replace the limited uses of equality reflection appeared in 
an extensional meta\-logic. 


%a \textbf{pen-and-paper} formalization
%assuming the facility of quotient inductive-inductive
%types~\cite{nordvall2010inductive,altkap2016} and extensional equality
%(equality reflection), available as a supplemental file in a
%\textbf{(pseudo-)Agda syntax}. Our formalization is directly following
%Agda syntax and type-checking (equality-checking) is done manually,
%leaving traces in the comments. We are currently working on mechanizing
%it and relying on Agda's rewriting mechanism to replace our limited
%usage of equality reflection. 
%
% We also typeset a more complete set of rules than the space allows and
% present it in
% \ifreport \cref{sec:complete-fmltt}.
% \else a supplemental appendix.
% \fi

\input{cc-condensed.tex}

\ifShowOldWriting
\newpage

To formalize our metatheory, we follow the formulation of~\citet{altkap2016}, which provides a declarative and intrinsic style of the predicative \textit{Martin-Lof Type Theory} (MLTT)~\cite{martin1982constructive},
using \textbf{Quotient Inductive Inductive Type}(QIIT)\footnote{Inductive Inductive Type(IIT) is a generalization of mutual inductive type where (indexed-)types \mintinline{Coq}{A : Type, B : A -> Type} can be defined mutually. QIIT further enhances IIT by allowing equality constructor (i.e. mathematical quotient).}, \textbf{explicit substitution} and \textbf{debruijn indices} as the main tool. 
Generally speaking, we \textbf{use each QIIT type to represent each kind of judgements, and thus a term will represent a derivation of a judgement}. The classical formulation of dependent type theory requires a lot of \textit{presupposition} and quotient afterwards, causing a lot of duplicacy. Both issues can be concisely solved by using QIIT expressing intrinsically typed syntax instead. What's more, working \textbf{in a type-theoretical setting} using QIIT makes checking of the pen-and-paper proof easier. However, we will follow conventional notation and thus the reader might not notice the usage of QIIT explicitly.\EDJ{We might be able to remove QIIT in the main text totally. Let's try to do it later.}

$$
\Rule[name=Subst]
{\goodType{\Delta}{T}{} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{}},
\Rule[]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
\quad
\Rule[name=Dbj Indices]
{}
{\goodSub{\Gamma, A}{p^1 \gamma}{\Gamma}},
\Rule[]
{}
{\goodSub{\Gamma, A}{"var"_0}{A[p^1]}}
$$

% Explicit substitution
Instead of meta-level substitution, we use \textbf{explicit substitution}, i.e., substitution itself is a expression in the program and will be done in the runtime. Thus substitution has its own judgement $\goodSub{\Gamma}{\gamma}{\Delta}$. We can apply substitution to types and terms\footnote{The type judgement is the form $\goodType{\Gamma}{T}{}$. The term judgement is the form $\goodTerm{\Gamma}{t}{T}$} in MLTT via \ruleref{Subst}.  Note how substitution will change the context---we suggest intuitvely understanding context as holes of the term/types and substitution as filling those holes, where the substitution itself has holes. After filling the holes, then the new context is about the holes of the substitution. We have an identity substitution $\goodSub{\Gamma}{"id"}{\Gamma}$.
% Debruijn Indices
Contrary to named variables, \textbf{debruijn indices} refer to the variable in the context like operating a stack. We will use "var"$_i$ indicating the $i$-th variable (from right to left, $i$ starts with 0) in the context.  On the other hand, we can also get the rest part of the stack, or ``subpart of "id"'' using $\goodSub{\Gamma, A}{p^1 \gamma}{\Gamma}$.  For example, we can get the very first variable in the context $\Gamma, x : T \vdash x : T$ by $\goodTerm{\Gamma, T}{var_0}{T[p^1]}$. Note here $T$ is a type in $\Gamma$, but now shifted into $\goodType{\Gamma, T}{T[p^1]}{}$ using $p^1$. Similarly, to get the second and prior variables, we use "var"$_i$ and $p^{i+1}$ correspondingly. 


Now, we will mainly focus on the newly introduced typing rules, and illustrate their connection to the plugin implementation. For those curious about the complete meta-theory formulation, we refer to our appendices or \citet{altkap2016, kaposi2017type} or maybe those not using QIIT \cite{coquand2018canonicity, sterling2019algebraic}. Our metatheory is formulated using QIIT in an extensional setting.

$$
\Rule[name=wsig/ept]
{""}
{\goodWSig{\Gm}{\WSigEmp}{0}}
\quad 
\Rule[name=wsigeq/ept/eta]
{\goodWSig{\Gm}{\wsig}{0}}
{\goodWSig{\Gm}{\wsig \equiv \WSigEmp}{0}}
\quad
\Rule[name=wsig/add]
{\goodWSig{\Gm}{\wsig}{n}
  \quad \goodType{\Gm}{A}{}
  \quad \goodType{\Gm, A}{B}{}}
{\goodWSig{\Gm}{\WSigAdd{\wsig}{A}{B}}{n+1}}
\quad
\Rule[name=wsig/universe]
{\goodWSig{\Gm}{\wsig}{n}}
{\goodType{\Gm}{\TyWSingle {\wsig}}{}
\\ \goodTerm{\Gm}{\wsingle{\wsig}}{\TyWSingle{\wsig}}
}
$$
$$
\Rule[name=ind/cstr]
{{\goodWSig{\Gm}{\wsig}{n}}
  \\ \goodTerm{\Gm}{a}{\wsigproj{j}{1}{\wsig}}
  \\ \goodTerm{\Gm, \sub{\wsigproj{j}{2}{\wsig}}{(id, a)}}{b}{\El{(\wcode{\wsig})}}}
{\goodTerm{\Gm}{\Wsup{}{T}{a}{b}}{\El{(\wcode{\wsig})}} }
$$
$$
\Rule[name=ty/casesig]
{\goodType{\Gm}{A}{}
\quad \goodType{\Gm, A}{B}{}
\quad \goodType{\Gm}{R}{}
}
{\goodType{\Gm}{\CaseSig{A}{B}{R} \equiv (\TyPi {A} {(\TyPi {(\TyPi {B} {(\sub{R}{ \SubstComp {\pi_1}{\pi_1}})})} {\sub{R}{\SubstComp{\pi_1}{\pi_1}}})} )}{}}
\quad 
\Rule[name=Hdlers]
{\goodWSig{\Gamma}{\tau}{n}
\quad \goodType{\Gamma}{R}{}
}
{\goodSig{\Gamma}{"RecSig"~\tau~R}{n}}
$$
$$
\Rule[name=reclkg/proj]
{ \goodWSig{\Gm}{\wsig}{N}
\\ \goodTerm{\Gm}{o}{\TyLkg{(\RecSig{\wsig}{R})}}
\\ j < N
}
{\goodTerm{\Gm}{\Recproj{j}{o}}{\sub{(\CaseSig{(\pi_1^j \wsig)}{(\pi_2^j \wsig)}{R})}{\pi_1}}}
$$
$$
\Rule[name=tm/wrec]
{ \goodWSig{\Gm}{\wsig}{N}
\\ \goodType{\Gm}{R}{}
\\ \goodTerm{\Gm}{r}{\TyLkg{(\RecSig{\wsig}{R})}}
\\ \goodTerm{\Gm}{w}{\El{(\wcode{\wsig})}}
}
{\goodTerm{\Gm}{\Wrec{\wsig}{w}{r}}{R}}
\YZ{I suppose Rec-Constr is only for exhaustivity checking? If so, then would it be more intuitive to not include the w in the term? And I suppose the programmer will want to use sealing to hide its type, or otherwise it would fail to normalize for lack of a beta rule?}\EDJreply{ 1. Yes. But not include w will cause $"Wrec"~r$ be a function type. we are not supposed to add a new intro-rule for function type(or for any other type), this is bad meta-theory design. \\
  2. It is actually the other way around -- if things are abstracted, then no beta rule can apply. More concretely, $T : \bW\tau$ is abstracted into $T' : \cU$, then this later one we cannot use $"Wrec"$ on it for sure. But once we have $\{T : \bW\tau, "rec" : \cL(RecSig~\tau)\}$ we are okay, and this, after wrap "rec" with an lambda abstraction, we will have $\cC\{T : \bW\tau, "rec" : \cL(RecSig~\tau~R), "recf" : T -> R\}$ as compilation type. Then with sealing abstraction, we will have $\Sigma(T : U, \Sigma ("rec" : ?, \Sigma("ref" : T -> R)))$ 
}\YZreply{
  What happens if the programmer forgets to seal "rec"? I suppose rec
  could still be inherited into a derived family. But it would not be
  useful if the inductive type is extended there, because rec is
  applicable only to the inductive type defined in the base family.
}\EDJreply{
  You are right. Since "rec" has type "\cL(RecSig~\tau~R)", after inheritance, it is basically the same type "rec : \cL(RecSig~\tau[k]~R[k])" for some "k" stands for the upcasting. but the most important $\tau[k]$ has an  unchanged shape (like the number of constructors) so it is still a recursor for inductive type of signature $\tau$. Once the parent inductive type $\bW\tau$ is extended $\bW\tau_2$ in the children family, with enriched signature $\tau_2$, then because of the signature inconsistency with $\tau[k]$, this old recursor is not useful for this new inductive type.    \\
  In other words, this recursor linkage "rec" can be used for any inductive type with signature $\tau$.
}
%\YZreply{
%  So there IS a beta rule for recursor (but you don't show it), right?
%}\EDJreply{
%  Yes. 
%  % https://github.com/DKXXXL/Redstone/blob/46c2420982e1fac50138924cdd7e152786cd38c8/Sketch/Extensible-Module-1/Syntax.agda#L589 \\ 
%  The only reference is here, but I commented out this url. The reduction applies to $"Wrec" \_ \_ ("Wcstr")$. \\
%  We also have canonicity (i.e. a closed term of boolean reduces to true or false), so there is definitely a beta rule for inductive type.
%}\YZreply{I'd add typeset this beta rule}\EDJreply{I just realize you use the words normalize. I will say currently this system cannot ``reduce'' any open term. But can only ``reduce'' close term. \\ 
%When the programmer program on this meta-theory, they don't need canonicity or normalization at all (they write out a chain of  judgemental equality by themselves). If they program on a proof assistant, then our proof assistant will need normalization to do type checking.
%
$$
$$
\Rule[name=tmeq/rec/beta]
{\goodTerm{\Gamma}{h}{\cL(\RecSig{\tau}{R})} 
\\ \goodTerm{\Gamma}{T}{\TyWSingle{\tau}}}
{\goodTerm{\Gamma}{\Wrec{\wsig}{h}{(\Wsup{}{\wsig}{a}{b})} \equiv 
(\app{((\app{(\Recproj{j}{h})} )[("id", a)])} )[("id", \lam{(\Wrec{\wsig}{h[\pi_1]}{b})})]
}{R}}\EDJ{"app" and "lam" are lambda application and abstraction}
$$


We start with the formulation of (extensible) inductive type, which is close to W-type (\ruleref{WSig-Add} requires a pair of types $A \vdash B$ as well), but with mulitple constructors. Thus we have a brand new judgement ${\goodWSig{\Gamma}{\tau}{n}}$ indicating signature of inductive type by its constructors. Unconventionally, a signature can induce a "universe" of types $\bW\tau$---in other words, $T : \bW\tau$ will be the inductive type instead of $\bW\tau$ itself. "Wsup" is used to construct a specific term of a given inductive type.


% When programming via meta-theory, we usually seal the inductive type, only expose its constructors (as a mundane function member) and hide the eliminator by abstracting $T : \bW\tau$ into $"W"~T : \cU$. Then the following fields---those only rely on this interface with $\cU$---can be inherited to other contexts (e.g. using enriched inductive type), as long as the targeting contexts can be abstracted into this {interface} again. 

Similar to plugin implementation, we delegate handlers (and their reuse) for recursion to linkages (and their inheritance). We use "RecSig1" to compute the type of a single handler and "RecSig" for the complete family of handlers for all constructors. \ruleref{Rec-Constr} uses "RecSig" to achieve exhaustiveness checking on elimination. The partial recursors and the computational axioms are treated as normal fields as expected, since we know they are provable in the plugin implementation. 

To introduce the concrete programming on inductive type in metatheory, we need to first introduce the formulation of families.


%\YZ{
%    Is extensionality in conflict with the claim in ¬ß3 that "subst tm_unit x t" and "tm_unit" are
%    not definitionally equal but propositionally equal in family STLC?
%}\EDJreply{No, TLDR: it is a different level. \\ 
%There are two type theories, one is Agda-like (= Latex = Conventional math), the other is the one formulated in QIIT. This sentence is saying that the Agda-like one is extensional MLTT (i.e. we have function extensionality and etc here in Latex writing directly). \\ But the one you are asking about is in the metatheory in QIIT: if we have an identity type $Id x y$ (propositionally equal) can we have a judgemetnal equality for the two terms in QIIT $x \equiv y$. \\
%Apparently, we don't setup our QIIT formulation in this way (I thought we need, but now I don't think we need it. Our QIIT formulation is purely in intensional MLTT now).\\ 
%But even if we do setup like that, I will not say a conflict is happening (because it is to our advantage if we have judgemental equal in metatheory). I will say it is a bit off as to how Coq is formulated (Coq is closer to an intensional MLTT, so no judgemental equal only propositional one). 
%}

% linkage, signature and compilation and seal
$$
\Rule[name=lsig/ept]
{""}
{\goodSig{\Gm}{\LSigEmp}{0}}
\quad
\Rule[name=ty/lkg]
{\goodSig{\Gm}{\lsig}{n}}
{\goodType{\Gm}{\TyLkg{\lsig}}{}
\\ \goodType{\Gm}{\TyTkg{\lsig}}{}}
\quad
\Rule[name=lnkg/pkg]
{ \goodTerm{\Gm}{o}{\TyLkg {\lsig}} 
}
{
  \goodTerm{\Gm}{\Tkg {o}}{\TyTkg{\lsig}}
}
$$
$$
\Rule[name=lsig/add]
{\goodSig{\Gm}{\lsig}{n} 
 \quad \goodType{\Gm}{A}{}
 \quad \goodSeal{\Gm}{\seal}{\lsig}{A}
 \quad \goodType{\Gm, A}{T}{}}
{\goodSig{\Gm}{(\LSigAdd {\lsig}{\seal}{T})}{n+1}}
\quad
\Biggl( \boxed{\goodSeal{\Gamma}{s}{\sigma}{A}} 
:= \boxed{\goodTerm{\Gamma, \cC\sigma}{s}{A[p^1]}} \Biggr)
$$
$$
\Rule[name=lnkg/ept]
{""}
{\goodTerm{\Gm}{\LkgEmp}{\TyLkg {\LSigEmp}}  
}
\quad
\Rule[name=lkg/add]
{ \goodTerm{\Gm}{o}{\TyLkg {\lsig}} 
\\ \goodType{\Gm}{A}{}
\\  \goodSeal{\Gm}{\seal}{\lsig}{A} 
\\  \boxed{\goodTerm{\Gm, A}{t}{T}}
}
{\goodTerm{\Gm}{(\LkgAdd {o} {t})}{\TyLkg{\LSigAdd {\lsig} {\seal} {T}}}
}
$$
$$
\Rule[name=lkg/proj]
{\goodTerm{\Gm}{o}{\TyLkg{\lsig}}}
{\goodTerm{\Gm}{\lkgproj{1} {o}}{\TyLkg {(\lsigproj{1} {\lsig})}}
\\ \boxed{\goodTerm{\Gm, \lsigprojT {\lsig}}{\lkgproj{2}{o}}{\lsigproj{2}{\lsig}}}
}
$$

We start with signature (in a brand new judgement $\goodSig{\Gamma}{\sigma}{n}$). A signature is a list of types contained by a \textit{linkage}\footnote{Following the convention by \citet{zm2017}, we name the meta-theoretical correspondents of \textit{family} as \textit{linkage}.}, tracking the length as superscript.   We will use $\{a : T_1, b : T_2, ..\}$ as a shorthand for signature with type $T_1, T_2, ..$ for readability. 

\ruleref{lkg/proj} indicates how linkage captures the idea of \textit{code reuse}, as $\lkgproj{2}{-}$ will lead to the boxed term that is parametric on the abstracted interface of linkage $\lsigprojT{\lsig}$ . To code reuse, we simply project out a field from the parent and add back to the children family.
\newpage 
Adding new types into signature \ruleref{Sig Add} requires a \textit{sealing judgement} $\goodSeal{\Gamma}{f}{\sigma}{A}$, which is an alias of a term judgement. Sealing is corresponding \textit{to indicating whether each field is overridable(extensible) or non-overridable (thus definitionally exposed) in the Coq Plugin}. 
Concretely, we encode our STLC example to show the motivation of the sealing.
%\YZ{Is sealing used only for late-binding the signatures of inductive types? Do I understand correctly that late binding of other kinds of fields (like subst) is achieved by the boxed premise in rule "LNKG ADD"?}\EDJreply{All late-bound are achieved by ``selective-abstraction'' imposed by sealing. For example, recursion will be consequently abstracted because of the abstraction of the inductive type it recurse on. 
%}\EDJreply{Sorry, I see what you mean. Yes. the box part is important for late-binding. But the functionality of sealing is always there. They are both required to achieve overriding. A illustrative example is, if the type is $S(\bot)$, then even with the boxed premise, it is still not overridable because the type itself restricts all the possibilities.}\YZreply{
%  By "selective abstraction", do you mean in the metatheory the programmer chooses what and how to abstract?
%}\EDJreply{Yes.}

% For example, if a field is overridable, we abstract that to its type; if a field has exposed its definition, we abstract it into the singleton type containing it instead.  Sealing $\goodSeal{\Gamma}{f}{\sigma}{A}$ is useful when the surrounding interface is $\sigma$ and we want to construct the new field based on $A$.

% We can now point out how "Overridable" and "pins" is modeled. Despite the fact we have a complicated dynamic of invisibility between overridable and normal fields in the plugin, every field can be elaborated into the (pseudo)-syntax form \\ \mintinline{Coq}{Field hiding {x, y, z ...} newfield := t...}  where every former field x,y,z,...  hide its definition when type-check t, and remaining former fields have their definition exposed in t.
% This above elaborated "hiding" syntax directly corresponding to the $f$ in $(\mu^+ ~o~\{f\}~t)$, where each fields decides the abstraction of the prior.


\begin{figure}[!htb]
  \lstset{
      basicstyle=\fontsize{8}{8.5}\ttfamily,
  % numbers=left,
  }
  
  \begin{minipage}{\textwidth}
  \begin{multicols}{3}
  

  \definecolor{codecomment-color}{HTML}{0DA3FF}
  
  \begin{lstlisting}
  Family STLC. 
   FInductive ty (* no hiding *)

   FInductive tm (* hiding ty *) 
   
   FRecursion subst
     Case ... (* hiding ty tm *)
     ...
   End subst (* hiding ty *) 
   

   Field t1 := (tvar 0) 
   (* hiding ty tm subst *) 


   Field t2 := (tapp t1 t1)
   (* hiding ty tm subst *)

  ...
  \end{lstlisting}
  
  % \makeline[0pt]{Parser-exmp-before-start}{Parser-exmp-before-end}[codecomment-color!50]
  
  \columnbreak
  % \definecolor{codecomment-color}{HTML}{5D030F}
  
  \begin{lstlisting}

    (* s[@‚ÇÅ@]  : {} | {} *)
    - o[@‚ÇÅ@]  = Œº+ {} s[@‚ÇÅ@] [@$W\tau_1$@] : ùïÉ{ty : [@$\TyS{W\tau_1}$@]}
    (* s[@‚ÇÇ@]  : {ty : [@$\TyS{W\tau_1}$@]} | [ty : ùïå; bool : ty; ...] *) 
    - o[@‚ÇÇ@]  = Œº+ o[@‚ÇÅ@] s[@‚ÇÇ@] [@$W\tau_2$@] : ùïÉ{ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]}
    (* s[@‚ÇÉ@][@‚ÇÅ@]  : {ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]}
            | [ty : ùïå; ... ; tm : ùïå; tvar : tm; ...] *)
    - o[@‚ÇÉ@][@‚ÇÅ@]  = Œº+ o[@‚ÇÇ@] s[@‚ÇÉ@] ([@Œº@]+ ..) : ùïÉ{ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]; subst' : ùïÉ(RecSig)}
    (* s[@‚ÇÉ@] : {ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]; subst' : ùïÉ(RecSig)} 
          | [ty : ùïå; ... ; tm : [@$\TyS{W\tau_2}$@]; subst' : ùïÉ(RecSig)] *)
    - o[@‚ÇÉ@] = Œº+ o[@‚ÇÉ@][@‚ÇÅ@] s[@‚ÇÉ@] (Œª (Wrec ..)) : ùïÉ{ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]; subst' : ùïÉ(RecSig); subst : tm ‚Üí nat ‚Üí tm ‚Üí tm}
    
    (* s[@‚ÇÑ@] : {ty : [@$\TyS{W\tau_1}$@]; ... subst : tm ‚Üí nat ‚Üí tm ‚Üí tm } 
          | [.. ; tm : ùïå; tvar : nat ‚Üí tm; .. subst : tm ‚Üí nat ‚Üí tm ‚Üí tm] *)
    - o[@‚ÇÑ@] = Œº+ o[@‚ÇÉ@] s[@‚ÇÑ@] [@("tvar"~0)@] : ùïÉ{ty : [@$\TyS{W\tau_1}$@]; ... t[@‚ÇÅ@] : [@\TyS{"tvar"~0}@]}
  
    (* s[@‚ÇÖ@] : {ty : [@$\TyS{W\tau_1}$@]; tm : [@$\TyS{W\tau_2}$@]; subst : ùïÉ(RecSig); t1 : [@\TyS{"tvar"~0}@]} 
          | [ty : ùïå; tm : ùïå; subst : ùïÉ(RecSig); t1 : [@\TyS{"tvar"~0}@]] *)
    - o[@‚ÇÖ@] = Œº+ o[@‚ÇÑ@] s[@‚ÇÖ@] .. : ùïÉ{ ... }
  \end{lstlisting}
  
  \columnbreak
  

  % \makeline[.5\textwidth+9pt]{Parser-exmp-after-start}{Parser-exmp-after-end}[codecomment-color!50]
  
  \end{multicols}
  \end{minipage}
  \caption{Sealing and Linkage}\label{fig:sealing+linkage}
  \end{figure}



In \cref{fig:sealing+linkage}, the "hiding" comment illustrates the late-bound prior fields for each fields.   For "tm", "ty" is late-bound and thus extending "ty" won't cause disruption on the inheritance of "tm". For "subst" itself, the definition of "tm"  cannot hidden for the sake of exhaustiveness checking. However, for each case handler inside "subst", "tm" is late-bound and thus each handler is inheritable. 

Each hiding comment corresponds to the textual-aligned sealing derivation on RHS. For readability, RHS is informal---curly brackets indicate a signature (omitting sealing at type level) and square bracket indicate a nested $\Sigma$-type, corresponding to sealing judgment $\goodSeal{}{s}{\sigma}{A}$.

For "tm", "ty" is hidden and thus the sealing "s‚ÇÇ" will make "ty" into an arbitrary type "ùïå" and expose its constructor "bool", "arrow", and etc. Then when constructing "o‚ÇÇ", the newly added field "tm" as "‚ãÜ : ùïéœÑ‚ÇÇ" is constructed in the context where "ty : ùïå", ignoring its original eliminator. (Because eliminator is only possible when "ty : ùïéœÑ‚ÇÅ"). On the other hand, for "subst", only "ty" is hidden and thus the sealing "s‚ÇÉ" leave "tm : ùïéœÑ‚ÇÇ" untouched and "Wrec" becomes possible when constructing "o‚ÇÉ".

Basically, the hidden prior fields---inductive type are sealed into arbitrary type with ``constructors only'', where the recursion is constructed without sealing the inductive type.  Generally speaking, each extensible inductive type are hidden for all the other fields except for the recursion on itself. 

We choose to expose the definition of $t_1$ to all the following fields including $t_2$ by using singleton type $\TyS{-}$. If other fields, say $t_3$, want to hide it, just seal $t_1$ into type "tm"; and then overriding $t_1$ will not disrupt the inheritablity of $t_3$. But such overriding will definitely disrupt the inheritablity of $t_2$ as $s_5$ doesn't hide $t_1$. Generally speaking, any field that has a clear "hiding" semantic on the prior fields can be understood as sealing. All of our plugin commands have clear "hiding" semantics.

% Intuitively, sealing corresponds to the following surface syntax\\
% \mintinline{Coq}{Field hiding {x, y, z ...} newfield := t...} where every former field "x","y","z",...  hide its definition when type-check "t", and remaining former fields have their definition exposed for "t". Thus, "x","y","z", ... can be overridden but other fields have to stay the same if we want to inherit "t". In meta-theory, we control the sealing $f$ so that "x","y","z",... only has type exposed and remaining fields are definitionally exposed using singleton type.


% The reader should feel this subtle difference compared to our current plugin implementation---$(\mu^+ ~o~\{f\}~t)$ reads as \textit{``$t$ is a new well-typed field when we abstract the \textbf{prior} fields using $f$''}. In other words, every field in meta-theory has the right to choose how they perceive and abstract the prior fields. While in the plugin, "Overridable" keyword will decide how the current defining field is percived by all the following fields.


% Given a signature $\sigma$, we have the linkage type $\cL\sigma$ inhabited by linkages; and the \textit{compilation type} $\cC\sigma$ of the linkage type. The compilation type corresponds to how we compile a context into a \mintinline{Coq}{Module Type} in the plugin implementation---in metatheory, $\cC\sigma$ will be a nested sigma type. For example, $\cC\{a : \cU, b : a \to \bot \} = \Sigma(a : \cU).\Sigma (b : a \to \bot). \top$.

Due to the definition of sealing, we can see the importance of compilation type, as the result of a sealing is usually a (nested) $\Sigma$-type instead of a linkage type. For example, $\TyLkg{\{a : S(\bot), b : a \to \bot\}}$ can only be sealed into $\TyTkg{\{a : \cU, b : a \to \bot\}}$ but never $\TyLkg{\{a : \cU, b : a \to \bot\}}$. Because the latter cannot be inhabitted---by projecting the second field of the $ t : \TyLkg{\{a : \cU, b : a \to \bot\}}$, we can get a proof of bottom type. For simplicity, we make sealing a term in the context of compilation type instead of linkage type.

% The difference between compilation type and linkage types lies in their introduction rules. The compilation types are just syntactic sugar for sigma types. However, the intro rules for the linkage types gives it the power of late-binding (also the fundation of inheritance and overriding). More concretely, the boxed premise in \ruleref{Lnkg Add} is making $t$ parametric on $A$, contrary to how in sigma type, the $t$ will be about a concrete $\mathit{self} : A$. This parametricity makes $t$ inheritable and the earlier stuff about $A$ late-bound.

% The sealing judgement provides a witness $f$ that a context $\Gamma, \cC\sigma$ can be abstracted into an \textit{interface} $\Gamma, A$ for a type $\goodType{\Gamma}{A}{}$. For example, sealing judgement can abstract an inductive type with constructors into an arbitrary type with functions (but without eliminators). Then any later fields $\goodTerm{\Gamma, A}{t}{T}$ relies only on the \textit{interface} $A$ can be inherited to other contexts (e.g. using extended inductive type), as long as the targeting contexts can be abstracted into the surrounding \textit{interface} for $t$ (i.e. $\Gamma, A$)  as well.

% The importance of the compilation type lies in its difference from the linkage type. First we have a singleton type $"s A" : S(T) \iff "A" \equiv T$, i.e. a type of one single term.  We can see that we have a term $x : \cC\{A : S(\bot), B : A \to \bot \} \vdash h_1 : \cC\{A : \cU, B:A \to \bot \}$ which is equivalent to $x : \Sigma (A: S(\bot)). A \to \bot \vdash h_1 : \Sigma (A: \cU). A \to \bot$. This can be considered as using seal to do an abstraction on $A:S(\bot)$.

% But we can never have a term $x : \cL\{a : S(\bot), b : a \to \bot \} \vdash h_2 : \cL\{a : \cU, b : a \to \bot \}$, as we know $\cL\{a : S(\bot), b : a \to \bot \}$ is inhabited
% and that leads to a close term of $\cL\{a : \cU, b : a \to \bot \}$ due to the nature of late-binding of $\cL\sigma$---once we override $a$ with $\top$ we will have inconsistency using $b$. This example illustrates the programming difference between the sigma type and linkage type.  

% However, this form of abstracting a type is very important when programming in our metatheory---as later we will show inductive type of different constructors locates in different type (universe), and to make later fields inheritable we need to work on an interface of abstracted type. Thus the compilation type is indispensable.

% Looking closely, the sealing judgement helps to model most machinaries about abstraction in plugin implementation.

% Inductive type and recursor and handlers

$$
\Rule[name=Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma}{l}{\cL \sigma_1}
}
{\goodTerm{\Gamma}{("inh" \ h \ l)}{\cL \sigma_2}},
\Rule[name=Inh-Id]
{}
{\goodInh{\Gamma}{"inhid"}{\sigma}{\sigma}},
\Rule[name=Inh-Ext]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma, A_2}{t}{T}}
{\goodInh{\Gamma}{"inhext" \ h \ t}{\sigma_1}{(\nu^+ \  \sigma_2\  T)}}
$$

% Inhertance judgement
Currently we can achieve inheritance by projecting out the field, and then add back the projection into the children family. That means the formulation of linkage already captures the concept of \textit{code reuse}. 

However, in the plugin implementation, we use "Family"s to organize the code reuse. They are second class objects like Coq's "Module". What's more, a "Family" (with or without "extends" clause) can be considered as a standalone piece of code trying to \textit{inherit} an existent (but maybe empty) family. Thus we model them using \textit{inheritance judgement} $\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}$ instead of considering them as first class terms. Inheritance judgement is like ``library function'' upon linkage for achieving inheritance and overriding. The only way to use $h$ is by \ruleref{Inh} and transforming a linkage of signature $\sigma_1$ to another linkage of $\sigma_2$. Inheritance judgement can be inductively constructed via inheriting operations, overriding operations, extending operations and etc, corresponding to "Inherit", "Override" and "Extend" command  in our plugin implementation.


In this way, we will consider the program in our metatheory similar to those vanilla MLTT program, except there are meta variables denoting inheirtance judgement (i.e. "Family"), of which the only usage is to apply \ruleref{Inh}. We don't yet consider non-trivial equality between derivations of inheritance judgements.


\subsection{Syntactic Translation that removes Linkages}
To further provide the intuition why our core calculus is sound, we provide a syntactic translation from our core calculus to the subpart where linkages are absent. This can justify the \textit{consistency} and \textit{canonicity} modulo the quirky (but apparent) formulation of our inductive type. To be complete, we also provide a consistency and canonicity proof for our complete core calculus in the appendix.

Thanks to QIIT formulation, syntactic translation becomes a function between QIIT type, which by definition respects all the judgemental equalities. We will now sketch this translation $\denotesT{\_}$, which keeps most parts untouched except for the linkages related. We omit most of the inheritance translation.



\begin{align*}
  \text{We first define a new type }& \goodType{\Gamma}{\Sigr{\Gamma}{n}}{}  \text{ when } \goodCtx{\Gamma}{}  \text{ is well-formed and } n \in \mathbb{N} \\
  \denotesT{\goodSig{\Gamma}{\_}{n}},\ &({\Sigr{\Gamma}{n}}), \text{ and } \ \denotesT{\TyTkg {-}} \text{ are mutually recursive, } \\
  & \text{defined by induction on the signature length} \\  
  \denotesT{\goodSig{\Gamma}{\_}{n}} &= (\goodTerm{\Gamma}{\_}{\Sigr{\Gamma}{n}}) \\ 
  &\text{, and thus } \denotesT{\goodSig{\Gamma}{\sigma}{n}} \text{ defined} \iff \goodTerm{\Gamma}{\denotesT{\sigma}}{\Sigr{\Gamma}{n}} \\ 
  {\Sigr{\Gamma}{(n+1)}} &= 
    \Sigma~(\Sigr{\Gamma}{n})
          ~(\Sigma~\cU
                  ~(\Sigma~(\Pi(\TyTkg {("var"_0[p^1])})(El~"var"_0[p^1]))~\cU)) \\
  \Sigr{\Gamma}{0} &= \top \\
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}}, \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} &\text{ defines upon } \denotesT{\sigma} 
  \text{ and inductively on the signature length} \\
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}} &= \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} = \top \quad
      \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}} \\ 
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}} &= 
    \Sigma~\denotesT{\TyTkg {(\lsigproj{1}{\sigma})}}~(El \ (\app{("pjr"^3~\denotesT{\sigma})})[(p^1, \app{(\fst{("pjr"^2~{\denotesT{\sigma}})})})]) \\
  \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} &=
  \denotesT{\TyLkg{(\lsigproj{1}{\sigma})}} \times \Pi(El~(\fst{(\snd{\denotesT{\sigma}})}))(El~(\app{("pjr"^3~\denotesT{\sigma})} )) \\
  &\text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}} \\
  \denotesT{\goodSig{\Gamma}{\LSigAdd{\sigma}{f}{T}}{n+1}} &= (\denotesT{\sigma}, \codety{A}, \lam{f}, \lam{(\codety{T})}) \\ 
  \denotesT{\goodTerm{\Gamma}{\mu^+~m~t}{\TyLkg{(\LSigAdd{\sigma}{s}{T})}}} &= (\denotesT{m}, \lam{t}) \\ 
  \denotesT{\goodTerm{\Gamma}{\Tkg{m}}{\TyTkg {\sigma}}} & \text{ is defined upon } \denotesT{m} \text{ and inductively on the signature length} \\ 
  \denotesT{\goodTerm{\Gamma}{\Tkg {m}}{\TyTkg {\sigma}}} &= 
  (\denotesT{\Tkg {o}}, t[(\SubstExt{p^1}{f})][(\SubstExt{"id"}{\denotesT{\Tkg {o}}})]) \\
  & \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}}, \text{ where } o = \lsigproj{1}{m}, t = \app{(\snd{\denotesT{m}})}, f = p_f\nu~\sigma \\ 
  \denotesT{\goodTerm{\Gamma}{\Tkg {m}}{\TyTkg {\sigma}}} &= () \quad \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}}
\end{align*}
\begin{align*}
  \denotesT{\goodInh{\Gamma}{\_}{\sigma_1}{\sigma_2}} &= \goodTerm{\Gamma, \TyLkg{\sigma_1}}{\_}{\TyLkg{\sigma_2[p^1]}} \\ \text{ and thus } \denotesT{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}} &\iff  \goodTerm{\Gamma, \TyLkg{\sigma_1}}{h}{\TyLkg{\sigma_2[p^1]}} \\
  \denotesT{\goodInh{\Gamma}{"inhinh"~h~T~\uparrow^s}{(\LSigAdd {\sigma_1} {s_1}{T})}{(\LSigAdd {\sigma_2} {s_2} {T[(p^1, \uparrow^s)]})}} &= \mu^+~(h[(p^1,\lkgproj{1}{"var"_0})])\\ &\quad \quad \{f_2[p^1]\}~(\lkgproj{2}{"var"_0})[(p^1, \uparrow^s[{p^1}^{\uparrow}])] \\
\end{align*}



\begin{figure}[!htb]
  \lstset{
      basicstyle=\fontsize{8}{8.5}\ttfamily,
  % numbers=left,
  }
  
  \begin{minipage}{\textwidth}
  \begin{multicols}{3}
  

  \definecolor{codecomment-color}{HTML}{0DA3FF}
  
  \begin{lstlisting}
  Family STLC_bool extends STLC. 

   FInductive ty += ty_bool
   FInductive tm += tm_true .. 
   

   FRecursion subst
     (* Inherits all others *)
   
   


   

   
     Case tm_true ...    


   End subst 



  

   

   Inherit t1








  ...
  \end{lstlisting}
  
  % \makeline[0pt]{Parser-exmp-before-start}{Parser-exmp-before-end}[codecomment-color!50]
  
  \columnbreak
  % \definecolor{codecomment-color}{HTML}{5D030F}
  
  \begin{lstlisting}

  i[@‚ÇÄ@] = inh-id : Inh ‚ãÖ {} {} 
  i[@‚ÇÅ@] = inh-ov i[@‚ÇÄ@] (W [@œÑ‚ÇÅ@]') : Inh ‚ãÖ {ty : ùïä(W œÑ‚ÇÅ)} {ty : ùïä(W œÑ‚ÇÅ')}
  s[@‚ÇÇ@]' : {ty : ùïä(W œÑ‚ÇÅ')} | [ty : ùïå] 
  i[@‚ÇÇ@] = inh-ov i‚ÇÅ (W œÑ‚ÇÇ') 
     : Inh ‚ãÖ {ty : ùïä(W œÑ‚ÇÅ); tm : ùïä(W œÑ‚ÇÇ)} {ty : ùïä(W œÑ‚ÇÅ'); tm : ùïä(W œÑ‚ÇÇ') }
  (* recall s[@‚ÇÉ‚ÇÅ@] : {ty : ùïä(W œÑ‚ÇÅ); tm : ùïä(W œÑ‚ÇÇ)} 
                | [ty : ùïå;  ..] *)
  s[@‚ÇÉ‚ÇÅ@]' : {ty : ùïä(W œÑ‚ÇÅ'); tm : ùïä(W œÑ‚ÇÇ')} | [ty : ùïå; ..; tm_true : tm; ..]
  ‚Üës[@‚ÇÉ@] : Tm ( ‚ãÖ, [ty : ùïå; ..; tm_true : tm; ..]) [ty : ùïå; ..] 
  (* ‚Üës[@‚ÇÉ@] map (the type of) s[@‚ÇÉ‚ÇÅ@]' to that of the sealing s[@‚ÇÉ‚ÇÅ@] before inheritance *)
  ii[@‚ÇÉ‚ÇÄ‚ÇÄ@] = inh-id 
           ‚´∂ Inh ( ‚ãÖ, [ty : ùïå; ..; tm_true : tm; ..])
              (RecSig œÑ‚ÇÇ  tm)[p[@‚ÇÄ@], ‚Üës[@‚ÇÉ@]]
              (RecSig œÑ‚ÇÇ  tm)[p[@‚ÇÄ@], ‚Üës[@‚ÇÉ@]]
  ii[@‚ÇÉ‚ÇÄ‚ÇÅ@] = inh-extend (inh-extend ii[@‚ÇÉ‚ÇÄ‚ÇÄ@] {p[@‚ÇÅ@]} .. ) {p[@‚ÇÅ@]} ..
        : Inh ( ‚ãÖ, [ty : ùïå; tm :ùïå; ..; tm_true : tm; ..]) 
              (RecSig œÑ‚ÇÇ  tm)[p[@‚ÇÄ@], ‚Üës[@‚ÇÉ@]] (RecSig œÑ‚ÇÇ'  tm)
  i[@‚ÇÉ‚ÇÅ@] = inh+inh i[@‚ÇÇ@] ‚Üës[@‚ÇÉ@] ii[@‚ÇÉ‚ÇÄ‚ÇÅ@] : 
      Inh ‚ãÖ {ty : ùïä(W œÑ‚ÇÅ); ..; subst' : ùïÉ(RecSig œÑ‚ÇÇ tm)} 
            {ty : ùïä(W œÑ‚ÇÅ'); ..; subst' : ùïÉ(RecSig œÑ‚ÇÇ' tm)}
  s[@‚ÇÉ@]' : {ty : ùïä(W œÑ‚ÇÅ'); tm : ùïä(W œÑ‚ÇÇ'); subst' : ùïÉ(RecSig œÑ‚ÇÇ' tm) }
      | [ty : ùïå; .. ; tm : ùïä(W œÑ‚ÇÇ'); subst' : ùïÉ(RecSig œÑ‚ÇÇ' tm)] 
  i[@‚ÇÉ@] = inh-ov i[@‚ÇÉ‚ÇÅ@] ..
     : Inh ‚ãÖ {ty : ùïä(W œÑ‚ÇÅ); tm : ùïä(W œÑ‚ÇÇ); subst' : ùïÉ(RecSig œÑ‚ÇÇ tm); subst : tm ‚Üí nat ‚Üí tm ‚Üí tm}  
             {ty : ùïä(W œÑ‚ÇÅ'); tm : ùïä(W œÑ‚ÇÇ'); subst' : ùïÉ(RecSig œÑ‚ÇÇ' tm); subst : subst : tm ‚Üí nat ‚Üí tm ‚Üí tm}
  (* recall s‚ÇÑ : {ty : ùïä(W œÑ‚ÇÅ); .. subst : .. } 
      | [ty : ùïå; .. ; tm : ùïå; .. ;subst' : ùïÉ(RecSig œÑ‚ÇÇ tm); subst : ..] *)
  s[@‚ÇÑ@]' : {ty : ùïä(W œÑ‚ÇÅ'); .. subst : .. } 
        | [ty : ùïå; .. ; tm : ùïå; .. ;subst' : ùïÉ(RecSig œÑ‚ÇÇ tm); subst : ..]
  ‚Üës[@‚ÇÑ@] : Tm ( ‚ãÖ, [ty : ùïå; .. ; tm : ùïå; .. ; subst' : ùïÉ(RecSig œÑ‚ÇÇ tm);subst : ..]) 
          [ty : ùïå; .. ; tm : ùïå; .. ;subst' : ùïÉ(RecSig œÑ‚ÇÇ tm); subst : ..]
  i[@‚ÇÑ@] = inh-inh i[@‚ÇÉ@] ‚Üës[@‚ÇÑ@] 
         : Inh ‚ãÖ {ty : ùïä(W œÑ‚ÇÅ); .. subst : ..; t1 : ùïä(tm_var 0)} 
                 {ty : ùïä(W œÑ‚ÇÅ'); .. subst : ..; t1 : ùïä(tm_var 0)} 
  \end{lstlisting}
  
  \columnbreak
  

  % \makeline[.5\textwidth+9pt]{Parser-exmp-after-start}{Parser-exmp-after-end}[codecomment-color!50]
  
  \end{multicols}
  \end{minipage}
  \caption{Inheritance Metatheory}\label{fig:inheritance}
  \end{figure}

\fi
