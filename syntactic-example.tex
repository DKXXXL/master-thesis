We use an example to better demonstrate different components of the syntax of our formulation. Our example will be the meta-theory encoding of the following pseudo-code.

We provide one example in its surface syntax as pseudocode, and their meta-theory encoding. This example is computing the predecessor of a mundane natural number -- however we split the inductive definition into two parts and making "O" and "S" standing alone. "pred" is defined as $n \mapsto ("pred" n, n)$, and thus a predecessor.




\begin{figure}[H]\label{fig:example-pseudocode}
\begin{minipage}[t]{0.5\linewidth}
\begin{minted}{Coq}
Family A.
 Inductive N := O : N. 
 (* Osig, sig₁, obj₁, sig₂,
    O₁, obj₂, sig₂', sl₁ *)
 Family handler.
   O :self[A].N * self[A].N 
     := (self[A].O, self[A].O). 

 EndFamily. (* pN₁, handler₁, sig₃ *)
 pred 
  : self[A].N → self[A].N×self[A].N 
  := ... 
  (* predT, pred₁, sig₄, sig₄', sl₄ *) 
 k := self[A].pred self[A].O 
(* pN₂, sig₅ *)
EndFamily.
\end{minted}
  \end{minipage}
  \begin{minipage}[t]{0.45\linewidth}
\begin{minted}{Coq}
Family A₂ extends A.
 Extend Inductive N := S : N -> N.
 (* Nsig, sig₁₁, inh₁, O₂, sig₂₁, inh₂, 
    sig₂₂, sig₂₁', sig₂₂', sl₂₂, inh₃ *)
 Extend Family handler.
   Inherit O. (* inhᵢₙ₀, pN₃ *)
   S : N*N -> N*N 
     := fun (x,y) => (y, self[A₂].S y).
 EndFamily. (* inhᵢₙ, sig₃₁, inh₄*)
 pred 
  : self[A₂].N → self[A₂].N×self[A₂].N 
  := ... 
  (* sig₄₁, inh₅, sl₄₁ *)
 Inherits k. 
 (* inh₆ *)
EndFamily.
    \end{minted}
  \end{minipage}
  \caption{Demonstrating Pseudo-Code}
\end{figure}

\begin{figure}
  \begin{minipage}{\linewidth}
    \begin{minted}{Coq}
      Inductive N :=
       | O : 1 -> (0 -> N) -> N 
       | S : 1 -> (1 -> N) -> N
      (* For example, Number 1 is encoded using
         1 = S () (fun _ -> O () (fun x -> elim-⊥ x)) *)
    \end{minted}
  \end{minipage}

  \begin{minipage}[t]{0.4\linewidth}
\begin{align*}
  "Osig" &:= \goodWSig{\cdot}{w+ \ \top \ \bot \  w\cdot}{1} \\
  "sig"_1 &:= \goodSig{\cdot}{\nu^+ \ \nu\cdot  \ (\bW \ "Osig"[\pi_1])}{1}  \\
  "obj"_1 &:= \goodTerm{\cdot}{\mu^+ \ \mu\cdot \ {id_s} \ *}{\cL"sig"_1}\\
  \cC"sig"_1 &= \goodType{\cdot}{\Sigma \ \top \ (\bW \ "Osig"[\pi_1]) }{} \\
  "sig"_2 &:=  \goodSig{\cdot}{\nu^+ \ "sig"_1 \ {id_s} \ El ("W" ("pjr" \ \pi_2))}{2} \\ 
  "O"_1 &:= {"Wsup" \ ("pjr" \pi_2) \ () \ ("elim-"\bot \ \pi_2)}  \\ 
  & \text{ and thus }  \goodTerm{\cdot, \cC"sig"_1}{"O"_1}{El ("W" ("pjr" \pi_2))} \\
  "obj"_2 &:= \goodTerm{\cdot}{\mu^+ \ "obj"_1 \ "O"_1}{\cL"sig"_2} \\
  "sig"_2' &:= \goodType{\cdot}{\Sigma (\Sigma \top \cU)El ("pjr" \pi_2)}{} \\ 
  \cC"sig"_2 &= \goodType{\cdot}{\Sigma (\Sigma \top (\bW \ "Osig"[\pi_1]))El \ W("pjr" \pi_2) }{} \\ 
  "sl"_1 &:= ((*, "W" ("pjr" ("pjl" \pi_2)) ), "pjr" \pi_2) \\ 
  & \text{ and thus }  \goodSeal{\cdot}{"sl"_1}{"sig"_2}{"sig"_2'} \\
  "pN"_1 &:= \goodType{\cdot, "sig"_2'}{El ("pjr" ("pjl" \pi_2)) * El ("pjr" ("pjl" \pi_2))}{} \\
  "handler"_1 & := \goodTerm{\cdot, "sig"_2'}{\_}{\cL(\nu^+ \ \nu\cdot \ \{id_s\} "pN"_1)} \\
  "sig"_3 &:= \goodSig{\cdot}{\nu^+ "sig"_2 \{"sl"_1\} \ \cL(\nu^+ \ \nu\cdot \ \{id_s\} "pN"_1)}{3} \\ 
  "predT" := (\Pi & \ El ("W"("pjr" ("pjl"^2 \pi_2))) \\  
  & (El ("W" ("pjr" ("pjl"^2  \pi_2)))[\pi_1])) \\
  "pred"_1 & := \goodTerm{\cdot, \cC "sig"_3}{\lambda ("Wrec" \_)}{predT} \\ 
  "sig"_4 &:= \nu^+ \ "sig"_3 \ \{id_s\} \ "predT" \\ 
  "sl"_4 &:= \goodSeal{\cdot}{\_}{"sig"_4}{"sig"_4'} \\ 
  "pN"_2 &:= \goodType{\cdot, "sig"_4'}{El ("pjr" ("pjl" \pi_2)) * El ("pjr" ("pjl" \pi_2))}{} \\
  "sig"_5 &:= \nu^+ \ "sig"_4 \ \{"sl"_4\} \  "pN"_2 \\ 
\end{align*}
\end{minipage}%
\begin{minipage}[t]{0.4\linewidth}
\begin{align*}
  "Nsig" &:= \goodWSig{\cdot}{w+ \ \top \ \bot \  "Osig"}{1} \\ 
  "sig"_{11} &:= \goodSig{\cdot}{\nu^+ \ \nu\cdot  \ (\bW \ "Nsig"[\pi_1])}{1} \\
  "inh"_1 &:= \goodInh{\cdot}{"inhov" \  "inhid" \ *}{"sig"_1}{"sig"_{11}}\\
  "O"_2 &:= {"Wsup" \ ("pjr" \pi_2) \ () \ ("elim-"\bot \ \pi_2)}  \\ 
  & \text{ but }  \goodTerm{\cdot, \cC"sig"_{11}}{"O"_2}{El ("W" ("pjr" \pi_2))} \\
  "sig"_{21} &:= \nu^+ \ "sig"_{11} \ \{id_s\} (El (W (pjr p₂))) \\ 
  "inh"_2 &:= \goodInh{\cdot}{"inhov" \ "inh"_1 \ "O"_2}{"sig"_2}{"sig"_{21}}\\
  "S"_T := (\Pi & \ El ("W"("pjr"  ("pjl" \pi_2))) \\  
  & (El ("W" ("pjr" ("pjl"  \pi_2)))[\pi_1])) \\
  "sig"_{22} &:= \nu^+ \ "sig"_{21} \ \{id_s\} \ "S"_T \\ 
  "sig"_{21}' &:= \goodType{\cdot}{\Sigma (\Sigma \top \cU) (El ("pjr" \pi_2))}{} \\
  "sig"_{22}' &:= \Sigma "sig"_{21}' (\Pi \ El ("pjr"  ("pjl" \pi_2)) \  ...) \\
  "sl"_{22} &:= \goodSeal{\cdot}{\_}{"sig"_{22}}{"sig"_{22}'} \\ 
  "inh"_3 &:= \goodInh{\cdot}{\_}{"sig"_2}{"sig"_{22}} \\ 
  \uparrow^s &:= \goodTerm{\cdot, "sig"_{22}'}{\_}{"sig"_2'[\pi_1]} \\ 
  "pN"_3 &:= "pN"_1[(\pi_1, \uparrow^s)] \\ 
\end{align*}
  \end{minipage}

  \begin{minipage}{0.8\linewidth}
    \centering
    \begin{align*}
      "inh"_{in0} &:= \goodInh{\cdot, "sig"_{22}'}{"inhid"}{(\nu^+ \ \nu\cdot \ ("pN"_1[\pi_1]))[(\pi_1, \uparrow^s)]}{(\nu^+ \cdot ("pN"_3[\pi_1]))} \\
      "inh"_{in} &:= \goodInh{\cdot , "sig"_{22}'}{\_}{(\nu^+ \ \nu\cdot \ "pN"_1[\pi_1])[(\pi_1, \uparrow^s)]}{(\nu^+ \ \cdot \ ("pN"_3[\pi_1]) \ \{id_s\} (\Pi "pN"_3 ("pN"_3[\pi_1])) )[\pi_1]}\\
      "sig"_{31} &:=  \nu^+ \ "sig"_{22} \ {"sl"_{22}}\  \cL(\nu^+ \cdot ("pN"_3[\pi_1])  (\Pi "pN"_3 ("pN"_3[\pi_1]))[\pi_1]) \\ 
      "inh"_4 &:= \goodInh{\cdot}{"inhnest" \ "inh"_3 \uparrow^s "inh"_{in}}{"sig"_3}{"sig"_{31}} \\
      "sig"_{41} &:= {\nu^+ \ "sig"_{31} \ (\Pi (El ("W" ("pjr" ("pjl"^4 \pi_2)))) (El ("W" ("pjr" ("pjl"^4 \pi_2))))[\pi_1])} \\ 
      "inh"_5 &:= \goodInh{\cdot}{inhov \ \_}{"sig"_4}{"sig"_{41}} \\ 
      "sl"_{41} &:= \goodSeal{\cdot}{\_}{"sig"_{41}}{"sig"_{41}'} \\ 
      \uparrow^s_2 &:= \goodTerm{\cdot, "sig"_{41}}{\_}{"sig"_4'[\pi_1]} \\ 
      "inh"_6 &:= \goodInh{\cdot}{"inhinh" \ "inh"_5 \ \uparrow^s_2}{"sig"_5}{(\nu^+ \ "sig"_{41} \{"sl"_{41}\} \ "pN"_2[(\pi_1, \uparrow^s_2)])}
    \end{align*}  
  \end{minipage}
  \caption{Detailed Construction}\label{fig:example-construction}
\end{figure}

Here we explain how  our detailed construction in Figure \ref{fig:example-construction} is constructed. We first elaborate that how our inductive type "N" is written in the specific format (the style of W-type). We use 1, 0 here to indicate unit type and bottom type. 

Next, we alias each part of the derivation with a name. Every derivation here is well-typed term. We also annotate in the original pseudocode the name of the related derivation. 

We start with the construction of "Osig" which is the signature of a standalone "O" constructor. With this we will have $"sig"_1, "obj"_1, "sig"_2, "obj"_2$ as the signature and object of the linkage with that inductive type, and the signature and the linkage once we export the concrete constructor $"O"_1$. 

Now sealing comes in to seal these concrete component into an abstract interface $"sig"_2'$ for decoupling the following fields. To make sure the sealing exists, we take a look at the resulting $\cC "sig"_2$, and doing abstraction on it to get $"sl"_1$. 

Now we construct the recursor, with the help of the handler module $"handler"_1$, with which we can construct the real recursor $"pred"_1$. Both detailed constructions are omitted. Then we again abstract the concrete recursor $"pred"_1$ away using $"sl"_4$ so that the field $"k"$ can applys it without resorting to the concrete recursor. Finally we have $"sig"_5$ as final signature. 

Now we construct the inheritance judgement for $"A"_2$. Still, we start with signature for inductive type, "Nsig". But to ``extend'' the inductive type, we actually \textit{override} the inductive type with the enriched inductive type in $"inh"_1$. Because inductive type is overridden, inheritance on the constructors are not pausible and thus we need to override the old $"O"_1$ constructor using $"O"_2$ and extend with new constructor for "S", resulting $"inh"_3$. These newly overridden constructors are sealed by $"sl"_{22}$. However, look closely, our sealed abstract interface in the children still has more fields than the sealed abstract interface in the parent. We still need $\uparrow^s$ to indicate the ``compatibility'' between two abstract interfaces so that the inheritance from the parents can work. It can be understood as ``upcasting'', but this ``upcasting'' is used to upcast the context of the children. We immeidately see its usage in $"pN"_3$ and $"inh"_{in0}$. Upon this, we construct the complete inner-inheritance $"inh"_{in}$ that is responsible for extending "handler". Then we continue the construction for $"inh"_4$ that ``nest'' the inner-inheritance into the whole $"inh"_3$, and we re-do exhaustiveness checking when constructing $"inh"_5$ using $"inhov"$ and "Wrec". Since it is another recursor requiring concrete inductive definition, we do another abstraction on it using $"sl"_41$. After that, $\uparrow^s_2$ again witnesses the compatibility of the abstract interface, and the two are both used for constructing $"inh"_6$, which is responsible for inheriting field "k". 



