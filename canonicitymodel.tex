Now we prove the consistency and canonicity using canoncity model. We follow the reducibility argument from~\cite{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic} to construct the canonicity model.
Each of their proof is based on QIIT, Category with Family\cite{dybjer1995internal} and Generalized Algebraic Theory \cite{cartmell1986generalised} as the syntax. Meanwhile, our proof will still work directly on the earlier introdcued syntax for readability.
We will first specify the formulation of the most basic canonicity theorem. 

\begin{theorem}[Canonicity]
  For a closed boolean term $\goodTerm{\cdot}{t}{\cB}$, we have $\goodTerm{\cdot}{t \equiv \true}{\cB}$ or $\goodTerm{\cdot}{t \equiv \false}{\cB}$ hold.
\end{theorem}

Canonicity is a basic criteria to consider a dependent type theory to be ``a programming language or as a computational foundation for mathematics''.\footnote{See nlab explanation: \href{https://ncatlab.org/nlab/show/canonical+form}{Canonical Form}}
We can even argue that, if this theorem is proven in a computable meta-logic, 
then by Curry-Howard Correspondence, this theorem provides a big-step interpreter for closed term of boolean type.\YZ{Can we say something about strong/weak normalization?}\EDJreply{
  No. \\
  1. In the declarative system, we cannot talk about strong/weak normalization (because we don't have operational semantic, if you recall the definition of strong/weak normalization, it based on reduction/path of steps/op semantic). So any review says strong/weak normalization to you, please stop them. \\ 
  2. In declarative system, we only say ``normalization'' directly, which means, we construct a function that \\
      for arbitrary class of (judgemental-equivalent) terms, it will return one syntax representation (called normal-form) for each class \\
    (apparently most people will make the normal form  without beta redex, however, interestingly, they may do eta expansion instead of eta reduction because theoretically easier) \\ 
  3. So translation won't work because it compiles away the normal form of linkage (the $\mu^+$). This part requires a direct proof which construct normal form and neutral form for our calculus, and a normalization model from which we extract a runnable interpreter for open terms \\
  4. Of course we can conjecture we have that normalization function \\
  5. Also we do have close term normalization, which is canonicity. Or more operationally speaking, we have termination (a runnable interpreter) for close term (since QIIT is runnable, the canoncity model itself is the runnable interpreter), \\
  but we don't have termination (a runnable interpreter) for open terms.  \\ 
  So earlier you say ``normalize'' a recursion on an inductive type, that is no doable -- if the programmer wants to program on meta-theory, they will have to manually write out the a chain of judgemental equality (with a bunch of beta rules inside) by themselves. 
}

We first need the mathmatical setup to interpret universe level, following \citet{sterling2019algebraic}:

\newcommand{\Set}[1]{\ensuremath{\texttt{Set}_{#1}}}

{\textbf{Set-theoretic Universe Assumption.}} As a simplifying move, we assume an infinite hierarchy of Grothendieck universes $\Set{i}$ for $i \in \mathbb{N}$ in our meta-logic.

For people familiar with Agda, we can roughly consider Grothendieck Universe $\Set{i}$ as the $\Set{i}$ in Agda. In other words, each $\Set{i}$ is 
\begin{itemize}
  \item Closed under dependent function type and dependent tuple type. For example, later, for our interpretation of dependent function type, when we have $\denotesC{A}, \denotesC{B} \in \Set{i}$, we will have $\denotesC{\TyPi{A}{B}} \in \Set{i}$
  \item the hierarchy is cumulative as $\Set{i} \in \Set{i+1}$ and $\Set{i} \subseteq \Set{i+1}$
\end{itemize}


Like most logical relation proof,  we interpret each judgement and inductively interpret each syntax piece. We are working on an intrinsic setting thus even if we omit context for brevity, the syntax piece is still well-typed. 
% We will omit the treatment of the universe and the verification of most equality for simplicity (and the treatment of the universe will not affect our model). Interested audience can refer to \citet{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic} for a complete technical treatements.

\begin{align*}
  \denotesC{\goodCtx{\Gm}{i}} & \text{ is a Set of closed substitution} \goodSub{\cdot}{\_}{\Gm} \\
  % &\text{and we define } \goodCtxS{\Gm}{i} :\iff \denotesC{\goodCtx{\Gm}{i}} \text{ is defined} \\
  \denotesC{\goodType{\Gm}{T}{}} & \text{ is a function maps to Set s.t.} \\
  & \text{for arbitrary } \gm \in \denotesC{\goodCtx{\Gm}{}}, \denotesC{\goodType{\Gm}{T}{}}(\gm) \text{ is a Set of closed terms } \goodTerm{\cdot}{\_}{\sub{T}{\gm}} \\ 
  % &\text{and we define } \goodTypeS{\Gm}{T}{i} : \iff \denotesC{\goodType{\Gm}{T}{i}} \text{ is defined } \\ 
  \denotesC{\goodSub{\Gm}{\gm}{\Delta}} & \text{ is a function}: \denotesC{\goodCtx{\Gm}{i}} \to \denotesC{\goodCtx{\Delta}{i}} \text{ s.t. } \denotesC{\goodSub{\Gm}{\gm}{\Delta}}(\sigma) \coloneqq \SubstComp{\sigma}{\gm} \\
  % &\text{and we define } \goodSubC{\Gm}{\gm}{\Delta} :\iff \denotesC{\goodSub{\Gm}{\gm}{\Delta}} \text{ is defined} \\
  \denotesC{\goodTerm{\Gm}{t}{T}} & \text{ is a dependent function}: \prod_{\gm \in \denotesC{\goodCtx{\Gm}{i}}}\denotesC{\goodType{\Gm}{T}{}}(\gm)  \text{ s.t. } \denotesC{\goodTerm{\Gm}{t}{T}}(\gm) \coloneqq \sub{t}{\gm} \\
  \denotesC{\goodType{\Gm}{\top}{}}(\gm) &= \{t : t \equiv \unit \} \\
  \denotesC{\goodType{\Gm}{\bot}{}}(\gm) &= \emptyset \\
  \denotesC{\goodType{\Gm}{\cB}{}}(\gm) &= \{t : t \equiv \true \text{ or } t \equiv\false \} \\
  \denotesC{\goodType{\Gm}{\TyId{a}{b}}{}}(\gm) &= \{t : t \equiv \eqrefl{\sub{a}{\gm}} \} \text{ when } \sub{a}{\gm} \equiv \sub{b}{\gm} \\ 
  &= \emptyset \text{ otherwise } \\ 
  \denotesC{\goodType{\Gm}{\TyPi{A}{B}}{}} &= \\
  \denotesC{\goodType{\Gm}{\TySigma{A}{B}}{}} &= \\
  \denotesC{\goodCtx{\cdot}{}} &= \{\SubstEmp\} \text{  the singleton set with identity substitution} \\ 
  \denotesC{\goodCtx{\Gm, T}{}} &= \{ (\gamma , t) : \gamma \in \denotesC{\goodCtx{\Gm}{}}, t \in \denotesC{\goodType{\cdot}{\sub{T}{\gm}}{}}  \} \\
  \denotesC{\goodTerm{\Gm}{\unit}{\top}}(\gm) &= \unit\\
  \denotesC{\goodTerm{\Gm}{\true}{\cB}}(\gm) &= \true \\
  \denotesC{\goodTerm{\Gm}{\false}{\cB}}(\gm) &= \false \\
  \denotesC{\goodTerm{\Gm}{\ifb{c}{a}{b}}{T}}(\gm) &= \denotesC{a}(\gm) \text{ if } \denotes{c}(\gm) \equiv \true \\
  \denotesC{\goodTerm{\Gm}{\ifb{c}{a}{b}}{T}}(\gm) &= \denotesC{b}(\gm) \text{ if } \denotes{c}(\gm) \equiv \false \\
  \denotesC{\goodTerm{\Gm}{\eqrefl{t}}{\TyId{t}{t}}}(\gm) &= \eqrefl{\sub{t}{\gm}}\\
  \denotesC{\goodTerm{\Gm}{\lam{t}}{\TyPi{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\app{t}}{B}} &= \\
  \denotesC{\goodTerm{\Gm}{\pair{a}{b}}{\TySigma{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\fst{t}}{T}} &= \\
  \denotesC{\goodTerm{\Gm}{\snd{t}}{T}} &= \\
\end{align*}

\newcommand{\Glued}[1]{\ensuremath{{#1}^c}}
\newcommand{\GluedPi}[2]{\ensuremath{\Pi^c({#1},{#2})}}
\newcommand{\GSubstExt}[2]{\ensuremath{{#1},^c{#2}}}
\newcommand{\Gpair}[2]{\ensuremath{({#1},^c{#2})}}
\newcommand{\Gfst}[1]{\ensuremath{\texttt{fst}^c~{#1}}}
\newcommand{\Gsnd}[1]{\ensuremath{\texttt{snd}^c~{#1}}}
\newcommand{\Gsub}[2]{\ensuremath{{#1}\!\left[{#2}\right]^c}}
\newcommand{\Gapp}[1]{\ensuremath{\texttt{app}^c({#1})}}
\newcommand{\GSubstWeak}[1]{\ensuremath{(\texttt{p}^c)^{#1}}}
\newcommand{\GLSigAdd}[3]{\ensuremath{\nu^{+c}({#1},{#2},{#3})}}
\newcommand{\GCaseSig}[3]{\ensuremath{\texttt{CaseTy}^c({#1},{#2},{#3})}}

Once we have above model for MLTT, we can notice that we have a function $\Glued{\Pi}$ s.t. if $A' = \denotesC{A}, B' = \denotesC{B}$ then $\GluedPi{A'}{B'} = \denotesC{\TyPi{A}{B}}$. Type-theoretical speaking, this $\Glued{\Pi}$ is using the \emph{internal dependent function type} of the above model. Similarly, we can have $\Glued{\Sigma}$, $\Gpair{a}{b}$  and $\GSubstExt{\gm}{t}$  for dependent tuple type, depende tuple construction and substitution extension, and also all other constructions. These will be useful in our \TT model because as syntactic translation hinted, \TT reuses a lot from MLTT. What's more, during the construction of the model for \TT, we will use $\Glued{(\cdot)}$ when we can.

Now we can extend the above model to \TT , we still start with the judgement. Since linkage transformers are just syntactic sugar, we will not interpret it.
The intuition of the model is similar to that of the syntactic translation---use the canonicity model of sigma type (from the earlier work) for linkage type and using inductive facility in the meta-logic to justify our W-type. 

\begin{align*}
  \denotesC{\goodSig{\Gm}{\lsig}{n}} & \text{ is a list of 3-tuple of length $n$  } \\
  % & \text{ and we define  } {\goodSigC{\Gm}{\lsig}{n}} :\iff \denotesC{\goodSig{\Gm}{\lsig}{n}} \text{ is defined} \\ 
  \denotesC{\goodWSig{\Gm}{\wsig}{n}} &\text{ is a list of 2-tuple of length $n$ } \\
  % & \text{ and we define } \goodWSigC{\Gm}{\wsig}{n} :\iff \denotesC{\goodWSig{\Gm}{\tau}{n}} \text{ is defined} \\
  & \text{we define }\TyLkg{}, \TyTkg{} \text{ inductively on its input signature} \\ 
  \mathit{L}("nil") &= \denotesC{\top} \\
  \mathit{L}((A,s,T) :: tl)(\gm) &= {\mathit{L}(tl)}(\gm) \times \GluedPi{A}{T}(\gm) \quad \text{($\times$ is a special case for $\Glued{\Sigma}$)}  \\
  \mathit{P}("nil") &= \denotesC{\top}\\
  \mathit{P}((A,s,T) :: tl) &= \Glued{\Sigma}(\mathit{P}(tl), \Gsub{T}{\GSubstExt{\Glued{\pi_1}}{s}}) \quad \text{(doing substitution on $T$)} \\
  \denotesC{\goodType{\Gm}{\TyLkg{\lsig}}{}} &= \mathit{L}(\denotesC{\lsig}) \\
  \denotesC{\goodType{\Gm}{\TyTkg{\lsig}}{}} &= \mathit{P}(\denotesC{\lsig}) \\
  % 
  \denotesC{\goodSig{\Gm}{\LSigEmp}{0}} &= "nil"\\ 
  \denotesC{\goodSig{\Gm}{\LSigAdd{\lsig}{s}{T}}{n+1}} &= (\denotesC{A}, \denotesC{s}, \denotesC{T})::\denotesC{\lsig}\\ 
  \denotesC{\goodSig{\Gm}{\lsigproj{1}{\lsig}}{n}} &= "tl"~\denotesC{\lsig}\\ 
  \denotesC{\goodType{\Gm}{\lsigprojT{\lsig}}{}} &= ("hd"~\denotesC{\lsig})[0] \quad \text{ take the first element in the tuple}\\ 
  \denotesC{\goodTerm{\Gm, \TyTkg{\lsigproj{1}{\lsig}}}{\lsigproj{s}{\lsig}}{\lsigprojT{\lsig}}} &= ("hd"~\denotesC{\lsig})[1]\\ 
  \denotesC{\goodType{\Gm, \lsigprojT{\lsig}}{\lsigproj{2}{\lsig}}{}} &= ("hd"~\denotesC{\lsig})[2]\\
  \denotesC{\goodTerm{\Gm}{\LkgEmp}{\TyLkg{\LSigEmp}}} &= \denotesC{\unit} \\
  \denotesC{\goodTerm{\Gm}{\LkgAdd{\lkg}{t}}{\TyLkg{\LSigAdd{\lsig}{s}{T}}}}(\gm) &= (\denotesC{\lkg}(\gm), \lambda u . t (\gm, u)) \\
  \denotesC{\goodTerm{\Gm}{\Tkg{\lkg}}{\TyTkg{\lsig}}} &= \denotesC{\unit}
  \quad \text{ when \goodSig{\Gm}{\lsig}{0}} \\
  \denotesC{\goodTerm{\Gm}{\Tkg{\lkg}}{\TyTkg{\lsig}}} &= \Gpair{\denotesC{\Tkg{\lkgproj{1}{\lkg}}}}{\Gsub{\Gsub{\denotesC{\lkgproj{2}{\lkg}}}{\GSubstExt{\Glued{\GSubstWeak{1}}}{s}}}{\GSubstExt{\Glued{(\SubstId)}}{\denotesC{\Tkg{\lkgproj{1}{\lkg}}}}}}
  \\ &\text{ when} \denotesC{\goodSig{\Gm}{\lsig}{n+1}} = (A, s, T)::\_ \\
  \denotesC{\goodTerm{\Gm}{\lkgproj{1}{\lkg}}{\TyTkg{\lsig}}} &= \Gfst{\denotes{\lkg}} \\
  \denotesC{\goodTerm{\Gm, \lsigprojT{\lsig}}{\lkgproj{2}{\lkg}}{T}} &= \Gapp{\Gsnd{\denotes{\lkg}}} \\
  \denotesC{\goodWSig{\Gm}{\WSigEmp}{0}} &= "nil" \\
  \denotesC{\goodWSig{\Gm}{\WSigAdd{\wsig}{A}{B}}{n+1}} &= (\denotesC{A} , \denotesC{B}) :: \denotesC{\wsig}\\
  \denotesC{\goodType{\Gm}{\wsigproj{j}{1}{\wsig}}{}} &= (\text{ $j$-th element of }~\denotesC{\wsig})[0]\\
  \denotesC{\goodType{\Gm, \wsigproj{j}{1}{\wsig}}{\wsigproj{j}{2}{\wsig}}{}} &= (\text{ $j$-th element of }~\denotesC{\wsig})[1]\\
  \denotesC{\goodWSig{\Gm}{\WSigSub{\wsig}}{n}} &= "tl"~\denotesC{\wsig}\\
  \denotesC{\goodTerm{\Gm}{\wcode{\wsig}}{\cU}} &= \\
  \denotesC{\goodTerm{\Gm}{\Wsup{i}{\wsig}{a}{b}}{\El{\wcode{\wsig}}}} &= \\
  % CsTy~A~B~R &= {\GluedPi{A}{\GluedPi {\GluedPi{B}{\Gsub{R}{\GSubstWeak{2}}}} {\Gsub{R}{\GSubstWeak{2}}}}} \\
  \denotesC{\goodType{\Gm}{\CaseSig{A}{B}{R}}{}} &= 
  {\GluedPi{\denotesC{A}}{\GluedPi {\GluedPi{\denotesC{B}}{\Gsub{\denotesC{R}}{\GSubstWeak{2}}}} {\Gsub{\denotesC{R}}{\GSubstWeak{2}}}}} \\
  % CsTy~\denotesC{A}~\denotesC{B}~\denotesC{R}\\
  \text{we define } \RecSig{}{} &\text{ by induction on the signature} \\
  RS~"nil"~R &= \denotesC{\LSigEmp} \\
  RS~((A, B) :: tl)~R &= \GLSigAdd{RS~tl~R}{\Glued{\pi_2}}{\GCaseSig{A}{B}{R}} \\
  \denotesC{\goodType{\Gm}{\RecSig{\wsig}{R}}{}} &= RS~\denotesC{\tau}~\denotesC{R} \\
  \denotesC{\Recproj{j}{\lkg}} &= \text{ take the $j$-th field from } \lkg \\
  \denotesC{\goodTerm{\Gm}{\Wrec{\wsig}{\lkg}{t}}{T}} &= \\
\end{align*}


The first observation is that, with this model, we know our system is consistent---we cannot derive $\goodTerm{\cdot}{t}{\bot}$. Otherwise, we have $\denotesC{\goodTerm{\cdot}{t}{\bot}}(\SubstEmp) = \sub{t}{\SubstEmp} \in \denotesC{\bot}(\star) = \emptyset$, that is an element in an empty set, a contradiction.

\begin{theorem}[Consistency]
  We cannot derive a closed term of bottom type, i.e. ,$\cdot \not \vdash t : \bot$ for arbitrary $t$.
\end{theorem}

What's more, with the above model, we can map an arbitrary closed term $\goodTerm{\cdot}{t}{\cB}$ to get the result $\denotesC{\goodTerm{\cdot}{t}{\cB}}(\SubstEmp) = \sub{t}{\SubstEmp} \in \sub{\cB}{\SubstEmp} = \{\true, \false\}$, Thus $t \equiv \true \text{ or } t \equiv\false$, arriving at the basic canonicity result.


With the logical relation and the help of eta rule, we figure out the following canonical form
\begin{theorem}[Canonical Forms].
  \begin{itemize}
    \item if $\goodTerm{\cdot}{t}{El~(\wcode{\tau})}$ with $\goodWSig{\cdot}{\tau}{n}$, then $\goodTerm{\cdot}{t \equiv "Wsup"~j~a~b}{El~(\wcode{\tau})}$ for some $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot, B[(id, a)]}{b}{El~(\wcode{\tau})}$ and $j < n$
    \item if $\goodTerm{\cdot}{t}{\mathbb{B}}$ then $\goodTerm{\cdot}{t \equiv "tt"}{\mathbb{B}}$ or $\goodTerm{\cdot}{t \equiv "ff"}{\mathbb{B}}$ 
    \item if $\goodTerm{\cdot}{t}{\cL\sigma}$ with $\goodSig{\cdot}{\sigma}{n}$, then $\goodTerm{\cdot}{t \equiv \LkgAdd{o}{t}}{\cL\sigma}$ 
    
      $\quad$ for some $\goodTerm{\cdot}{o}{\cL(\lkgproj{1}{\sigma})}$ and $\goodTerm{\cdot, \lsigproj{2}{\sigma}}{t}{\lkgproj{2}{\sigma}}$
    \item if $\goodTerm{\cdot}{t}{\Sigma A B}$ then $\goodTerm{\cdot}{t = (a, b)}{\Sigma A B}$ with $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot}{b}{B[(id, a)]}$
    \footnote{We emphasize the last one because $\cCt t$ is a dependent pair}
  \end{itemize}
\end{theorem}

% the canonical form of inductive type, linkage and boolean 