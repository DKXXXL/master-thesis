Now we prove the consistency and canonicity using canoncity model. We follow the reducibility argument from~\cite{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic} to construct the canonicity model.
Each of their proof is based on QIIT, Category with Family\cite{dybjer1995internal} and Generalized Algebraic Theory \cite{cartmell1986generalised} as the syntax. However, our proof will still work directly on the earlier introdcued syntax for readability.
We will first specify the formulation of the most basic canonicity theorem. 

\begin{theorem}[Canonicity]
  For a closed boolean term $\goodTerm{\cdot}{t}{\cB}$, we have $\goodTerm{\cdot}{t \equiv \true}{\cB}$ or $\goodTerm{\cdot}{t \equiv \false}{\cB}$ hold.
\end{theorem}

Canonicity is one of the basic criteria to consider a dependent type theory to be ``a programming language or as a computational foundation for mathematics''.\footnote{See nlab explanation: \href{https://ncatlab.org/nlab/show/canonical+form}{Canonical Form}}
We can even argue that, if this theorem is proven in a computable meta-logic, 
then by Curry-Howard Correspondence, this theorem provides a big-step interpreter for closed term of boolean type.\YZ{Can we say something about strong/weak normalization?}\EDJreply{
  No. \\
  1. In the declarative system, we cannot talk about strong/weak normalization (because we don't have operational semantic, if you recall the definition of strong/weak normalization, it based on reduction/path of steps/op semantic). So any review says strong/weak normalization to you, please stop them. \\ 
  2. In declarative system, we only say ``normalization'' directly, which means, we construct a function that \\
      for arbitrary class of (judgemental-equivalent) terms, it will return one syntax representation (called normal-form) for each class \\
    (apparently most people will make the normal form  without beta redex, however, interestingly, they may do eta expansion instead of eta reduction because theoretically easier) \\ 
  3. So translation won't work because it compiles away the normal form of linkage (the $\mu^+$). This part requires a direct proof which construct normal form and neutral form for our calculus, and a normalization model from which we extract a runnable interpreter for open terms \\
  4. Of course we can conjecture we have that normalization function \\
  5. Also we do have close term normalization, which is canonicity. Or more operationally speaking, we have termination (a runnable interpreter) for close term (since QIIT is runnable, the canoncity model itself is the runnable interpreter), \\
  but we don't have termination (a runnable interpreter) for open terms.  \\ 
  So earlier you say ``normalize'' a recursion on an inductive type, that is no doable -- if the programmer wants to program on meta-theory, they will have to manually write out the a chain of judgemental equality (with a bunch of beta rules inside) by themselves. 
}

Like most logical relation proof,  we interpret each judgement, inductively interpret each syntax piece and prove compatibility lemma. We are working on an intrinsic setting thus even we omit context for brevity, the syntax piece is still well-typed. We only specify part of the logical relation proof for MLTT part. For the complete version, please refer to \citet{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic}.

\begin{align*}
  \denotesC{\goodCtx{\Gm}{i}} & \text{ is a Set of closed substitution} \goodSub{\cdot}{\_}{\Gm} \\
  &\text{and we define } \goodCtxS{\Gm}{i} :\iff \denotesC{\goodCtx{\Gm}{i}} \text{ is defined} \\
  \denotesC{\goodType{\Gm}{T}{}} & \text{ is a function maps to Set s.t.} \\
  & \text{for arbitrary } \gm \in \denotesC{\goodCtx{\Gm}{}}, \denotesC{\goodType{\Gm}{T}{}}(\gm) \text{ is a Set of closed terms } \goodTerm{\cdot}{\_}{\sub{T}{\gm}} \\ 
  &\text{and we define } \goodTypeS{\Gm}{T}{i} : \iff \denotesC{\goodType{\Gm}{T}{i}} \text{ is defined } \\ 
  \denotesC{\goodSub{\Gm}{\gm}{\Delta}} & \text{ is a function}: \denotesC{\goodCtx{\Gm}{i}} \to \denotesC{\goodCtx{\Delta}{i}} \text{ s.t. } \denotesC{\goodSub{\Gm}{\gm}{\Delta}}(\sigma) \coloneqq \SubstComp{\sigma}{\gm} \\
  &\text{and we define } \goodSubC{\Gm}{\gm}{\Delta} :\iff \denotesC{\goodSub{\Gm}{\gm}{\Delta}} \text{ is defined} \\
  \denotesC{\goodTerm{\Gm}{t}{T}} & \text{ is a dependent function}: \prod_{\gm \in \denotesC{\goodCtx{\Gm}{i}}}\denotesC{\goodType{\Gm}{T}{}}(\gm)  \text{ s.t. } \denotesC{\goodTerm{\Gm}{t}{T}}(\gm) \coloneqq \sub{t}{\gm} \\
  \denotesC{\goodType{\Gm}{\top}{}}(\gm) &= \{t : t \equiv \unit \} \\
  \denotesC{\goodType{\Gm}{\bot}{}}(\gm) &= \emptyset \\
  \denotesC{\goodType{\Gm}{\cB}{}}(\gm) &= \{t : t \equiv \true \text{ or } t \equiv\false \} \\
  \denotesC{\goodType{\Gm}{\TyId{a}{b}}{}}(\gm) &= \{t : t \equiv \eqrefl{\sub{a}{\gm}} \} \text{ when } \sub{a}{\gm} \equiv \sub{b}{\gm} \\ 
  &= \emptyset \text{ otherwise } \\ 
  \denotesC{\goodType{\Gm}{\TyPi{A}{B}}{}} &= \\
  \denotesC{\goodType{\Gm}{\TySigma{A}{B}}{}} &= \\
  \denotesC{\goodCtx{\cdot}{}} &= \{\SubstEmp\} \text{  the singleton set with identity substitution} \\ 
  \denotesC{\goodCtx{\Gm, T}{}} &= \{ (\gamma , t) : \gamma \in \denotesC{\goodCtx{\Gm}{}}, t \in \denotesC{\goodType{\cdot}{\sub{T}{\gm}}{}}  \} \\
  \denotesC{\goodTerm{\Gm}{\unit}{\top}} &= \\
  \denotesC{\goodTerm{\Gm}{\true}{\cB}} &= \\
  \denotesC{\goodTerm{\Gm}{\false}{\cB}} &= \\
  \denotesC{\goodTerm{\Gm}{\ifb{c}{a}{b}}{T}} &= \\
  \denotesC{\goodTerm{\Gm}{\eqrefl{t}}{\TyId{t}{t}}} &= \\
  \denotesC{\goodTerm{\Gm}{\lam{t}}{\TyPi{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\app{t}}{B}} &= \\
  \denotesC{\goodTerm{\Gm}{\pair{a}{b}}{\TySigma{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\fst{t}}{T}} &= \\
  \denotesC{\goodTerm{\Gm}{\snd{t}}{T}} &= \\
\end{align*}

Then we extend the above model to \TT , we still start with the judgement. Since linkage transformers are just syntactic sugar, we will not interpret it.
The intuition of the model is similar to that of the syntactic translation---use the canonicity model of sigma type (from the earlier work) for linkage type and using inductive facility in the meta-logic to justify our W-type. 

\begin{align*}
  \denotesC{\goodSig{\Gm}{\_}{n}} & \text{ is a Set  and we define  } {\goodSigC{\Gm}{\sigma}{n}} :\iff \denotesC{\sigma} \in  \denotesC{\goodSig{\Gm}{\_}{n}} \\ 
  \denotesC{\goodWSig{\Gm}{\_}{n}} &\text{ is a set of list of pairs of type interpretation of length } n \\
  & \text{ and we define } \goodWSigC{\Gm}{\tau}{n} :\iff \denotesC{\goodWSig{\Gm}{\tau}{n}} \in \denotesC{\goodWSig{\Gm}{\_}{n}}
\end{align*}


The first observation is that, with this model, we know our system is consistent---we cannot derive $\goodTerm{\cdot}{t}{\bot}$. Otherwise, we have $\denotesC{\goodTerm{\cdot}{t}{\bot}}(\SubstEmp) = \sub{t}{\SubstEmp} \in \denotesC{\bot}(\star) = \emptyset$, that is an element in an empty set, a contradiction.

\begin{theorem}[Consistency]
  We cannot derive a closed term of bottom type, i.e. ,$\cdot \not \vdash t : \bot$ for arbitrary $t$.
\end{theorem}

What's more, with the above model, we can map an arbitrary closed term $\goodTerm{\cdot}{t}{\cB}$ to get the result $\denotesC{\goodTerm{\cdot}{t}{\cB}}(\SubstEmp) = \sub{t}{\SubstEmp} \in \sub{\cB}{\SubstEmp} = \{\true, \false\}$, Thus $t \equiv \true \text{ or } t \equiv\false$, arriving at the basic canonicity result.


With the logical relation and the help of eta rule, we figure out the following canonical form
\begin{theorem}[Canonical Forms].
  \begin{itemize}
    \item if $\goodTerm{\cdot}{t}{El~(\wcode{\tau})}$ with $\goodWSig{\cdot}{\tau}{n}$, then $\goodTerm{\cdot}{t \equiv "Wsup"~j~a~b}{El~(\wcode{\tau})}$ for some $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot, B[(id, a)]}{b}{El~(\wcode{\tau})}$ and $j < n$
    \item if $\goodTerm{\cdot}{t}{\mathbb{B}}$ then $\goodTerm{\cdot}{t \equiv "tt"}{\mathbb{B}}$ or $\goodTerm{\cdot}{t \equiv "ff"}{\mathbb{B}}$ 
    \item if $\goodTerm{\cdot}{t}{\cL\sigma}$ with $\goodSig{\cdot}{\sigma}{n}$, then $\goodTerm{\cdot}{t \equiv \LkgAdd{o}{t}}{\cL\sigma}$ 
    
      $\quad$ for some $\goodTerm{\cdot}{o}{\cL(\lkgproj{1}{\sigma})}$ and $\goodTerm{\cdot, \lsigproj{2}{\sigma}}{t}{\lkgproj{2}{\sigma}}$
    \item if $\goodTerm{\cdot}{t}{\Sigma A B}$ then $\goodTerm{\cdot}{t = (a, b)}{\Sigma A B}$ with $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot}{b}{B[(id, a)]}$
    \footnote{We emphasize the last one because $\cCt t$ is a dependent pair}
  \end{itemize}
\end{theorem}

% the canonical form of inductive type, linkage and boolean 