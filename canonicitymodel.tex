Now we prove the consistency and canonicity using canoncity model. We follow the reducibility argument from~\cite{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic} to construct the canonicity model.
Each of their proof is based on QIIT, Category with Family\cite{dybjer1995internal} and Generalized Algebraic Theory \cite{cartmell1986generalised} as the syntax. Meanwhile, our proof will still work directly on the earlier introduced syntax for readability\footnote{We still take quotient, so ultimately our syntax should be considered as an instance of any of the above logical framework, without exposing the reader too many technical details}.

We will first specify the formulation of the most basic canonicity theorem. 

\begin{theorem}[Canonicity]
  For a closed boolean term $\goodTerm{\cdot}{t}{\cB}$, we have $\goodTerm{\cdot}{t \equiv \true}{\cB}$ or $\goodTerm{\cdot}{t \equiv \false}{\cB}$ hold.
\end{theorem}

Canonicity is a basic criteria to consider a dependent type theory to be ``a programming language or as a computational foundation for mathematics''.\footnote{See nlab explanation: \href{https://ncatlab.org/nlab/show/canonical+form}{Canonical Form}}
We can even argue that, if this theorem is proven in a computable meta-logic, 
then by Curry-Howard Correspondence, this theorem provides a big-step interpreter for closed term of boolean type.\YZ{Can we say something about strong/weak normalization?}\EDJreply{
  No. \\
  1. In the declarative system, we cannot talk about strong/weak normalization (because we don't have operational semantic, if you recall the definition of strong/weak normalization, it based on reduction/path of steps/op semantic). So any review says strong/weak normalization to you, please stop them. \\ 
  2. In declarative system, we only say ``normalization'' directly, which means, we construct a function that \\
      for arbitrary class of (judgemental-equivalent) terms, it will return one syntax representation (called normal-form) for each class \\
    (apparently most people will make the normal form  without beta redex, however, interestingly, they may do eta expansion instead of eta reduction because theoretically easier) \\ 
  3. So translation won't work because it compiles away the normal form of linkage (the $\mu^+$). This part requires a direct proof which construct normal form and neutral form for our calculus, and a normalization model from which we extract a runnable interpreter for open terms \\
  4. Of course we can conjecture we have that normalization function \\
  5. Also we do have close term normalization, which is canonicity. Or more operationally speaking, we have termination (a runnable interpreter) for close term (since QIIT is runnable, the canoncity model itself is the runnable interpreter), \\
  but we don't have termination (a runnable interpreter) for open terms.  \\ 
  So earlier you say ``normalize'' a recursion on an inductive type, that is no doable -- if the programmer wants to program on meta-theory, they will have to manually write out the a chain of judgemental equality (with a bunch of beta rules inside) by themselves. 
}

We first need the mathmatical setup to interpret universe level, following \citet{sterling2019algebraic}:

\newcommand{\Set}[1]{\ensuremath{\texttt{Set}_{#1}}}
\newtheorem{assumption}{Assumption}[section]

\begin{assumption}[Set-theoretic Universe Assumption] As a simplifying move, we assume an infinite hierarchy of Grothendieck universes $\Set{i}$ for $i \in \mathbb{N}$ in our ambient meta-logic.
\end{assumption}

We can roughly consider each Grothendieck Universe $\Set{i}$ as a $\Set{i}$ in Agda. In other words, each $\Set{i}$ is 
\begin{itemize}
  \item Closed under dependent function type and dependent tuple type. For example, later, for our interpretation of dependent function type, when we have $\denotesC{A}, \denotesC{B} \in \Set{i}$, we will have $\denotesC{\TyPi{A}{B}} \in \Set{i}$
  \item the hierarchy is cumulative as $\Set{i} \in \Set{i+1}$ and $\Set{i} \subseteq \Set{i+1}$
\end{itemize}


Like most logical relation proof,  we interpret each judgement and inductively interpret each syntax piece. We are working on an intrinsic setting thus even if we omit context for brevity, the syntax piece is still well-typed. However, unlike most logical relation proof, we are having a proof-relevant logical realtion, essential for modeling universes properly~\cite{coquand2018canonicity}. Our canonicity model at MLTT part is basically the same as shown in \citet{coquand2018canonicity}.
% We will omit the treatment of the universe and the verification of most equality for simplicity (and the treatment of the universe will not affect our model). Interested audience can refer to \citet{kaposi2019gluing, coquand2018canonicity,sterling2019algebraic} for a complete technical treatements.

\begin{align*}
  \denotesC{\goodCtx{\Gm}{k}} \text{ is a function }&: \{\gm : \goodSub{\cdot}{\gm}{\Gm} \} \to \Set{k} \quad \text{ (also sets indexed by closed substitution)}\\
  % &\text{and we define } \goodCtxS{\Gm}{i} :\iff \denotesC{\goodCtx{\Gm}{i}} \text{ is defined} \\
  \denotesC{\goodType{\Gm}{T}{j}} \text{ is a dependent function }&: \prod_{\goodSub{\cdot}{\gm}{\Gm}}\prod_{\gm' \in \denotesC{\goodCtx{\Gm}{}}(\gm)}\{t : \goodTerm{\cdot}{t}{\sub{T}{\gm}}\}\to\Set{j} \\
  % &\text{and we define } \goodTypeS{\Gm}{T}{i} : \iff \denotesC{\goodType{\Gm}{T}{i}} \text{ is defined } \\ 
  \denotesC{\goodSub{\Gm}{\delta}{\Delta}} \text{ is a dependent function }&: \prod_{\goodSub{\cdot}{\gm}{\Gm}} \prod_{\gm' \in \denotesC{\goodCtx{\Gm}{}}(\gm)} \denotesC{\goodCtx{\Dl}{}}(\delta \circ \gm) \\
  % &\text{and we define } \goodSubC{\Gm}{\gm}{\Delta} :\iff \denotesC{\goodSub{\Gm}{\gm}{\Delta}} \text{ is defined} \\
  \denotesC{\goodTerm{\Gm}{t}{T}} \text{ is a dependent function}&: \prod_{\goodSub{\cdot}{\gm}{\Gm}} \prod_{\gm' \in \denotesC{\goodCtx{\Gm}{}}}\denotesC{\goodType{\Gm}{T}{}}(\gm)(\gm')(\sub{t}{\gm})\\
  \denotesC{\goodType{\Gm}{\top}{}}(\gm)(\gm')(t) &= \{\star \} \\
  \denotesC{\goodType{\Gm}{\bot}{}}(\gm)(\gm')(t) &= \emptyset \\
  \denotesC{\goodType{\Gm}{\cB}{}}(\gm)(\gm')(t) &= \{\star^1 \ | \text{ when } t \equiv \true  \} \dot{\cup} \{\star^2 \ | \text{ when } t \equiv \false  \} \quad \text{disjoint union} \\
  \denotesC{\goodType{\Gm}{\TyId{a}{b}}{}}(\gm)(\gm')(t) &= \{\star \ |  \text{ when } t \equiv \eqrefl{\sub{a}{\gm}} \text{ and } \sub{a}{\gm} \equiv \sub{b}{\gm} \} \\
  \denotesC{\goodType{\Gm}{\TyPi{A}{B}}{}}(\gm)(\gm')(t) &= \prod_{\goodTerm{\cdot}{u}{\sub{A}{\gm}}} \ \ \prod_{u' \in \denotesC{A}(\gm)(\gm')(u)} \denotesC{B}(\SubstExt{\gm}{u})((\gm', u'))(\sub{\app{t}}{\SubstExt{"id"}{u}})\\
  \denotesC{\goodType{\Gm}{\TySigma{A}{B}}{}}(\gm)(\gm')(t) &= \sum_{u' \in \denotesC{A}(\gm)(\gm')} \\
  \denotesC{\goodCtx{\cdot}{}}(\gm) &= \{\star\} \quad \text{  a singleton set } \\ 
  \denotesC{\goodCtx{\Gm, T}{}}(\gm_t) &= \{ (\gamma , t) : \gamma \in \denotesC{\goodCtx{\Gm}{}}(\pi_1 \gm_t), t \in \denotesC{\goodType{\cdot}{\sub{T}{\gm}}{}}(\pi_2 \gm_t)  \} \\
  \denotesC{\goodTerm{\Gm}{\unit}{\top}}(\gm)(\gm') &= \star\\
  \denotesC{\goodTerm{\Gm}{\true}{\cB}}(\gm)(\gm') &= \star^1 \\
  \denotesC{\goodTerm{\Gm}{\false}{\cB}}(\gm)(\gm') &= \star^2 \\
  \denotesC{\goodTerm{\Gm}{\ifb{c}{a}{b}}{T}}(\gm)(\gm') &= \denotesC{a}(\gm) \text{ if } \denotes{c}(\gm)(\gm') = \star^1 \\
  \denotesC{\goodTerm{\Gm}{\ifb{c}{a}{b}}{T}}(\gm)(\gm') &= \denotesC{b}(\gm)(\gm') \text{ if } \denotes{c}(\gm)(\gm') = \star^2 \\
  \denotesC{\goodTerm{\Gm}{\eqrefl{t}}{\TyId{t}{t}}}(\gm)(\gm') &= \star\\
  \denotesC{\goodTerm{\Gm}{\lam{t}}{\TyPi{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\app{t}}{B}} &= \\
  \denotesC{\goodTerm{\Gm}{\pair{a}{b}}{\TySigma{A}{B}}} &= \\
  \denotesC{\goodTerm{\Gm}{\fst{t}}{T}} &= \\
  \denotesC{\goodTerm{\Gm}{\snd{t}}{T}} &= \\
  \denotesC{\goodType{\Gm}{\cU_j}{j+1}}(\gm)(\gm')(T) &= \{t : \goodTerm{\cdot}{t}{\El{T}}\}  \to \Set{j} \\
  \denotesC{\goodTerm{\Gm}{\codety{T}}{\cU_j}}(\gm)(\gm') &= \denotesC{T}(\gm)(\gm') \\ 
  \denotesC{\goodType{\Gm}{\El{T}}{j}}(\gm)(\gm')(t) &= \denotesC{T}(\gm)(\gm')(t) \\
\end{align*}

\newcommand{\Glued}[1]{\ensuremath{{#1}^\bullet}}
\newcommand{\GluedPi}[2]{\ensuremath{\Pi^\bullet({#1},{#2})}}
\newcommand{\GSubstExt}[2]{\ensuremath{{#1},^\bullet{#2}}}
\newcommand{\Gpair}[2]{\ensuremath{({#1},^\bullet{#2})}}
\newcommand{\Gfst}[1]{\ensuremath{\texttt{fst}^\bullet~{#1}}}
\newcommand{\Gsnd}[1]{\ensuremath{\texttt{snd}^\bullet~{#1}}}
\newcommand{\Gsub}[2]{\ensuremath{{#1}\!\left[{#2}\right]^\bullet}}
\newcommand{\Glam}[1]{\ensuremath{\lambda^\bullet({#1})}}
\newcommand{\Gapp}[1]{\ensuremath{\texttt{app}^\bullet({#1})}}
\newcommand{\GSubstWeak}[1]{\ensuremath{(\texttt{p}^\bullet)^{#1}}}
\newcommand{\GLSigAdd}[3]{\ensuremath{\nu^{+\bullet}({#1},{#2},{#3})}}
\newcommand{\GCaseSig}[3]{\ensuremath{\texttt{CaseTy}^\bullet({#1},{#2},{#3})}}
\newcommand{\Gmodel}[1]{\ensuremath{{({#1})}^c}}


The counter-intuitive part of the proof-relevant logical relation is the treatment of proposition---a proposition is encoded as a subsingleton data. For example, $\denotesC{\goodType{\Gm}{\top}{}} = $ $ \{\star \ | \text{  when } t \equiv \unit \}$ represents a singleton set when $t \equiv \unit$ or an empty set otherwise. However, not all the denotation of types are subsingleton---the salient counter-examples are $\denotes{\goodType{\Gm}{\cU}{}}$ and $\denotes{\goodType{\Gm}{\TyPi{A}{B}}{}}$. The non-trivial interpretation on these types is the main reason we use proof-relevant logical relations.


Given above model for MLTT, we should have such a function ${\Pi}^c$ s.t. ${\Pi}^c({\denotesC{A}},{\denotesC{B}}) = \denotesC{\TyPi{A}{B}}$. We want to reuse this function when defining the rest of the model of \TT, because as syntactic translation hinted, \TT reuses a lot from MLTT. Type-theoretical speaking, this ${\Pi}^c$ is using the \emph{internal dependent function type} of the above model. However this is not possible because the definition $\denotesC{\TyPi{A}{B}}$ is not solely based on the $\denotesC{A}$ and $\denotesC{B}$, but also on the syntax $\goodType{\Gm}{A}{}$ and $\goodType{\Gm}{B}{}$. 

Thus, we define a new denotation $\denotesCC{S} \coloneq (S, \denotesC{S})$, that will return the syntax piece $S$ as well. Thus we can have a function $\Glued{\Pi}$ s.t. $\GluedPi{\denotesCC{A}}{\denotesCC{B}} = \denotesCC{\TyPi{A}{B}}$ now that syntax is also provided. Similarly, we can have $\Glued{\Sigma}$, $\Gpair{a}{b}$  and $\GSubstExt{\gm}{t}$  for dependent tuple type, depende tuple construction and substitution extension, and also all other constructions.  What's more, given $\Glued{S}$ a pair of syntax and model , we denote $\Gmodel{\Glued{S}}$ as getting the (canonicity) model part (the second element in that pair).  
% These will be useful in our \TT model because as syntactic translation hinted, \TT reuses a lot from MLTT. What's more, during the construction of the model for \TT, we will use $\Glued{(\cdot)}$ when we can.

Now we can extend the above model to \TT , we still start with the judgement. Since linkage transformers are just syntactic sugar, we will not interpret it.
The intuition of the model is similar to that of the syntactic translation---use the canonicity model of sigma type (from the earlier work) for linkage type and using inductive facility in the meta-logic to justify our W-type. 

\begin{align*}
  \denotesC{\goodSig{\Gm}{\lsig}{n}} & \text{ is a list of 3-tuple of length $n$  } \\
  % & \text{ and we define  } {\goodSigC{\Gm}{\lsig}{n}} :\iff \denotesC{\goodSig{\Gm}{\lsig}{n}} \text{ is defined} \\ 
  \denotesC{\goodWSig{\Gm}{\wsig}{n}} &\text{ is a list of 2-tuple of length $n$ } \\
  % & \text{ and we define } \goodWSigC{\Gm}{\wsig}{n} :\iff \denotesC{\goodWSig{\Gm}{\tau}{n}} \text{ is defined} \\
  & \text{we define }\TyLkg{}, \TyTkg{} \text{ inductively on its input signature} \\ 
  \Glued{\mathit{L}}("nil") &= ( \TyLkg{\LSigEmp} , \denotesC{\top} ) \\
  \Glued{\mathit{L}}((A,s,T) :: tl) &= {\Glued{\mathit{L}}(tl)}(\gm) \times^\bullet \GluedPi{A}{T} \quad \text{($\times^\bullet$ is a special case for $\Glued{\Sigma}$)}  \\
  \Glued{\mathit{P}}("nil") &= ( \TyTkg{\LSigEmp} , \denotesC{\top} )\\
  \Glued{\mathit{P}}((A,s,T) :: tl) &= \Glued{\Sigma}(\Glued{\mathit{P}}(tl), \Gsub{T}{\GSubstExt{\Glued{\pi_1}}{s}}) \quad \text{(doing substitution on $T$)} \\
  \denotesC{\goodType{\Gm}{\TyLkg{\lsig}}{}} &= \Gmodel{\Glued{\mathit{L}}(\denotesC{\lsig})} \quad \text{ discard syntax info} \\
  \denotesC{\goodType{\Gm}{\TyTkg{\lsig}}{}} &= \Gmodel{\Glued{\mathit{P}}(\denotesC{\lsig})} \\
  % 
  \denotesC{\goodSig{\Gm}{\LSigEmp}{0}} &= "nil"\\ 
  \denotesC{\goodSig{\Gm}{\LSigAdd{\lsig}{s}{T}}{n+1}} &= (\denotesCC{A}, \denotesCC{s}, \denotesCC{T})::\denotesC{\lsig}\\ 
  \denotesC{\goodSig{\Gm}{\lsigproj{1}{\lsig}}{n}} &= "tl"~\denotesC{\lsig}\\ 
  \denotesC{\goodType{\Gm}{\lsigprojT{\lsig}}{}} &= \Gmodel{("hd"~\denotesC{\lsig})[0]} \quad \text{ take the first element in the tuple,...}\\ 
  \denotesC{\goodTerm{\Gm, \TyTkg{\lsigproj{1}{\lsig}}}{\lsigproj{s}{\lsig}}{\lsigprojT{\lsig}}} &= \Gmodel{("hd"~\denotesC{\lsig})[1]} \quad \text{  ... and discard syntax}\\ 
  \denotesC{\goodType{\Gm, \lsigprojT{\lsig}}{\lsigproj{2}{\lsig}}{}} &= \Gmodel{("hd"~\denotesC{\lsig})[2]}\\
  \denotesC{\goodTerm{\Gm}{\LkgEmp}{\TyLkg{\LSigEmp}}} &= \denotesC{\unit} \\
  \denotesC{\goodTerm{\Gm}{\LkgAdd{\lkg}{t}}{\TyLkg{\LSigAdd{\lsig}{s}{T}}}} &= \Gmodel{\Gpair{\denotesCC{\lkg}}{\Glam{\denotesCC{t}}}} \\
  \denotesC{\goodTerm{\Gm}{\Tkg{\lkg}}{\TyTkg{\lsig}}} &= \denotesC{\unit}
  \quad \text{ when \goodSig{\Gm}{\lsig}{0}} \\
  \denotesC{\goodTerm{\Gm}{\Tkg{\lkg}}{\TyTkg{\lsig}}} &= \Gmodel{\Gpair{\denotesC{\Tkg{\lkgproj{1}{\lkg}}}}{\Gsub{\Gsub{\denotesC{\lkgproj{2}{\lkg}}}{\GSubstExt{\Glued{\GSubstWeak{1}}}{s}}}{\GSubstExt{\Glued{(\SubstId)}}{\denotesC{\Tkg{\lkgproj{1}{\lkg}}}}}}}
  \\ &\text{ when} \denotesC{\goodSig{\Gm}{\lsig}{n+1}} = (A, s, T)::\_ \\
  \denotesC{\goodTerm{\Gm}{\lkgproj{1}{\lkg}}{\TyTkg{\lsig}}} &= \Gmodel{\Gfst{\denotesCC{\lkg}}} \\
  \denotesC{\goodTerm{\Gm, \lsigprojT{\lsig}}{\lkgproj{2}{\lkg}}{T}} &= \Gmodel{\Gapp{\Gsnd{\denotesCC{\lkg}}}} \\
  \denotesC{\goodWSig{\Gm}{\WSigEmp}{0}} &= "nil" \\
  \denotesC{\goodWSig{\Gm}{\WSigAdd{\wsig}{A}{B}}{n+1}} &= (\denotesCC{A} , \denotesCC{B}) :: \denotesC{\wsig}\\
  \denotesC{\goodType{\Gm}{\wsigproj{j}{1}{\wsig}}{}} &= \Gmodel{(\text{ $j$-th element of }~\denotesC{\wsig})[0]}\\
  \denotesC{\goodType{\Gm, \wsigproj{j}{1}{\wsig}}{\wsigproj{j}{2}{\wsig}}{}} &= \Gmodel{(\text{ $j$-th element of }~\denotesC{\wsig})[1]}\\
  \denotesC{\goodWSig{\Gm}{\WSigSub{\wsig}}{n}} &= "tl"~\denotesC{\wsig}\\
  \denotesC{\goodTerm{\Gm}{\wcode{\wsig}}{\cU}} &= \\
  \denotesC{\goodTerm{\Gm}{\Wsup{i}{\wsig}{a}{b}}{\El{\wcode{\wsig}}}} &= \\
  % CsTy~A~B~R &= {\GluedPi{A}{\GluedPi {\GluedPi{B}{\Gsub{R}{\GSubstWeak{2}}}} {\Gsub{R}{\GSubstWeak{2}}}}} \\
  \denotesC{\goodType{\Gm}{\CaseSig{A}{B}{R}}{}} &= 
  \Gmodel{\GluedPi{\denotesC{A}}{\GluedPi {\GluedPi{\denotesC{B}}{\Gsub{\denotesC{R}}{\GSubstWeak{2}}}} {\Gsub{\denotesC{R}}{\GSubstWeak{2}}}}} \\
  % CsTy~\denotesC{A}~\denotesC{B}~\denotesC{R}\\
  \text{we define } \RecSig{}{} &\text{ by induction on the signature} \\
  RS~"nil"~R &= \denotesCC{\LSigEmp} \\
  RS~((A, B) :: tl)~R &= \GLSigAdd{RS~tl~R}{\Glued{\pi_2}}{\GCaseSig{A}{B}{R}} \\
  \denotesC{\goodType{\Gm}{\RecSig{\wsig}{R}}{}} &= \Gmodel{RS~\denotesC{\tau}~\denotesC{R}} \\
  \denotesC{\Recproj{j}{\lkg}} &= \text{ take the $j$-th field from } \lkg \\
  \denotesC{\goodTerm{\Gm}{\Wrec{\wsig}{\lkg}{t}}{T}} &= \\
\end{align*}


The first observation is that, with this model, we know our system is consistent---we cannot derive $\goodTerm{\cdot}{t}{\bot}$. Otherwise, we have $\denotesC{\goodTerm{\cdot}{t}{\bot}}(\SubstEmp)(\star) \in \denotesC{\bot}(\SubstEmp)(\star)(\sub{t}{\gm}) = \emptyset$, that is an element in an empty set, a contradiction.

\begin{theorem}[Consistency]
  We cannot derive a closed term of bottom type, i.e. ,$\cdot \not \vdash t : \bot$ for arbitrary $t$.
\end{theorem}

What's more, with the above model, we can map an arbitrary closed boolean term $\goodTerm{\cdot}{t}{\cB}$ to get the result $\denotesC{\goodTerm{\cdot}{t}{\cB}}(\SubstEmp)(\star) = \star^1$ or $\star^2$, witnessing $t \equiv \true \text{ or } t \equiv\false$, arriving at the basic canonicity result.


With the logical relation and the help of eta rule, we figure out the following canonical form
\begin{theorem}[Canonical Forms].
  \begin{itemize}
    \item if $\goodTerm{\cdot}{t}{El~(\wcode{\tau})}$ with $\goodWSig{\cdot}{\tau}{n}$, then $\goodTerm{\cdot}{t \equiv "Wsup"~j~a~b}{El~(\wcode{\tau})}$ for some $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot, B[(id, a)]}{b}{El~(\wcode{\tau})}$ and $j < n$
    \item if $\goodTerm{\cdot}{t}{\mathbb{B}}$ then $\goodTerm{\cdot}{t \equiv "tt"}{\mathbb{B}}$ or $\goodTerm{\cdot}{t \equiv "ff"}{\mathbb{B}}$ 
    \item if $\goodTerm{\cdot}{t}{\cL\sigma}$ with $\goodSig{\cdot}{\sigma}{n}$, then $\goodTerm{\cdot}{t \equiv \LkgAdd{o}{t}}{\cL\sigma}$ 
    
      $\quad$ for some $\goodTerm{\cdot}{o}{\cL(\lkgproj{1}{\sigma})}$ and $\goodTerm{\cdot, \lsigproj{2}{\sigma}}{t}{\lkgproj{2}{\sigma}}$
    \item if $\goodTerm{\cdot}{t}{\Sigma A B}$ then $\goodTerm{\cdot}{t = (a, b)}{\Sigma A B}$ with $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot}{b}{B[(id, a)]}$
    \footnote{We emphasize the last one because $\cCt t$ is a dependent pair}
  \end{itemize}
\end{theorem}

% the canonical form of inductive type, linkage and boolean 