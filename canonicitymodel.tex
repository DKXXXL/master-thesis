We follow the reducibility argument from~\citet{coquand2018canonicity,sterling2019algebraic, kaposi2019gluing} to construct the canonicity model. We will first specify the formulation of the most basic canonicity theorem. 

\begin{theorem}[Canonicity]
  For a closed boolean term $\goodTerm{\cdot}{t}{\cB}$, we have $\goodTerm{\cdot}{t \equiv \true}{\cB}$ or $\goodTerm{\cdot}{t \equiv \false}{\cB}$ hold.
\end{theorem}

Canonicity is one of the basic criteria to consider a dependent type theory to be ``a programming language or as a computational foundation for mathematics''.\footnote{See nlab explanation: \href{https://ncatlab.org/nlab/show/canonical+form}{Canonical Form}}
We can even argue that, if this theorem is proven in a computable meta-logic, 
then by Curry-Howard Correspondence, this theorem provides a big-step interpreter for closed term of boolean type.\YZ{Can we say something about strong/weak normalization?}\EDJreply{
  No. \\
  1. In the declarative system, we cannot talk about strong/weak normalization (because we don't have operational semantic, if you recall the definition of strong/weak normalization, it based on reduction/path of steps/op semantic). So any review says strong/weak normalization to you, please stop them. \\ 
  2. In declarative system, we only say ``normalization'' directly, which means, we construct a function that \\
      for arbitrary class of (judgemental-equivalent) terms, it will return one syntax representation (called normal-form) for each class \\
    (apparently most people will make the normal form  without beta redex, however, interestingly, they may do eta expansion instead of eta reduction because theoretically easier) \\ 
  3. So translation won't work because it compiles away the normal form of linkage (the $\mu^+$). This part requires a direct proof which construct normal form and neutral form for our calculus, and a normalization model from which we extract a runnable interpreter for open terms \\
  4. Of course we can conjecture we have that normalization function \\
  5. Also we do have close term normalization, which is canonicity. Or more operationally speaking, we have termination (a runnable interpreter) for close term (since QIIT is runnable, the canoncity model itself is the runnable interpreter), \\
  but we don't have termination (a runnable interpreter) for open terms.  \\ 
  So earlier you say ``normalize'' a recursion on an inductive type, that is no doable -- if the programmer wants to program on meta-theory, they will have to manually write out the a chain of judgemental equality (with a bunch of beta rules inside) by themselves. 
}

Now we sketch out the big picture of the proof. The canonicity model $"Tm"^C~\Gamma^C~"T"^C$ will map each syntax piece $("t : Tm Γ T") \mapsto "(t, tₚ) :" "Tm"^C~\Gamma^C~"T"^C = \sum~("t : Tm Γ T")."Tm"_p~\Gamma^C~"T"^C~"t"$ to a dependent pair\footnote{This $"Tm"_p$ is usually called dependent model.}, of which the first part will be the same as the input syntax. Using this mapping on closed boolean term $"t : Tm ⋅ "\mathbb{B}$ will give us a proof of $"Tm"_p~\cdot^C~\mathbb{B}^C~"t"$, which will unfolds to our final goal $"t" \equiv "tt" + "t" \equiv "ff"$. Roughly, this can read as ``every closed boolean term is reducible''.  Thus once we can ``propagate'' $(\cdot)^C$ into every syntactic piece, and construct this model, we are done. In our (pseudo) Agda formulation, we use $(\cdot)_2$ to replace the notation of $(\cdot)^C$ because we consider most parts of this model are actually a dependent pair.

Another helpful analogy of the canonicity model is that $"Tm"_p~\Gamma^C~"T"^C~"t"$ can be understood as ``a reducible set'': $"t" \in \{$ Reducible Terms of type $T$ (and $T_p$) in context $\Gamma$ (and $\Gamma_p$) $\}$. The reformulation can be understood as an unfolding of the \textit{type-theoretic logical relation proof}.\footnote{We usually use predicate to encode ``belong to''/``is element of'' relation in type theory} If we use the terminology of the conventional formulation, this reducible set means if we apply its element $t$ with a substitution $\gamma$ from the set $\Gamma$ where we have $\Gamma_p$ witnesses the ``reducibility'' of $\Gamma$, then we will have $t[\gamma] \in T_p$ as a closed and \textbf{reducible} term. Now if $\Gamma$ is actually empty $\cdot$ and $T$ is $\cB$, we are done. 

% $\Gamma_p$ witnesses the set of substitution $ \gamma \in \Gamma$ makes applied term $t[\gamma]$ closed and \textbf{reducible} of types $T_p$. Thus, we proved $t[\gamma] \in T_p$---the set of closed reducible term of type $T$---when $\gamma \in \Gamma_p$.

% The proof can be found in appendix. 
The intuition of the model is similar to that of the consistency model---use the canonicity model of sigma type (from the earlier work) for linkage type and using Agda's inductive facility to justify our W-type. 

With the logical relation and the help of eta rule, we figure out the following canonical form
\begin{theorem}[Canonical Forms].
  \begin{itemize}
    \item if $\goodTerm{\cdot}{t}{El~(\wcode{\tau})}$ with $\goodWSig{\cdot}{\tau}{n}$, then $\goodTerm{\cdot}{t \equiv "Wsup"~j~a~b}{El~(\wcode{\tau})}$ for some $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot, B[(id, a)]}{b}{El~(\wcode{\tau})}$ and $j < n$
    \item if $\goodTerm{\cdot}{t}{\mathbb{B}}$ then $\goodTerm{\cdot}{t \equiv "tt"}{\mathbb{B}}$ or $\goodTerm{\cdot}{t \equiv "ff"}{\mathbb{B}}$ 
    \item if $\goodTerm{\cdot}{t}{\cL\sigma}$ with $\goodSig{\cdot}{\sigma}{n}$, then $\goodTerm{\cdot}{t \equiv \LkgAdd{o}{t}}{\cL\sigma}$ 
    
      $\quad$ for some $\goodTerm{\cdot}{o}{\cL(\lkgproj{1}{\sigma})}$ and $\goodTerm{\cdot, \lsigproj{2}{\sigma}}{t}{\lkgproj{2}{\sigma}}$
    \item if $\goodTerm{\cdot}{t}{\Sigma A B}$ then $\goodTerm{\cdot}{t = (a, b)}{\Sigma A B}$ with $\goodTerm{\cdot}{a}{A}$ and $\goodTerm{\cdot}{b}{B[(id, a)]}$
    \footnote{We emphasize the last one because $\cCt t$ is a dependent pair}
  \end{itemize}
\end{theorem}

% the canonical form of inductive type, linkage and boolean 