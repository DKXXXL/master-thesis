Firstly, there are four standard kinds of judgement in MLTT, well-typed context $\goodCtx{\Gamma}{l}$, well-typed type $\goodType{\Gamma}{T}{l}$, well-typed term $\goodTerm{\Gamma}{t}{T}$ and well-typed substitution $\goodSub{\Gamma}{\gamma}{\Delta}$. We are following \citep{kaposi2019gluing} but we will omit the universe level attached to the judgement here, to make it more readable. After these, we will have four new kinds of judgement. 

Because we consider each judgement as a (dependent) QIIT type, each judgement has a \textit{type} and each sequent is well-typed as well (otherwise how can they be encoded in Agda?). Latex-wise, we spell out these \textit{well-formed-ness rule} of type judgements and their Agda counterpart to make things more understandable. Of course, a well-formed sequent  is not necessarily derivable. 
Due to our intrinsic setting, we can omit a lot of presumption, for example we don't spell out that the rule "Type-Universe" requires a well-typed context, even though it did implicitly -- because it is not possible to have "not-well-formed" context in our setting.

Among them, sealing judgement $\goodSeal{\Gamma}{\_}{\sigma}{\tau}$ is the most special one because it is actually just a short hand of term judgement $\goodTerm{\Gamma , \cL \sigma}{\_}{\cL\tau[\pi_1]}$. Even though we will introduce rules for sealing judgement, we will later show that all these rules are derivable by term judgements.

\begin{figure}[H]
  \begin{minipage}[b]{0.3\linewidth}
      $$
      \Rule[name=Tm]
      {\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{T}{j}}
      {\goodTerm{\Gamma}{\_}{T}}
      $$
      $$
      \Rule[name=Tms]
      {\goodCtx{\Gamma}{i} \quad \goodCtx{\Delta}{i}}
      {\goodSub{\Gamma}{\_}{\Delta} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Sig]
      {\goodCtx{\Gamma}{i} \quad n \in \nat}
      {\goodSig{\Gamma}{\_}{n} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Seal]
      {\goodCtx{\Gamma}{i} \quad \goodSig{\Gamma}{\sigma, \tau}{n}}
      {\goodSeal{\Gamma}{\_}{\sigma}{\tau} \text{ is well-formed}}
      $$
  \end{minipage}
  \begin{minipage}[b]{0.6\linewidth}
    \begin{minted}[]{agda}
      data Con   : Set 
      data Ty    : Con ‚Üí Set   
      data Tms   : Con ‚Üí Con ‚Üí Set 
      data Tm    : (Œì : Con) ‚Üí Ty Œì  ‚Üí Set 
      data Sig  : Con ‚Üí ‚Ñï ‚Üí Set
      data WSig : Con ‚Üí ‚Ñï ‚Üí Set 
      data Inh  : (Œì : Con) ‚Üí Sig Œì n ‚Üí Sig Œì m ‚Üí Set
      Seal : (Œì : Con) ‚Üí Sig Œì n ‚Üí Sig Œì n ‚Üí Set
    \end{minted}
  \end{minipage}
  \caption{Well-formed-ness of Four New Judgements}
\end{figure}





Now we show case some of the typing rules, and demonstrate their typed encoding in our (fake) Agda, to help the reader  grasp the rough idea of our type system and understand the Agda-formulation of the typing rules easier.


  \label{fig:rules:well-typed-ctx}
\judgebox{\goodCtx{\Gamma}{i}}
$$ 
\Rule[name=Empty Context]{}{\goodCtx{\cdot}{0}} 
\quad
\Rule[name=Context Extension]
{\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{A}{j}}
{\goodCtx{\Gamma, A}{i \cup j}}  
$$


\judgebox{ \goodType{\Gamma}{T}{i} }
$$
\Rule[name=Type Universe]
{}
{\goodType{\Gamma}{\cU_j}{j + 1}}
\quad 
\Rule[name=Boolean]
{}
{\goodType{\Gamma}{\cB}{0}}
\quad 
\Rule[name=Bottom]
{}
{\goodType{\Gamma}{\bot}{0}}
\quad 
\Rule[name=Function]
{\goodType{\Gamma}{A}{j} 
  \quad \goodType{\Gamma, A}{B}{k}}
{\goodType{\Gamma}{\Pi A B}{j \cup k}}
$$

$$
\Rule[name=Type Subst]
{\goodType{\Delta}{T}{j} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{j}}
\quad 
\Rule[name=Func Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{(\Pi A B)[\gamma] \equiv \Pi A[\gamma] B[\gamma^\uparrow] }{j \cup k}}
$$
$$
\Rule[name=Base Type Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{\cU_j[\gamma] \equiv \cU_j }{j + 1} \quad
  \goodType{\Gamma}{\cB[\gamma] \equiv \cB}{0} \quad 
  \goodType{\Gamma}{\bot[\gamma] \equiv \bot}{0}
}
$$
\judgebox{ \goodTerm{\Gamma}{t}{T} }
$$
\Rule[name=Univ-1]
{\goodType{\Gamma}{T}{j}}
{\goodTerm{\Gamma}{c \ T}{\cU_j}
}\quad
\Rule[name=Univ-2]
{\goodTerm{\Gamma}{T}{\cU_j}}
{\goodType{\Gamma}{El \ T}{j}}
\quad
\Rule[name=True]
{}
{\goodTerm{\Gamma}{tt}{\cB}}
\quad
\Rule[name=False]
{}
{\goodTerm{\Gamma}{ff}{\cB}}
$$
$$
\Rule[name=Term Subst]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
\quad 
\Rule[name=Func intro]
{\goodTerm{\Gamma, A}{t}{B}}
{\goodTerm{\Gamma}{\lambda t}{\Pi A B}}
\quad 
\Rule[name=Lam Subst]
{}
{\goodTerm{\Gamma}{(\lambda t)[\gamma] \equiv \lambda (t[\gamma^\uparrow])}{\Pi A B}}
$$
$$
\Rule[name=Base Type/Term Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{(El \ T)[\gamma] \equiv El \ (T[\gamma]) }{j} \quad
 \goodTerm{\Gamma}{tt[\gamma] \equiv tt}{\cB} \quad 
 \goodTerm{\Gamma}{ff[\gamma] \equiv ff}{\cB} 
}
$$
\judgebox{\goodSub{\Gamma}{\sigma}{\Delta}}
$$
\Rule[name=Empty Subst]
{}{\goodSub{\Gamma}{\epsilon}{\cdot}}
\quad
\Rule[name=Id Subst]
{}{\goodSub{\Gamma}{id}{\Gamma}}
\quad
\Rule[name=Subst Extension]
{\goodSub{\Gamma}{\sigma}{\Delta} \quad \goodTerm{\Gamma}{t}{A[\sigma]}}
{\goodSub{\Gamma}{(\sigma, t)}{(\Delta, A)}}
$$

$$
\Rule[name=Proj Subst-1]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_1 \sigma}{\Delta}}
\quad
\Rule[name=Proj Subst-2]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_2 \sigma}{A[\pi_1 \sigma]}}
\quad
\Rule[name=Proj-Ext]
{}
{\goodSub{\Gamma}{(\pi_1 \sigma, \pi_2 \sigma) \equiv \sigma}{\Delta}}
$$

We have shown case some exemplar rules for all four standard type judgments, now we focus on the newly introduced facility. 


We have two kinds of signatures, one for extensible inductive type, the other for linkages.



\judgebox{\goodWSig{\Gamma}{\sigma}{n}}
$$
\Rule[name=Inductive Type]
{\goodWSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{W\sigma}{i}}
\quad
\Rule[name=Inductive Sig]
{\goodWSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodWSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{W (\sigma[\gamma]) \equiv (W \sigma)[\gamma]}{i}}
$$


Recall in W-type \citep{martin1982constructive}, a pair of type $x : A \vdash B(x)$ decides a W-type. For simplicity,  we use a list of pairs of such $A, B$ as the signature for a given inductive type. Doing so, all the constructors will have a fixed form \mintinline{agda}{cstr·µ¢ : (x : A·µ¢) ‚Üí (B·µ¢ x ‚Üí W) ‚Üí W}. 
Of course we need to put an eye on the substitution law for each piece of the syntax. In our meta-theory, we only formulate non-dependent eliminator, i.e. the \textit{recursor}. Each recursor is constructed by a linkage contained with functions dealing with each case. Thus code-reuse for recursor is delegated by the inheritance for linkage.


\judgebox{\goodSig{\Gamma}{\sigma}{n} }
$$
\Rule[name=Linkage Type]
{\goodSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\cL \sigma}{i}}
\quad
\Rule[name=Sig/Linkage Subst]
{\goodSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{\cL (\sigma[\gamma]) \equiv (\cL \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Empty Sig]
{}
{\goodSig{\Gamma}{\nu\cdot}{0}}
\quad
\Rule[name=Sig Add]
{\goodSig{\Gamma}{\sigma}{n} 
 \quad \goodSeal{\Gamma}{f}{\sigma}{\sigma'}
 \quad \goodType{\Gamma, \sigma'}{T}{i}}
{\goodSig{\Gamma}{(\nu^+ \ \sigma \ \{f\} \ T)}{n+1}}
$$
$$
\Rule[name=Empty Lnkg]
{}
{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot}}
\quad
\Rule[name=Lnkg Add]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
\quad  \goodSeal{\Gamma}{f}{\sigma}{\sigma'} 
 \quad \goodTerm{\Gamma, \cL \sigma'}{t}{T}
}
{\goodTerm{\Gamma}{(\mu^+ \ o \ \{f\} \ t)}{\cL(\nu^+ \ \sigma \ \{f\} \ T)}}
$$

$\goodSig{\Gamma}{\sigma}{n}$ means $\sigma$ is a well-typed signature for linkages in the context $\Gamma$ with $n$ fields. We omit the naming/label information for fields in the meta-theory. We can use $\cL$ to retrieve the corresponding types of linkage of a given signature. Our signature corresponds to Coq's Module Type and our linkage corresponds to Coq's Module. 


The signature for linkage closely follows the signature for inductive type.  They are both constructed from the empty stuff, and respect substitution lemma for sure. We have projection for each componenet due to harmony \citep{pfenning2009lecture} (local soundness and completeness), but we omit them and the substitution laws for either concatenation and projection. For $\mu^+,\nu^+$ rules, we will omit $\{f\}$ if possible.


Intuitively, both of the $\mu^+, \nu^+$ rules should be motivated by that of dependent pairs, so an obvious question is why is that sealing judgement there? 

\judgebox{[\goodSeal{\Gamma}{s}{\sigma}{\sigma'}] = [\goodTerm{\Gamma, \cL\sigma}{s}{\cL \sigma'[\pi_1]}] }
$$
\Rule[name=Seal Subst]
{\goodSeal{\Delta}{s}{\sigma}{\sigma'}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSeal{\Gamma}{s[\gamma]}{\sigma[\gamma]}{\sigma'[\gamma]}}
=
\frac
{\goodTerm{\Delta, \cL\sigma}{s}{\cL\sigma'[\pi_1]}
  \quad  \goodSub{\Gamma}{\gamma}{\Delta}  }
{\goodTerm{\Gamma,\cL\sigma[\gamma]}{s[\gamma^\uparrow]}{\cL\sigma'[\pi_1][\gamma^\uparrow]\equiv\cL\sigma'[\gamma][\pi_1]}}
$$
$$
\Rule[name=Seal-Id]
{}
{\goodSeal{\Gamma}{id_s}{\sigma}{\sigma}}
= \goodTerm{\Gamma, \cL\sigma}{\pi_2}{\cL\sigma[\pi_1]}
$$
\begin{figure}[H]

\centering
\captionsetup{justification=centering}

\caption{Seal Judgement, and its Agda Representation \\ (or What do we mean when we say one judgement is a short hand of the other)}

\begin{minted}[]{agda}
Seal : (Œì : Con) ‚Üí (œÉ : Sig Œì n) ‚Üí (œÑ : Sig Œì n) ‚Üí Set 
Seal Œì œÉ œÑ = Tm (Œì, ùìõœÉ) ùìõœÑ[p‚ÇÅ]

-[-]S : (f : Seal Œì œÉ‚ÇÅ œÉ‚ÇÇ) ‚Üí (œÑ : Tms Œò Œì) ‚Üí Seal Œò œÉ‚ÇÅ[œÑ] œÉ‚ÇÇ[œÑ]
f[œÑ]S = t[œÑ ‚Üë ùìõœÉ‚ÇÅ]

id‚Çõ : Seal Œì œÉ œÉ
id‚Çõ = œÄ‚ÇÅ
\end{minted}

\end{figure}




As we said earlier, $\goodSeal{\Gamma}{\_}{\sigma}{\sigma'}$ is actually just a short hand of term judgement $\goodTerm{\Gamma , \cL \sigma}{\_}{\cL\tau[\pi_1]}$. The substitution law should understand as a lemma, and easily derivable by using $\gamma^\uparrow$. 

The motivation for sealing judgement is acting like a syntactic sugar helpful for inheritance. Consider the scenario we have constructed a linkage meant to be a recursor $  .. (T : \bW(\sigma)) \vdash L : \cL(\tau)$. Now we extend $\sigma$ with more constructors into $\sigma'$, but we don't have any rules to transfer $L$ to the context of $\bW(\sigma')$. Thus the correct way is to construct $L$ in an \textit{sealed} context, $  .. (T : \cU) \vdash L : \cL(\tau)$, and single out the \textit{recursor term}  $.. (T : \bW(\sigma)), L : \cL(\tau) \vdash \ \text{ Recursor } \ T \ L .. : R $ also functioning as \textit{coverage checking}. (Because we don't need to inherit coverage checking -- we should redo it in every linkage) Here, the recursor should also be \textit{seal-ed} so that every field is relying on an abstract, overridable recursor. Thus the sealing judgement will be helpful to shift the context from $.. (T : \bW(\sigma)) .. $ to $.. (T : \cU) ..$ 

However, in most of the cases, we don't need to seal anything, and thus the "Seal-Id" is used. For notation clearance, we will sometime use $sf'$ to emphasize that we consider that seal $s$ as a term $(sf' \ s)$. 




\judgebox{\goodInh{\Gamma}{h}{\sigma}{\tau}}

Finally we introduce the inheritance judgement. Inheritance is represented by judgement so naturally first order data (i.e. not something function can return), but it itself looks very much alike a function that transform a given linkage. 

