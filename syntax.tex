Firstly, there are four standard kinds of judgement in MLTT, well-typed context $\goodCtx{\Gamma}{l}$, well-typed type $\goodType{\Gamma}{T}{l}$, well-typed term $\goodTerm{\Gamma}{t}{T}$ and well-typed substitution $\goodSub{\Gamma}{\gamma}{\Delta}$. We are following \citep{kaposi2019gluing} but we will omit the universe level attached to the judgement here, to make it more readable. After these, we will have four new kinds of judgement. 

Because we consider each judgement as a (dependent) QIIT type, each judgement has a \textit{type} and each sequent is well-typed as well (otherwise how can they be encoded in Agda?)\YZ{What's the distinction of judgments vs. sequents?}.\EDJreply{I am not sure about the correct terminology here. Here I want to say "even underivable judgement has to be well-typed". That's the main reason I spell out the fake Agda code there. I actually want the reader to have intrinsic-typed syntax in mind all the time (like read conventional math but acknowledge we are manipulating Agda)}
Latex-wise, we spell out these \textit{well-formed-ness rule} of type judgements and their Agda counterpart to make things more understandable. Of course, a well-formed sequent  is not necessarily derivable. 
Due to our intrinsic setting, we can omit a lot of presumption, for example we don't spell out that the rule "Type-Universe" requires a well-typed context, even though it did implicitly -- because it is not possible to have "not-well-formed" context in our setting.

Among them, sealing judgement $\goodSeal{\Gamma}{\_}{\sigma}{\tau}$ is the most special one because it is actually just a short hand of term judgement $\goodTerm{\Gamma , \cL \sigma}{\_}{\cL\tau[\pi_1]}$. Even though we will introduce rules for sealing judgement, we will later show that all these rules are derivable by term judgements.

\begin{figure}[H]
  \begin{minipage}[b]{0.3\linewidth}
      $$
      \Rule[name=Tm]
      {\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{T}{j}}
      {\goodTerm{\Gamma}{\_}{T}}
      $$
      $$
      \Rule[name=Tms]
      {\goodCtx{\Gamma}{i} \quad \goodCtx{\Delta}{i}}
      {\goodSub{\Gamma}{\_}{\Delta} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Sig]
      {\goodCtx{\Gamma}{i} \quad n \in \nat}
      {\goodSig{\Gamma}{\_}{n} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Seal]
      {\goodCtx{\Gamma}{i} \quad \goodSig{\Gamma}{\sigma, \tau}{n}}
      {\goodSeal{\Gamma}{\_}{\sigma}{\tau} \text{ is well-formed}}
      $$
  \end{minipage}
  \begin{minipage}[b]{0.6\linewidth}
    \begin{minted}[]{agda}
      data Con   : Set 
      data Ty    : Con → Set   
      data Tms   : Con → Con → Set 
      data Tm    : (Γ : Con) → Ty Γ  → Set 
      data Sig  : Con → ℕ → Set
      data WSig : Con → ℕ → Set 
      data Inh  : (Γ : Con) → Sig Γ n → Sig Γ m → Set
      Seal : (Γ : Con) → Sig Γ n → Sig Γ n → Set
    \end{minted}
  \end{minipage}
  \caption{Well-formed-ness of Four New Judgements}
\end{figure}





Now we show case some of the typing rules, and demonstrate their typed encoding in our (fake) Agda, to help the reader  grasp the rough idea of our type system and understand the Agda-formulation of the typing rules easier.


  \label{fig:rules:well-typed-ctx}
\judgebox{\goodCtx{\Gamma}{i}}
$$ 
\Rule[name=Empty Context]{}{\goodCtx{\cdot}{0}} 
\quad
\Rule[name=Context Extension]
{\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{A}{j}}
{\goodCtx{\Gamma, A}{i \cup j}}  
$$


\judgebox{ \goodType{\Gamma}{T}{i} }
$$
\Rule[name=Type Universe]
{}
{\goodType{\Gamma}{\cU_j}{j + 1}}
\quad 
\Rule[name=Boolean]
{}
{\goodType{\Gamma}{\cB}{0}}
\quad 
\Rule[name=Bottom]
{}
{\goodType{\Gamma}{\bot}{0}}
\quad 
\Rule[name=Function]
{\goodType{\Gamma}{A}{j} 
  \quad \goodType{\Gamma, A}{B}{k}}
{\goodType{\Gamma}{\Pi A B}{j \cup k}}
$$

$$
\Rule[name=Type Subst]
{\goodType{\Delta}{T}{j} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{j}}
\quad 
\Rule[name=Func Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}\YZ{What is the requirement on Delta?}
\EDJreply{ Delta here is of type Con and thus Delta here should be a well-typed Context. This is another issue I want to talk about, in Agda these kinds of stuff is inferred (so the reader can infer them as well). For example, we know delta is at the place of context, so it is a context, but we don't need to specify that it is a ``well-typed context'' because every context is well-typed in this intrinsic-typing. What's more, I think adding this extra judgement here just cause significant code bloat (like what I complained to you before I know how to use implcit variable in agda. For example, TYPE SUBST, there will be two more judgements (with no more information there) ) (Another reason I prefer fake agda formulation) }
}
{\goodType{\Gamma}{(\Pi A B)[\gamma] \equiv \Pi A[\gamma] B[\gamma^\uparrow] }{j \cup k}}
$$
$$
\Rule[name=Base Type Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{\cU_j[\gamma] \equiv \cU_j }{j + 1} \quad
  \goodType{\Gamma}{\cB[\gamma] \equiv \cB}{0} \quad 
  \goodType{\Gamma}{\bot[\gamma] \equiv \bot}{0}
}
$$
\judgebox{ \goodTerm{\Gamma}{t}{T} }
$$
\Rule[name=Univ-1]
{\goodType{\Gamma}{T}{j}}
{\goodTerm{\Gamma}{c \ T}{\cU_j}
}\quad
\Rule[name=Univ-2]
{\goodTerm{\Gamma}{T}{\cU_j}}
{\goodType{\Gamma}{El \ T}{j}}
\quad
\Rule[name=True]
{}
{\goodTerm{\Gamma}{tt}{\cB}}
\quad
\Rule[name=False]
{}
{\goodTerm{\Gamma}{ff}{\cB}}
$$
$$
\Rule[name=Term Subst]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
\quad 
\Rule[name=Func intro]
{\goodTerm{\Gamma, A}{t}{B}}
{\goodTerm{\Gamma}{\lambda t}{\Pi A B}}
\quad 
\Rule[name=Lam Subst]
{}
{\goodTerm{\Gamma}{(\lambda t)[\gamma] \equiv \lambda (t[\gamma^\uparrow])}{\Pi A B}}
$$
$$
\Rule[name=Base Type/Term Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{(El \ T)[\gamma] \equiv El \ (T[\gamma]) }{j} \quad
 \goodTerm{\Gamma}{tt[\gamma] \equiv tt}{\cB} \quad 
 \goodTerm{\Gamma}{ff[\gamma] \equiv ff}{\cB} 
}
$$
\judgebox{\goodSub{\Gamma}{\sigma}{\Delta}}
$$
\Rule[name=Empty Subst]
{}{\goodSub{\Gamma}{\epsilon}{\cdot}}
\quad
\Rule[name=Id Subst]
{}{\goodSub{\Gamma}{id}{\Gamma}}
\quad
\Rule[name=Subst Extension]
{\goodSub{\Gamma}{\sigma}{\Delta} \quad \goodTerm{\Gamma}{t}{A[\sigma]}}
{\goodSub{\Gamma}{(\sigma, t)}{(\Delta, A)}}
$$

$$
\Rule[name=Proj Subst-1]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_1 \sigma}{\Delta}}
\quad
\Rule[name=Proj Subst-2]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_2 \sigma}{A[\pi_1 \sigma]}}
\quad
\Rule[name=Proj-Ext]
{}
{\goodSub{\Gamma}{(\pi_1 \sigma, \pi_2 \sigma) \equiv \sigma}{\Delta}}
$$

We have shown case some exemplar rules for all four standard type judgments, now we focus on the newly introduced facility. 


We have two kinds of signatures, one for extensible inductive type, the other for linkages.



\judgebox{\goodWSig{\Gamma}{\sigma}{n}}
$$
\Rule[name=Emp WSig]
{}
{\goodWSig{\Gamma}{w\cdot}{0}}
\quad
\Rule[name=WSig Add]
{\goodWSig{\Gamma}{s}{n}
  \quad \goodType{\Gamma}{A}{i}
  \quad \goodType{\Gamma, A}{B}{i}}
{\goodWSig{\Gamma}{w^+ \  s \  A \  B}{n+1}}
\quad
\Rule[name=Ind Univ]
{\goodWSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\bW \sigma}{i}\YZ{Is there an introduction rule for terms of type 'bW sigma'?}\EDJreply{Yes there is. I omit it because it is a singleton type, please see my newly added explanation at below.}}
$$

$$
\Rule[name=WSig Proj]
{\goodWSig{\Gamma}{s}{n} \quad j < n}
{\goodType{\Gamma}{\pi^j_1 s}{i} \quad \goodType{\Gamma, \pi^j_1 s}{\pi^j_2  s}{i}}
\quad
\Rule[name=Ind Sig]
{\goodWSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodWSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{W (\sigma[\gamma]) \equiv (W \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Ind Type]
{\goodTerm{\Gamma}{T}{\bW \sigma}}
{\goodTerm{\Gamma}{W \ T}{\cU}}
\quad
\Rule[name=Ind Term]
{\goodTerm{\Gamma}{T}{\bW \sigma}
  \quad \goodTerm{\Gamma}{a}{\pi^j_1\sigma}
  \quad \goodTerm{\Gamma, \pi^j_1\sigma}{b}{\pi^j_2\sigma}}
{\goodTerm{\Gamma}{Wsup \ T \ a \ b}{El\ (W\ T)} }
$$


Recall in W-type \citep{martin1982constructive}, a pair of type $x : A \vdash B(x)$ decides a W-type. For simplicity,  we use a list of pairs of such $A, B$ as the signature for a given inductive type. Doing so, all the constructors will have a fixed form \mintinline{agda}{cstrᵢ : (x : Aᵢ) → (Bᵢ x → W) → W}. Of course we need to put an eye on the substitution law for each piece of the syntax. Here $\bW \sigma$ is a large singleton type, and it only has one "element", the inductive type itself, inside. We formulate in this cumbersome way because we want to have inductive type to be a field element at the same time exposing the constructors for later \textit{pattern-matching coverage checking} (i.e. if an inductive type as field element has type $\cU$, then no information about the inductive type is exposed)\EDJ{Here}.

In our meta-theory, we only formulate non-dependent eliminator, i.e. the \textit{recursor}. Each recursor is constructed by a linkage contained with functions/handlers/pattern-matching cases dealing with each constructor. Thus code-reuse for recursor is delegated by the inheritance of linkage -- to reuse one particular pattern-matching case, we just inherit the function/handler. This greatly simplifies the metatheory development. 


\judgebox{\goodSig{\Gamma}{\sigma}{n} }
$$
\Rule[name=Linkage Type]
{\goodSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\cL \sigma}{i}}
\quad
\Rule[name=Sig/Linkage Subst]
{\goodSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{\cL (\sigma[\gamma]) \equiv (\cL \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Empty Sig]
{}
{\goodSig{\Gamma}{\nu\cdot}{0}}
\quad
\Rule[name=Sig Add]
{\goodSig{\Gamma}{\sigma}{n} 
 \quad \goodSeal{\Gamma}{f}{\sigma}{\sigma'}
 \quad \goodType{\Gamma, \sigma'}{T}{i}}
{\goodSig{\Gamma}{(\nu^+ \ \sigma \ \{f\} \ T)}{n+1}}
$$
$$
\Rule[name=Empty Lnkg]
{}
{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot}}
\quad
\Rule[name=Lnkg Add]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
\quad  \goodSeal{\Gamma}{f}{\sigma}{\sigma'} 
 \quad \goodTerm{\Gamma, \cL \sigma'}{t}{T}
}
{\goodTerm{\Gamma}{(\mu^+ \ o \ \{f\} \ t)}{\cL(\nu^+ \ \sigma \ \{f\} \ T)}}
$$

$\goodSig{\Gamma}{\sigma}{n}$ means $\sigma$ is a well-typed signature for linkages in the context $\Gamma$ with $n$ fields. We omit the naming/label information for fields in the meta-theory. We can use $\cL$ to retrieve the corresponding types of linkage of a given signature. Our signature corresponds to Coq's Module Type and our linkage corresponds to Coq's Module. 


The signature for linkage closely follows the signature for inductive type.  They are both constructed from the empty stuff, and respect substitution lemma for sure. We have projection for each componenet due to harmony \citep{pfenning2009lecture} (local soundness and completeness), but we omit them and the substitution laws for either concatenation and projection. For $\mu^+,\nu^+$ rules, we will omit $\{f\}$ if possible\footnote{Interestingly, this omission can be supported by Agda using }.


Intuitively, both of the $\mu^+, \nu^+$ rules should be motivated by that of dependent pairs, so an obvious question is why is that sealing judgement there?

\judgebox{[\goodSeal{\Gamma}{s}{\sigma}{\sigma'}] = [\goodTerm{\Gamma, \cL\sigma}{s}{\cL \sigma'[\pi_1]}] }
$$
\Rule[name=Seal Subst]
{\goodSeal{\Delta}{s}{\sigma}{\sigma'}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSeal{\Gamma}{s[\gamma]}{\sigma[\gamma]}{\sigma'[\gamma]}}
=
\frac
{\goodTerm{\Delta, \cL\sigma}{s}{\cL\sigma'[\pi_1]}
  \quad  \goodSub{\Gamma}{\gamma}{\Delta}  }
{\goodTerm{\Gamma,\cL\sigma[\gamma]}{s[\gamma^\uparrow]}{\cL\sigma'[\pi_1][\gamma^\uparrow]\equiv\cL\sigma'[\gamma][\pi_1]}}
$$
$$
\Rule[name=Seal-Id]
{}
{\goodSeal{\Gamma}{id_s}{\sigma}{\sigma}}
= \goodTerm{\Gamma, \cL\sigma}{\pi_2}{\cL\sigma[\pi_1]}
$$
\begin{figure}[H]

\centering
\captionsetup{justification=centering}

\caption{Seal Judgement, and its Agda Representation \\ (or What do we mean when we say one judgement is a short hand of the other)}

\begin{minted}[]{agda}
Seal : (Γ : Con) → (σ : Sig Γ n) → (τ : Sig Γ n) → Set 
Seal Γ σ τ = Tm (Γ, 𝓛σ) 𝓛τ[p₁]

-[-]S : (f : Seal Γ σ₁ σ₂) → (τ : Tms Θ Γ) → Seal Θ σ₁[τ] σ₂[τ]
f[τ]S = t[τ ↑ 𝓛σ₁]

idₛ : Seal Γ σ σ
idₛ = π₁
\end{minted}

\end{figure}




As we said earlier, $\goodSeal{\Gamma}{\_}{\sigma}{\sigma'}$ is actually just a short hand of term judgement $\goodTerm{\Gamma , \cL \sigma}{\_}{\cL\tau[\pi_1]}$. The substitution law should understand as a lemma, and easily derivable by using $\gamma^\uparrow$. 

The motivation for sealing judgement is acting like a syntactic sugar helpful for inheritance. Consider the scenario we have constructed a linkage meant to be a recursor $  .. (T : \bW(\sigma)) \vdash L : \cL(\tau)$. Now we extend $\sigma$ with more constructors into $\sigma'$, but we don't have any rules to transfer $L$ to the context of $\bW(\sigma')$. Thus the correct way is to construct $L$ in an \textit{sealed} context, $  .. (T : \cU) \vdash L : \cL(\tau)$, and single out the \textit{recursor term}  $.. (T : \bW(\sigma)), L : \cL(\tau) \vdash \ \text{ Recursor } \ T \ L .. : R $ also functioning as \textit{coverage checking}.
\YZ{Does coverage checking mean exhaustiveness checking?}
(Because we don't need to inherit coverage checking -- we should redo it in every linkage) Here, the recursor should also be \textit{seal-ed} so that every field is relying on an abstract, overridable recursor.
\YZ{I suppose the terminology 'sealing' is a reference to ML modules? In
ML, sealing has the connotation of hiding things behind an existential
type. So using the same word may cause the reader to have false
presumptions about what is going on here.}\EDJreply{You are right. Our "Sealing" is not hiding a particular field into an existential type, but our seal is make several fields together into an "existential type". Basically it hides the concrete definition of inductive type so that future fields doesn't have to be defined upon that.}
Thus the sealing judgement will be helpful to shift the context from $.. (T : \bW(\sigma)) .. $ to $.. (T : \cU) ..$
\YZ{Can we have a more concrete example of how the judgment is useful?}\EDJreply{}

However, in most of the cases, we don't need to seal anything, and thus the "Seal-Id" is used. For notation clearance, we will sometime use $sf'$ to emphasize that we consider that seal $s$ as a term $(sf' \ s)$. 


Note that, there will be a lot of $\sigma_1, \sigma_1'$ and $\sigma_2, \sigma_2'$, in these cases, $\sigma_1'$ is the result of the sealing of $\sigma_1$, i.e. we assume we have a term $\goodSeal{\Gamma}{f_1}{\sigma_1}{\sigma_1'}, \goodSeal{\Gamma}{f_2}{\sigma_2}{\sigma_2'}$ when needed.

\judgebox{\goodInh{\Gamma}{h}{\sigma}{\tau}}

$$
\Rule[name=Inh-Id]
{}
{\goodInh{\Gamma}{"inhid"}{\sigma}{\sigma}}
\quad
\Rule[name=Inh-Override]
{
\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}  
\quad \goodType{\Gamma, \cL\sigma_1'}{T_1}{}
\quad \goodType{\Gamma, \cL\sigma_2'}{T_2}{}
  \quad \goodTerm{\Gamma, \cL \sigma_2'}{t}{T_2}}
{\goodInh{\Gamma}{"inhov" \ h \ t}{(\nu^+ \  \sigma_1 \  T_1)}{(\nu^+ \  \sigma_2\  T_2)}}
$$

$$
\Rule[name=Inh-Ext]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma, \cL \sigma_2'}{t}{T}}
{\goodInh{\Gamma}{"inhext" \ h \ t}{\sigma_1}{(\nu^+ \  \sigma_2\  T)}}
\quad
\Rule[name=Inh-Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodType{\Gamma, \cL\sigma_1'}{T}{}
\quad \goodTerm{\Gamma, \cL\sigma_2'}{\uparrow^s}{\cL\sigma_1'[\pi_1]}
}
{\goodInh{\Gamma}{"inhinh" \ h}{(\nu^+ \  \sigma_1 \  T)}{(\nu^+ \  \sigma_2 \  T[(\pi_1, \uparrow^s)])}}
$$
$$
\Rule[name=Inh+Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma, \cL\sigma_2'}{\uparrow^s}{\cL\sigma_1'[\pi_1]}
\quad 
\goodInh{\Gamma, \cL\sigma_2'}{i}{\tau_1[(\pi_1, \uparrow^s)]}{\tau_2}}
{\goodInh{\Gamma}{"inhnest" \ h \ i}{(\nu^+ \  \sigma_1\  \cL\tau_1)}{(\nu^+ \  \sigma_2\  \cL\tau_2)}}
\quad
$$

$$
\Rule[name=Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma}{l}{\cL \sigma_1}
}
{\goodTerm{\Gamma}{("inh" \ h \ l)}{\cL \sigma_2}} 
\quad 
\Rule[name=Inh-Inh-beta]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma}{m}{\cL \sigma_1}
  \quad \goodTerm{\Gamma, \cL\sigma_1'}{t}{T}
}
{\goodTerm{\Gamma}{"inh" ("inhinh" \ h) (\mu^+ \ m \ t) \equiv \mu^+ \ ("inh" \ h \ m) \ t[(\pi_1, \uparrow^s)]}{}} 
$$

Finally we introduce the inheritance judgement. Inheritance are judgement so naturally second class citizen data (i.e. not something function can return and cannot be assigned to variables), and it looks very much alike a function that transform a given linkage. 

The syntax of the inheritance judgement is very close to how Family is defined in the surface syntax -- a Family with no parent is an inheritance with empty input; an extended Family is exactly an inheritance -- because the parent of an extended Family can be overridden thus inheritance should only define upon the ``interface'' instead of a concrete family. However, since our current formulation doesn't support further-binding (i.e. we cannot do inheritance inside a family), our formulation still have some distance to the real family polymorphism. 

"inhid" and "inhext" are simple as expected -- the former corresponds to empty inheritance, and the latter gives the programmer the ability to add new field. 

"inhinh" is special because it requires user to provide a proof of ``upcasting'' from the context of the children to that of the parent. In other words, if I want to inherit a specific field from the parent, I have to convince the type checker that my current context can ``accommodate'' the inherited field. 

Override "inhov" is even more special because in mundane OO programming language, we usually require that the overriding term has the same type/interface as the overriden one.  Here we don't since the very reason we want the same type/interface is that we hope other inherited fields can use this overridden/late-binding field without breaking abstraction, and this reason is already managed by the assumption of "inhinh", the upcasting proof $\uparrow^s$. Thus "inhov" is quite like "inhext", where overriding is just throwing away one parent field. This difference also show one of the distinct feature of our vanilla family inheritance compared to the mainstream OO inheritance -- family inheritance don't need to introduce the concept of ``subclassing'' between families and thus no bounded polymorphism yet\footnote{Of course once trait and interface comes in, we can have bounded polymorphism back}, and code reuse is mainly achieved by late binding. Without ``subclassing'', there is no way of confusing inheritance and subtyping.

Finally we need to introduce nested inheritance "inhnest" for dealing with nested families. The rule is mostly direct and we need "upcasting" again when dealing with nested family in different but inheriting context.  We also show how to use an inheritance judgement to derive children family and how the beta rule is defined. We omit most of the other substitution laws here.




