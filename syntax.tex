
\subsubsection{\textbf{Warm Up: Review Declarative MLTT}}

We highlight some specialities of declarative style in QIIT that differ from a
conventional setting: 
(1) This declarative formulation of type theory does not
have an operational semantics but only judgemental equality (e.g. $\beta$-reduction is now $\beta$-equality).\footnote{Later we will prove
canonicity which can imply a certain level of computational ability of
our theory} 
(2) We directly use the equality from QIIT to represent judgemental equality in our syntax, relieve from us the burden to explicit mentioning equivalence closure; however, this also mean that, \textit{every piece of the syntax data}, including all kinds of judgements (QIIT type) and their derivations will have equality information upon them  
%We will recover canonicity afterwards, which implies the computational ability of our theory. 
% (3) We are dealing with quotient data, so we are actually manipulating
% \textit{equivalence classes of terms} instead of one representative (term) from the equivalence class.
(3) Instead of using meta-level substitution, we use explicit
substitution and de Bruijn indices in our intrinsic formulation. This is
also called \textit{substitution calculus} in the literature and is favoured due
to its closedness to categorical semantic and easir to handle in mechanization. We will go through these details one-by-one.




\newcommand\mathboxtext[1]{
  \fcolorbox{black}{faint-gray}{\ensuremath{#1}}
}

\begin{figure}[!htb]
  \begin{align*}
    &\Gamma~:~"Con"&&\mathboxtext{\goodCtx{\Gamma}{}} &&T~:~"Ty"~\Gamma&&\mathboxtext{\goodType{\Gamma}{T}{}}  &&\gamma~:~"Tms"~\Gamma~\Delta&&\mathboxtext{\goodSub{\Gamma}{\gamma}{\Delta}}  && t~:~"Tm"~\Gamma~T&&\mathboxtext{\goodTerm{\Gamma}{t}{T}} 
  \end{align*}
\caption{Judgement forms, as Agda types and as presented in this section.}\label{fig:vanillaMLTTjudgeQIIT}
\end{figure}
\begin{figure}[!htb]
  \begin{minipage}[b]{0.3\linewidth}
      $$
      \Rule[name=Tm]
      {\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{T}{j}}
      {\goodTerm{\Gamma}{\_}{T}}
      $$
      $$
      \Rule[name=Tms]
      {\goodCtx{\Gamma}{i} \quad \goodCtx{\Delta}{i}}
      {\goodSub{\Gamma}{\_}{\Delta} \text{ is well-formed}}
      $$
  \end{minipage}
  \begin{minipage}[b]{0.6\linewidth}
    \begin{minted}[]{agda}
      data Con   : Set 
      data Ty    : Con → Set   
      data Tms   : Con → Con → Set 
      data Tm    : (Γ : Con) → Ty Γ  → Set 
    \end{minted}
  \end{minipage}

\caption{Well-formedness rules of the judgements}\label{fig:vanillaMLTTjudgewellformed}
\end{figure}
\underline{\textit{\textbf{Judgements and Universe.}}}
% Judgements in QIIT
We formalize our language as a deep embedding in a type theory using QIIT types. Every judgement is a (dependent) QIIT \textit{type} and all judgement derivations are well-typed QIIT terms. (Otherwise how can they be encoded in Agda?) There are four standard judgement forms from (vanilla) MLTT,
well-typed contexts $\goodCtx{\Gamma}{l}$, well-typed types
$\goodType{\Gamma}{T}{l}$, well-typed terms $\goodTerm{\Gamma}{t}{T}$, and
well-typed substitutions $\goodSub{\Gamma}{\gamma}{\Delta}$. The QIITs corresponding of these four judgements are
mutually recursively defined together, and declared in \cref{fig:vanillaMLTTjudgeQIIT}. Our presentation
follows the style of~\citet{kaposi2019gluing} and thus a predicative MLTT, but for readability we
omit the universe levels.
%\YZ{What's the distinction of judgments vs. sequents?}.\EDJreply{I am not sure about the correct terminology here. Here I want to say "even underivable judgement has to be well-typed". That's the main reason I spell out the (pseudo) Agda code there. I actually want the reader to have intrinsic-typed syntax in mind all the time (like read conventional math but acknowledge we are manipulating Agda)}\EDJreply{I rephrase that so there won't be confusion for the future readers. Please check}
Latex-wise, in \cref{fig:vanillaMLTTjudgewellformed}, we spell out these \textit{well-formedness rules} of type
judgements and their (pseudo-)Agda counterparts to make things more accessible. In (pseudo-)Agda, well-formedness rules are just well-typedness of (indexed) QIIT family---(the judgement)"Tm~$\Gamma$~$T$" is well-typed (well-formed) only when $\Gamma$ and $T$ are both well-typed (well-formed). We omitted a bunch for latex version. Of
course, a well-formed judgement is not necessarily derivable, just as
a well-formed QIIT type is not necessarily inhabited. 
These well-formedness rules are direct translations of the \textit{well-typedness} of QIIT. 

% omitting presupposition
Due to our intrinsic setting, \textbf{we can and will omit a lot of premises of the typing rules}~(the presuppositions). 
For example, we don't explicitly
spell out that the rule \ruleref{Boolean} (that is stating a boolean is a proper type) requires a well-formed
context, even though it does implicitly inferrable, \textbf{because it is not
possible to have ill-formed(ill-typed) contexts in our intrinsic setting}. This is
a bit unusual for conventional extrinsic setting where they will have
well-formedness of context everywhere in most of the term judgements. We
consider this as one advantage of using intrinsic setting---this
``well-formed context'' condition is usually attached to some other premises thus
inferrable and can be considered as ``boilerplate code''. Free of
such boilerplate code, the intrinsic setting provides a more concise
representation.


% How judgemental equality is used
Quotient is used to represent definitional equality (aka judgemental
equality) between QIIT types concisely.
This way, for all four kinds of judgements we are
using, there is always equality among these data but only those equalities between terms and types are emphasized due to their non-triviality.


% Example : how judgemental equality is used for the universe
We review the concept of ``universe'' and at the same time showing how equality is representing semantic. In dependent type setting, function now can return type, of which the type is ``type of type'', i.e., \textit{the universe} $\cU$. We follow the style of \textit{type universe à la Tarski}~\cite{hofmann1997syntax} and
distinguish types from their \textit{codes or names} as showin in \ruleref{Code/Get Type}: given a \textit{code} (term) $\goodTerm{\Gamma}{T}{\cU}$ we can retrieve the corresponding type
$\goodType{\Gamma}{El~T}{}$, and vice-versa.

In other words, (1) a universe $\cU$ is a type inhabited by the \textit{codes or names} of types.
(2) a code (term) $\goodTerm{\Gamma}{T}{\cU}$ cannot be used at type position
(i.e., at the rightmost position of a term judgement) but $El \ T$ can (i.e., we distinguish the code and the type).
(3) "c" is the ``inverse'' of $El$, obtaining  the \underline{"c"}ode of
a type. More concretely, using QIIT, the corresponding constructors will
look like, (notice that the type on both sides of the equalities are
always the same and thus a well-typed equality) 
\begin{align*}
  &\mintinline{Agda}{c : Ty Γ → Tm Γ U} &&\mintinline{Agda}{El : (a : Tm Γ U) → Ty } \\
  &\mintinline{Agda}{Elc : El (c T) ≡ T} && \mintinline{Agda}{cEl : c (El T) ≡ T}
\end{align*}
These two equations indicate how the \textit{dynamics} should react when
$El~"c"~T$ appears. Later we will see other similar $\beta$-equations
but we won't display their (pseudo-)Agda formulation.

Note that we are actually using predicative universe, so we actually
have different levels of universes $\cU_j$. However, we omit universe levels in our latex presentation for conciseness and readability.
% Most of the reasoning can be formulated using the \textit{algebra} of QIIT (mapping out function from this quotient data-type). 

\begin{figure}[!htb]
  \begin{alignat*}{3}
    \text{Context} \quad & \Gamma, \Delta &&= \cdot~|~ \Gamma, A \\ 
    \text{Types}   \quad & A, B, T        &&= \cU~|~\cB~|~\bot~|~\top~|~\Pi A B~|~\Sigma A B~|~El~t~|~T[\gamma]\\
    \text{Terms}   \quad & t, t_1, t_2    &&= "c"~T~|~t[\gamma]~|~\lambda t~|~"app"~t~|~(t_1,t_2)~|~"pjl"~t~|~"pjr"~t~|~"tt"~|~"ff"~|~\pi_2 \gamma  \\
    \text{Substitution}   \quad & \gamma, \gamma_1, \gamma_2    &&= \epsilon~|~"id"~|~\gamma_1 \circ \gamma_2~|~(\gamma, t)~|~\pi_1 \gamma \\
  \end{alignat*}
\caption[Caption for LOF]{Overview of Instrinsically-typed Syntax for vanilla MLTT\protect\footnotemark}
\end{figure}
\footnotetext{This is not the definition of our syntax, just a grand overview of the intrinsically-typed syntax, to expose the reader with an idea on, for example, whether a syntax piece is a term or type, the general impression of the expressiveness of the calculus}

\label{fig:rules:well-typed-ctx}
\judgebox{\goodCtx{\Gamma}{i}}
$$ 
\Rule[name=Empty Context]{}{\goodCtx{\cdot}{0}} 
\quad
\Rule[name=Context Extension]
{\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{A}{j}}
{\goodCtx{\Gamma, A}{i \cup j}}  
$$


\judgebox{ \goodType{\Gamma}{T}{i} }
$$
\Rule[name=Type Universe]
{}
{\goodType{\Gamma}{\cU}{j + 1}}
\quad 
\Rule[name=Boolean]
{}
{\goodType{\Gamma}{\cB}{0}}
\quad 
\Rule[name=Bottom]
{}
{\goodType{\Gamma}{\bot}{0}}
\quad 
\Rule[name=Function]
{\goodType{\Gamma}{A}{j} 
  \quad \goodType{\Gamma, A}{B}{k}}
{\goodType{\Gamma}{\Pi A B}{j \cup k}}
$$

$$
\quad 
\Rule[name=Func/DPair Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}
\quad \goodType{\Delta}{A}{} 
\quad \goodType{\Delta, A}{B}{}
}
{
  \goodType{\Gamma}{(\Pi A B)[\gamma] \equiv \Pi A[\gamma] B[\gamma^\uparrow] }{j \cup k}
  \quad 
  \goodType{\Gamma}{(\Sigma A B)[\gamma] \equiv \Sigma A[\gamma] B[\gamma^\uparrow] }{j \cup k}
}
$$
%\YZ{What is the requirement on Delta?}
%\EDJreply{ Delta here is of type Con and thus Delta here should be a well-typed Context. This is another issue I want to talk about, in Agda these kinds of stuff is inferred (so the reader can infer them as well). For example, we know delta is at the place of context, so it is a context, but we don't need to specify that it is a ``well-typed context'' because every context is well-typed in this intrinsic-typing. What's more, I think adding this extra judgement here just cause significant code bloat (like what I complained to you before I know how to use implcit variable in agda. For example, TYPE SUBST, there will be two more judgements (with no more information there) ) (Another reason I prefer (pseudo) agda formulation) }\YZreply{I was thinking about 'Delta |- A'. I suppose it is also implicitly enforced via intrinsically typed syntax. Seems to me it is worth stating, however, or otherwise the rule appears to say that Delta can be any context as long as Gamma |- gamma : Delta.}\EDJreply{You are absolutely right! I think Delta |- A, even though inferrable, mentioning it is good, also some information are B is also ok, please check, resolve if ok, thanks!}
$$
\Rule[name=Type Subst]
{\goodType{\Delta}{T}{j} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{j}}
\quad
\Rule[name=Base Type Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{\cU[\gamma] \equiv \cU }{j + 1} \quad
  \goodType{\Gamma}{\cB[\gamma] \equiv \cB}{0} \quad 
  \goodType{\Gamma}{\bot[\gamma] \equiv \bot}{0}
}
$$
\judgebox{ \goodTerm{\Gamma}{t}{T} }
$$
\Rule[name=Code/Get Type]
{\goodType{\Gamma}{T}{j}}
{\goodTerm{\Gamma}{"c" \ T}{\cU}
}\quad
\Rule[]
{\goodTerm{\Gamma}{T}{\cU}}
{\goodType{\Gamma}{El \ T}{j}}
\quad 
\Rule[name=Term Subst]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
$$
$$
\Rule[]
{\goodTerm{\Gamma, A}{t}{B}}
{\goodTerm{\Gamma}{\lambda t}{\Pi A B}}
\quad 
\Rule[]
{\goodTerm{\Gamma}{t}{\Pi A B}}
{\goodTerm{\Gamma, A}{"app"~t}{B}}
\quad 
\Rule[]
{\goodTerm{\Gamma}{u}{A} 
\quad \goodTerm{\Gamma}{v}{B[(id, u)]}}
{\goodTerm{\Gamma}{(u,v)}{\Sigma A B}}
\quad 
\Rule[]
{\goodTerm{\Gamma}{t}{\Sigma A B}}
{\goodTerm{\Gamma}{"pjl" \ t}{A}
\\\\ \goodTerm{\Gamma}{"pjr" \  t}{B[(id, "pjl" \  t)]}
}
$$
$$
\Rule
{}
{\goodTerm{\Gamma}{(\lambda t)[\gamma] \equiv \lambda (t[\gamma^\uparrow])}{\Pi A B}
\quad \goodTerm{\Gamma}{(u,v)[\gamma] \equiv (u[\gamma],v[\gamma])}{\Sigma A B}
\quad \goodType{\Gamma}{El \ (T[\gamma]) \equiv (El \ T) [\gamma]}{}
}
$$

$$
\Rule[name=Bool]
{}
{\goodTerm{\Gamma}{"tt", "ff"}{\cB}}
\quad
\Rule[]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{(El \ T)[\gamma] \equiv El \ (T[\gamma]) }{j} \quad
 \goodTerm{\Gamma}{"tt"[\gamma] \equiv "tt"}{\cB} \quad 
 \goodTerm{\Gamma}{"ff"[\gamma] \equiv "ff"}{\cB} 
}
$$
\judgebox{\goodSub{\Gamma}{\sigma}{\Delta}}
$$
\Rule[name=Ept Subst]
{}{\goodSub{\Gamma}{\epsilon}{\cdot}}
\quad
\Rule[]
{}{\goodSub{\Gamma}{"id"}{\Gamma}}
\quad
\Rule[name=Sub Comp]{
  \goodSub{\Delta}{\delta}{\Theta}
  \quad \goodSub{\Gamma}{\gamma}{\Delta} 
}{\goodSub{\Gamma}{\delta \circ \gamma}{\Theta}}
\Rule[name=Sub Extend]
{\goodSub{\Gamma}{\gamma}{\Delta} \quad \goodTerm{\Gamma}{t}{A[\gamma]}}
{\goodSub{\Gamma}{(\gamma, t)}{(\Delta, A)}}
$$

$$
\Rule[name=Proj Subst-1]
{\goodSub{\Gamma}{\gamma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_1 \gamma}{\Delta}}
\quad
\Rule[name=Proj Subst-2]
{\goodSub{\Gamma}{\gamma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_2 \gamma}{A[\pi_1 \gamma]}}
\quad
\Rule[name=Proj-Ext]
{}
{\goodSub{\Gamma}{(\pi_1 \gamma, \pi_2 \gamma) \equiv \gamma}{\Delta}}
$$

\underline{\textit{\textbf{Substitution Calculus.}}}
We first review the substitution calculus.
Substitution is very (if not the most) important because (dependent) functions are
first-class citizens, and lambdas can wrap all possible terms and once we apply the functions,  \textbf{the substitution will happen on the wrapped body and the substitution needs to
commute} with all type/term constructs in the function body. However, our substitution \textbf{is part of the syntax} instead of a meta-operation in conventional setting. We review the key to substitution calculus, mainly surrounding the judgements $\goodSub{\Gamma}{\gamma}{\Delta},\goodTerm{\Gamma}{t}{T},\goodType{\Gamma}{T}{}$.

A term $\goodTerm{\Gamma}{t}{A}$ can be understood as one term $t$ of
type $A$, with a bunch of holes (of type $\Gamma$) inside the term $t$.
A \textbf{simultaneous substitution} $\goodSub{\Gamma}{\gamma}{\Delta}$ can be similarly
understood in the way that $\gamma$ will output a \textbf{series} of
(dependently-typed related) terms of types $\Delta$, parametrized by
$\Gamma$ (i.e., we can consider there are holes of type $\Gamma$ in $\gamma$).
Thus (1) \ruleref{Sub Extend} looks like concatenating one
series of terms with a new term (the weird-looking type of
$\goodTerm{\Gamma}{t}{A[\gamma]}$ in the premise is due to our need of type $A$ in
the context $\Delta$ so that we can use \ruleref{Context Extension} to
create new context); (2) we have \ruleref{Proj Subst-1} to extract a
subpart of a given substitution; (3) \ruleref{Proj-Ext} explains why
substitution really looks like a (deeply-nested) pair. 

Since the $\Gamma$ before the $\vdash$ is always indicating the types of
``holes'', this explains rules \ruleref{Term Subst} and \ruleref{Type
Subst}: given a term $\goodTerm{\Delta}{t}{A}$ and a substitution
$\goodSub{\Gamma}{\gamma}{\Delta}$, we will have a new term
$\goodTerm{\Gamma}{t[\gamma]}{A[\gamma]}$ after the substitution---this
substitution can be understood as ``filling all the holes''. Once all
the holes are filled with a given substitution, the new holes all come
from the substitution itself.
Consecutive substitutions can be composed using \ruleref{Sub Comp}, because
all the holes are always from the last substitutions.

Note that, for simplicity, we will often write $\pi_1$ as a
shorthand for ${\pi_1~"id"}$, typed as
$\goodSub{\Gamma,A}{\pi_1~"id"}{\Gamma}$, and $\pi_2$ as a shorthand
for $\pi_2~"id"$, typed as $\goodTerm{\Gamma, A}{\pi_2~"id"}{A[\pi_1]}$.


\underline{\textit{\textbf{Original MLTT Constructs.}}}
We only include  the dependent function types, dependent pair types,
the boolean type (as a base type later for canonicity), the unit type,
the empty type, and the universe type from the original MLTT. Dependent
pair types are used to model Coq module, which is useful when we need to
later model the ``compilation'' from families to modules. We also have
$\beta$- and $\eta$-rules for both dependent function types and
dependent pair types. 

For these two types using binder, de Bruijn indices emphasizes its
difference from the conventional setting---we directly use $\lambda t$
as a function term where $t$ is the body, no binder indication is
required---to refer to variables in the context, we use $\pi_1,\pi_2$
from substitution calculus instead of using their names in the
conventional setting.  For example, the identity function $\lambda x. x$
is actually $\lambda(\pi_2 "id")$. $"app"~t$ is even more different than
that in the original setting---we don't require an application argument
now. The reason is, (1) we asked for argument in conventional setting so
we can use meta-level substitution as part of the dynamics, but here we
use explicit substitution. If the user wants to substitute some
arguments, they can just use $[\gamma]$ instead. (2) Formulated in this
way, "app" and $\lambda$ are symmetrical inverse to each other (just like
how $El$ and "c" are to each other). This makes the $\beta\eta$-rule
elegantly straightforward. Besides $\lambda$, $\Pi$ and $\Sigma$ are
also using binders and are formulated in a similar style.


Apparently, all of the type constructs have to commute with substitution somehow. The substitution law for dependent function and dependent pair
requires \textit{de Bruijn lifting}: for a given substitution
$\goodTerm{\Gamma}{\gamma}{\Delta}$ and a type
$\goodType{\Delta}{A}{}$, we define its de Bruijn lifting
$\goodTerm{\Gamma,A[\gamma]}{\gamma^\uparrow := (\gamma \circ \pi_1, \pi_2)}{\Delta, A}$ . Intuitively speaking, de Bruijn lifting is to ``fill all the holes except the last one''.

We also have identity type as part of our core syntax from the original MLTT. but we omit its presentations here---we follow~\citet{kaposi2019gluing} and use based path induction~\citet{program2013homotopy} as the elimination rule.  

\subsubsection{\textbf{Core Syntax of the Extended MLTT}}

\begin{figure}[!htb]
  \begin{alignat*}{3}
    \text{Inductive Type Signature}   \quad & \tau       &&= w\cdot~|~w^+~\tau~A~B~|~\tau[\gamma] \\
    \text{Linkage Signature}          \quad & \sigma       &&= \nu\cdot~|~\nu^+~\sigma~\{f\}~T~|~\sigma[\gamma]~|~p_1\nu~\sigma \\
    \text{Seal}          \quad & f       &&= t~|~p_f\nu~\sigma\\    
    \text{Types}   \quad & A, B, T        &&= ...~|~\bW \tau~|~\pi_1^j~|~\pi_2^j~|~\cL\sigma~|~\cC\sigma~|~p_1\nu'~\sigma~|~p_2\nu~\sigma\\
    \text{Terms}   \quad & t, t_1, t_2    &&= ...~|~"W"~T~|~"Wsup"~T~t_1~t_2~|~\mu\cdot~|~\mu^+~t~\{f\}~T~|~p_1\mu~t~|~p_2\mu~t~|~\cCt~t
  \end{alignat*}
\caption{Overview of Instrinsically-typed Syntax for extended MLTT}
\end{figure}
\begin{figure}[!htb]
  \begin{align*}
&\sigma~:~"Sig"~\Gamma~n&&\mathboxtext{\goodSig{\Gamma}{\sigma}{n}}  &&\tau~:~"WSig"~\Gamma~n&&\mathboxtext{\goodWSig{\Gamma}{\tau}{n}} \\ &h~:~"Inh"~\Gamma~\sigma_1~\sigma_2&&\mathboxtext{\goodInh{\Gamma}{h}{\sigma}{\tau}} && f~:~"Seal"~\Gamma~\sigma~T&&\mathboxtext{\goodSeal{\Gamma}{f}{\sigma}{A}}
  \end{align*}
\caption{Extended Judgement forms, as Agda types}
\end{figure}
\begin{figure}[!htb]
  \begin{minipage}[b]{0.3\linewidth}
      $$
      \Rule[name=Sig]
      {\goodCtx{\Gamma}{i} \quad n \in \nat}
      {\goodSig{\Gamma}{\_}{n} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Seal]
      {\goodCtx{\Gamma}{i} \quad \goodSig{\Gamma}{\sigma}{n} 
      \quad \goodType{\Gamma}{A}{} }
      {\goodSeal{\Gamma}{\_}{\sigma}{A} \text{ is well-formed}}
      $$\YZ{Doesn't the left column show well-formedness rules for ONLY TWO of the four new judgments? Besides, are these rules used anywhere in the following? Seems a bit unusual to have well-formedness rules for judgments per se.}\EDJreply{Yes. Right column show all the well-formedness rule for all the judgement. That is unusual because it is a direct translation from QIIT. }
  \end{minipage}
  \begin{minipage}[b]{0.6\linewidth}
    \begin{minted}[]{agda}
      data Sig  : Con → ℕ → Set
      data WSig : Con → ℕ → Set 
      data Inh  : (Γ : Con) → Sig Γ n → Sig Γ m → Set
      Seal : (Γ : Con) → Sig Γ n → Sig Γ n → Set
    \end{minted}
  \end{minipage}

\caption{Well-formedness rules of the extended judgements}
\end{figure}


The core language builds on MLTT and adds four new judgement forms.
% Among them, sealing judgement $\goodSeal{\Gamma}{\_}{\sigma}{A}$ is just a
% shorthand for term judgement
% $\goodTerm{\Gamma , \cC \sigma}{\_}{A[\pi_1]}$ where $A$ is a type.
% We have shown some exemplar rules for all four standard types of
% judgments. Now we focus on the newly introduced facility. 
We have two kinds of signatures, one for inductive types, the other for linkages. We start with inductive type signature.







% \begin{minted}[texcomments]{Coq}
%   Γ : Con  (* $\goodCtx{\Gamma}{}$ *) 
% \end{minted}
% T : Ty Γ (* $\goodType{\Gamma}{T}{}$ *)       σ : Tms Γ Δ {- $\goodSub{\Gamma}{\sigma}{\Delta}$ -}        t : Tm Γ T {- $\goodTerm{\Gamma}{t}{T}$ -}












\judgebox{\goodWSig{\Gamma}{\tau}{n}}
$$
\Rule[name=Emp-WSig]
{}
{\goodWSig{\Gamma}{w\cdot}{0}}
\quad
\Rule[name=WSig-Add]
{\goodWSig{\Gamma}{\tau}{n}
  \quad \goodType{\Gamma}{A}{i}
  \quad \goodType{\Gamma, A}{B}{i}}
{\goodWSig{\Gamma}{w^+ \  \tau \  A \  B}{n+1}}
\quad
\Rule[name=Ind-Univ]
{\goodWSig{\Gamma}{\tau}{n}}
{\goodType{\Gamma}{\bW \tau}{i}}
$$
%\YZ{Is there an introduction rule for terms of type 'bW sigma'?}
%\EDJreply{Yes there is. I omit it because it is a singleton type, please see my newly added explanation below.}

$$
\Rule[name=WSig-Proj]
{\goodWSig{\Gamma}{\tau}{n} \quad j < n}
{\goodType{\Gamma}{\pi^j_1 \tau}{i} \quad \goodType{\Gamma, \pi^j_1 \tau}{\pi^j_2  \tau}{i}}
\quad
\Rule[name=Ind-Sig]
{\goodWSig{\Delta}{\tau}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodWSig{\Gamma}{\tau[\gamma]}{n}
  \quad \goodType{\Gamma}{W (\tau[\gamma]) \equiv (W \tau)[\gamma]}{i}}
$$

$$
\Rule[name=Ind-Type]
{\goodTerm{\Gamma}{T}{\bW \tau}}
{\goodTerm{\Gamma}{"W" \ T}{\cU}}
\quad
\Rule[name=Ind-Term]
{\goodTerm{\Gamma}{T}{\bW \tau}
  \quad \goodTerm{\Gamma}{a}{\pi^j_1\tau}
  \quad \goodTerm{\Gamma, \pi^j_2\tau[(id, a)]}{b}{El~("W"~T)}}
{\goodTerm{\Gamma}{"Wsup"~T~a~b}{El~("W"~T)} }
$$

We base our formalization of inductive types on W-type~\cite{martin1982constructive}.
W-types, despite their simplicity, are able to construct a wide range of
inductive types in extensional setting~\cite{martin1984intuitionistic,dybjer1997representing,abbott2004representing}
and intensional setting (with the help of identity types~\cite{hugunin2021not}).
Recall with W-type, a pair of type $x : A \vdash B(x)$ decides a W-type.
To simulate extensible inductive types, we
have to equip our inductive types with multiple constructors, and for
simplicity, each constructor has a fixed form
\mintinline{agda}{cstrᵢ : (x : Aᵢ) → (Bᵢ x → W) → W}.
Thus, we use a `list' of pairs ($\goodWSig{\Gamma}{w^+~A_i~B_i~\tau}{}$) as the signature of one
inductive type. Given the signature $\tau$ of an inductive type, \ruleref{WSig-Proj}
extracts the corresponding $A_i, B_i$ via $\pi_1^i~\tau$ and $\pi_2^i~\tau$.

Of course, we need to put an eye on the substitution law for each piece
of the syntax. Here, $\bW \tau$ is a large singleton
type~\cite{stone2000}, and it only has one ``element''---the inductive
type itself, inside. We formulate in this cumbersome way because we want
to have inductive types as family members and expose the
constructors at the type level for later \textit{exhaustiveness checking}
(otherwise inductive types as family members would have type~$\cU$, and
no information about the inductive types could be exposed).
 

The formulation of our recursor is closely related to that of linkages,
so we will postpone their description.




\judgebox{\goodSig{\Gamma}{\sigma}{n} }
$$
\Rule[name=Lnkg Type/Compile]
{\goodSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\cL \sigma}{i}
\quad \goodType{\Gamma}{\cC \sigma}{}}
\quad
\Rule[name=Sig/Lnkg Subst]
{\goodSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{\cL (\sigma[\gamma]) \equiv (\cL \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Ept Sig]
{}
{\goodSig{\Gamma}{\nu\cdot}{0}}
\quad
\Rule[name=Sig Add]
{\goodSig{\Gamma}{\sigma}{n} 
 \quad \goodType{\Gamma}{A}{}
 \quad \goodSeal{\Gamma}{f}{\sigma}{A}
 \quad \goodType{\Gamma, A}{T}{i}}
{\goodSig{\Gamma}{(\nu^+ \ \sigma \ \{f\} \ T)}{n+1}}
$$

$$ 
\Rule[name=Sig Proj]
{\goodSig{\Gamma}{\sigma}{n+1}}
{\goodSig{\Gamma}{p_1\nu \ \sigma}{n}
\\ \goodType{\Gamma}{p_1\nu' \ \sigma}{}
\\ \goodSeal{\Gamma}{p_f\nu \  \sigma}{p_1\nu \  \sigma}{p_1\nu' \sigma}
\\ \goodType{\Gamma, p_1\nu' \ \sigma}{p_2\nu \ \sigma}{}
}
$$

$$ 
\Rule[name=Sig Proj Beta]
{\goodSig{\Gamma}{\sigma}{n} 
\quad \goodType{\Gamma}{A}{}
\quad \goodSeal{\Gamma}{f}{\sigma}{A}
\quad \goodType{\Gamma, A}{T}{i}}
{\goodSig{\Gamma}{p_1\nu \ (\nu^+ \ \sigma \ \{f\} \ T) \equiv \sigma}{n}
\\ \goodType{\Gamma}{p_1\nu' \ (\nu^+ \ \sigma \ \{f\} \ T) \equiv A}{}
\\ \goodSeal{\Gamma}{p_f\nu \  (\nu^+ \ \sigma \ \{f\} \ T) \equiv f}{\sigma}{A}
\\ \goodType{\Gamma, p_1\nu' \ \sigma}{p_2\nu \ (\nu^+ \ \sigma \ \{f\} \ T) \equiv T}{}
}
$$

$$
\Rule[name=Ept Lnkg]
{}
{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot}}
\quad
\Rule[name=Lnkg Add]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
\quad \goodType{\Gamma}{A}{}
\quad  \goodSeal{\Gamma}{f}{\sigma}{A} 
 \quad \goodTerm{\Gamma, A}{t}{T}
}
{\goodTerm{\Gamma}{(\mu^+ \ o \ \{f\} \ t)}{\cL(\nu^+ \ \sigma \ \{f\} \ T)}}
$$

$$
\Rule[name=Lnkg Proj]
{\goodTerm{\Gamma}{o}{\cL\sigma}}
{\goodTerm{\Gamma}{p_1\mu \ o}{\cL (p_1\nu \ \sigma)}
\\ \goodTerm{\Gamma, p_1\nu' \ \sigma}{p_2\mu \ o}{p_2\nu \ \sigma}
}
\quad 
\Rule[name=Lnkg Compile]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
}
{
  \goodTerm{\Gamma}{\cCt o}{\cC \sigma}
}
$$
$$ 
\Rule[name=Lnkg Proj Beta]
{\goodTerm{\Gamma}{o}{\cL \sigma} 
\quad \goodType{\Gamma}{A}{}
\quad  \goodSeal{\Gamma}{f}{\sigma}{A} 
 \quad \goodTerm{\Gamma, A}{t}{T}}
{\goodTerm{\Gamma}{p_1\mu \ (\mu^+ \ o \ \{f\} \ t) \equiv o}{\cL \sigma}
\\ \goodTerm{\Gamma, A}{p_2\mu \  (\mu^+ \ o \ \{f\} \ t) \equiv t}{T}
}
$$
$$
\Rule[name=Compile]
{}
{\goodType{\Gamma}{\cC \nu\cdot \equiv \top}{} 
\\
\goodType{\Gamma}{\cC (\nu^+ \ \sigma \ \{f\} \ T) \equiv 
    \Sigma (\cC \sigma) T["sf" \ f]}{}
\\\\ \goodTerm{\Gamma}{ \cCt \mu\cdot \equiv ()}{\cC \nu\cdot}
\\ \goodTerm{\Gamma}{\cCt \ (\mu^+ \ o \ \{f\}\ t) \equiv ((\cCt \ o), t["sf" \ f][(id, \cCt \ o)]) }{}\YZ{nothing after colon?}\EDJreply{There should be something but the space is not enough.}
}
$$
% $$
% \Rule
% { \goodSeal{\Gamma}{f}{\sigma}{A}
% \\ \goodType{\Gamma, A}{T}{}
% \\ \goodTerm{\Gamma}{t}{T}
% }{}
% $$

$\goodSig{\Gamma}{\sigma}{n}$ means $\sigma$ is a well-typed signature
for linkages in the context $\Gamma$ with $n$ fields. We omit the
naming/label information for fields in the meta\-theory. The signature (for the linkage) and the linkage rules are quite similar to
the signature for inductive types.  They are both constructed from the
empty stuff, and respect substitution lemmas. We have
\ruleref{Sig Proj}, \ruleref{Lnkg Proj} projection for each component.
We do have harmony~\cite{pfenning2009lecture} (i.e. local soundness
and local completeness, or $\beta,\eta$ rules). We omit them and the
substitution laws for either field addition and projection. For
$\mu^+,\nu^+$ rules, we will omit the sealing $\{f\}$ if possible.
% \footnote{This omission can be supported
%  by Agda using Implicit Arguments}

\textit{A side note}: before we dive in more details of our metatheory
for linkage (especially the meaning of sealing and $\cC$), we have to
mention that, the challenge of incorporating family polymorphism with
inductive type mentioned in \ref{chg:extensible-inductive-type} mutates
in metatheory because of de Bruijn indices. (Using named variables),
consider the example of a linkage $\{a~:~\bW \sigma;\ b_1 : a \to T;\
b_2 ..\}$ with a bunch of $b_i$ \textit{using} $a$. The tension we need
to solve here is between \textit{exhaustiveness checking} and
\textit{inheritance (code reuse)}---on one hand, if we want to make sure
$b_i$ is pattern matching correctly, then we have to construct $b_i$
term in the context of $a : \bW\sigma$; on the hand, if we want to let
$b_i$ to be inherited into a derived family with extended inductive type
$a~:~\bW \sigma'$, then the old inductive type $a~:~\bW \sigma$ in the
context of $b_i$ is stopping that and thus we hope $b_i$ constructed in
the context of $a : \cU$ (and thus later this $a$ can be compatible with
inductive type of any signature). Our metatheory formulation of linkage
is mainly trying to solve this tension.



We use $\cL$ to retrieve the type of some linkage of a given signature,
and $\cC$ to get the (existential) type of the compiled linkage.
$\cL\sigma$ corresponds to the type of a family term, but $\cC\sigma$,
according to \ruleref{Compile}, is a deeply nested dependent pair.
$\cCt \sigma$ provides the concrete module of type $\cC\sigma$ given a
linkage of type $\cL\sigma$. 

The reason we need this additional type construct of $\cC\sigma$ here is
to support \textit{code reuse}, as the rule of linkages hinders its
ability to do abstraction. Concretely speaking, (using named variables)
we cannot have $\goodTerm{\Gamma} %, \cL(\{a~:~\bW \sigma;~b~:~a \to T\})}
{h}{\cL(\{a~:~\cU;~b~:~a \to T\})}$. It would otherwise mean that any
subsequent field such as $b$ would be universally quantified under
$a\,:\,\cU$, leading to inconsistency.\footnote{%
Consider the case $T$ is bottom type and $\sigma$ is empty record and
thus $a$ is initially bottom type. Now the direct projection using
\ruleref{Sig Proj} $\goodTerm{\Gamma, a : \cU}{h.b}{a \to \bot}$ will
lead to problem because every field in linkage has this implicit
universal quantification, and for this case we can substitute $a$ with
arbitrary type, say $\top$: $\goodTerm{\Gamma}{h.b[a \mapsto \top]}{\top
\to \bot}$ is a contradiction}
However, this underivable term is important for us to abstract the
concrete inductive type so that a later field can depend on the
``abstract interface'' (i.e., something like $\cL(\{a:\cU~;~b:a \to T\})$)
and achieve \textit{code reuse}. 

The good news is that we don't have to use $\cL(\sigma)$ to
express the abstract interface. We can also use $\Sigma$-types, and actually
we do have $\goodTerm{\Gamma, (\Sigma a : \bW\sigma, a \to T)
}{h}{(\Sigma a : \cU, a \to T)}$ because of the rules for
$\Sigma$-types.\footnote{The intro rule for $\Sigma$-types decides that
there is no such implicit universal quantification happening.}
So to enable abstraction, we need $\cC\sigma$ to compile a
linkage to module as part of the context, and we also need
\ruleref{Lnkg Compile} to specify the compilation from linkage to
module.


This is also reflected in the implementation of our plugin: we know
every field is defined in the context of the former fields, and our
implementation makes every field depend on \textbf{the
compiled module of the already-defined-part of the family}. 
%\YZ{Why is Csigma needed? How is it different from Lsigma?}\EDJreply{It corresponds to the compilation of the family ``type'', which is part of the implementation detail. Basically we know every field of a family is dependent on the former fields. The implementation detail here is that, every field of a family is dependent on the compiled module of the former family (and thus includes all the former fields)}\YZreply{I don't think you should explain the metatheory from the angle of how things are implemented in your plugin. Rather, when describing your Coq plugin, you can say it matches the metatheory.
%PS: you use two terminologies: 'compile' and 'seal', but I guess they mean very similar things. So avoid saying 'compile' here.
%PPS: Sealing means hiding, so what is being hided? Why do you need to hide it? And how does the 'Compile' and 'Seal' rules perform hiding?}\EDJreply{  Compile is very different from seal.  Compile is making a linkage into a module, depriving the ability to override---if we understand a linkage as a module with a lot of universal quantifier inside. Compile cannot hide things, but only translate a linkage into a module. Seal is really something that does hiding---because existential type can hide stuff. Seal is an term between existential types. \\
%The ultimate reason we have this two notion is that, the introduction rule for linkage fails to provide abstraction mechanism so we have to translate them into module. \\
%Generally speaking Compile : Linkage -> Module, Seal : Module -> Module, we need module here because linkage cannot do abstraction of inductive type. A concrete detail is at the above. \\ 
%I now describe the motivation of compile in the earlier paragraph, right before the "reflecting" section. Note that, this compile is inspired by plugin implementation. This is the reason I say the metatheory is really close and inspired by the implementation. Similarly as I say ``there is no extensible inductive type but only overriding of new inductive type'' because in metatheory it is using overriding to ``extend'' (same as plugin implementation), seal means the same thing, and ``compile'' in metatheory happens in plugin implementation
%}

However, $\cC$ can only make sure we have $\cL(\{a~:~\bW \sigma; b~:~a
\to T\}) \to (\Sigma a:\bW \sigma, a \to T)$, we still need $(\Sigma
a:\bW \sigma, a \to T) \to (\Sigma a:\cU, a \to T)$ to complete
this shifting of the context. This is sealing's job.



\begin{figure}[H]

  \judgebox{[\goodSeal{\Gamma}{s}{\sigma}{A}] 
  = [\goodTerm{\Gamma, \cC\sigma}{s}{A[\pi_1]}] }
  $$
  \Rule[name=Seal Subst]
  {\goodSeal{\Delta}{s}{\sigma}{A}
    \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
  {\goodSeal{\Gamma}{s[\gamma]}{\sigma[\gamma]}{A[\gamma]}}
  =
  \frac
  {\goodTerm{\Delta, \cC\sigma}{s}{A[\pi_1]}
    \quad  \goodSub{\Gamma}{\gamma}{\Delta}  }
  {\goodTerm{\Gamma,\cC\sigma[\gamma]}{s[\gamma^\uparrow]}{A[\pi_1][\gamma^\uparrow]\equiv A[\gamma][\pi_1]}}
  $$
  $$
  \Rule[name=Seal-Id]
  {}
  {\goodSeal{\Gamma}{id_s}{\sigma}{\cC \sigma}}
  = \goodTerm{\Gamma, \cC\sigma}{\pi_2}{\cC\sigma[\pi_1]}
  $$

\medskip

\begin{minted}[escapeinside=@@]{agda}
Seal : (Γ : Con) → (σ : Sig Γ n) → (A : Ty Γ) → Set 
Seal Γ σ A = Tm (Γ, @$\mathcal{C}$@σ) A[π₁]

-[-]S : (f : Seal Γ σ A) → (τ : Tms Θ Γ) → Seal Θ σ[τ] A[τ]
f[τ]S = t[@$\tau^\uparrow$@]

idₛ : Seal Γ σ @$\mathcal{C}$@σ
idₛ = π₁
\end{minted}

\caption{Seal Judgement, and its Agda Representation (or What do we mean when we say one judgement is a shorthand for the other)}

\end{figure}


As we said earlier, $\goodSeal{\Gamma}{\_}{\sigma}{A}$ is actually just
a shorthand for term judgement $\goodTerm{\Gamma , \cC
\sigma}{\_}{A[\pi_1]}$,
a special form of \textit{local morphism}~\cite{abbott2003category}.
The substitution law should be understood as a lemma, and it is easily
derivable using $\gamma^\uparrow$. 

For notation clarity, we will sometimes use $sf'$ to emphasize that we
consider that the seal $\goodSeal{\Gamma}{s}{\sigma}{A}$ as a term
$\goodTerm{\Gamma, \cC \sigma}{sf'~s}{A[\pi_1]}$.\YZ{sf' seems unnecessary, since sf' s ad s are the same?}\EDJreply{Yes. Technically it is pretty unnecessary. It is just a bit weird to have $\goodTerm{\Gamma, \cC \sigma}{s}{A[\pi_1]}$ and $\goodSeal{\Gamma}{s}{\sigma}{A}$ at the same time because it is one derivation but turns out to be two judgements, for intrinsically typed. I can also remove ``sf'' if you don't find it weird. I initially having ``sf'' to just *emphasize* ``sf s'' should be considered as a term  and ``s'' a sealing}\YZreply{
  I'm still confused about the difference among s, sf s and sf' s.
  I thought s and sf' s were technically the same; they are both terms of type A[pi1] in a context that contains cC sigma.
  I thought sf s was different because it is a substitution.
}\EDJreply{You are absolutely right. s and sf' s are techincally the same. sf s is a substitution.
  About s and sf' s, I can say that, I don't allow something like $\goodSeal{\Gamma}{sf'~s}{\sigma}{A}$. The reason I don't allow it is only notational consideration. 
  I mean technically we can consider them the same. I can just remove all the appearances of sf' if you want and find it less confusing.
}\YZreply{Yes, sf' is confusing to me.}
Notation "sf"
(used in \ruleref{Compile}) is defined as the substitution $\goodSub{\Gamma,
\cC \sigma}{(sf~s) := (\pi_1, sf'~s)}{\Gamma, A}$.

Sealing judgement is still about the important term $h$ we mentioned
earlier. Thanks to $\cC$, a field $t_{new}$ that depends on $a$ is now
in the context containing $\cC\{a : \bW \sigma; ..\}$.
But if we want $t_{new}$ to be inherited(reused) when $\sigma$ is
extended, we would like $t_{new}$ to be in the context containing
$\cC\{a : \cU; ..\}$ instead. The sealing is responsible for this
because we have a sealing $\goodTerm{\Gamma, \cC\{a : \bW \sigma;
..\}}{s}{\cC\{a : \cU; ..\}}$ = $\goodTerm{\Gamma, (\Sigma a : \bW
\sigma,..)}{s}{(\Sigma a : \cU,..)}$. Then we can construct
$t_{new}$ in the context containing $(\Sigma a : \cU,..)$, ready for
inheritance. Thus sealing itself can be considered as proving 
abstractions on $\Sigma$-types.

%\YZ{It occurs to me that you use the word "sealing" to mean
%different (though tangentially related) things. Previously you used it
%as in "sealed families".}\EDJreply{They are actually the same thing.
%This sealing in metatheory is much stronger than that of the implemented
%plugin. Downside of the strong sealing is that if the user really use
%this version of sealing, the user will have to annotate what the sealed
%family type is. Now in the plugin, the sealed family type is almost
%fixed (directly inferred using a fixed rules). So basically this
%complete version of sealing (in metatheory) can deduce that of seal (in
%plugin implementation)}


% For example, $ X_1 : \bW
% \sigma_1 \vdash t : T$ in the parent family will generally not be able
% to be inherited to the children once we override the inductive type $\bW
% \sigma_1$ with $\bW \sigma_2$. 
% In
% other words, there is no way to ``transplant'' $t$ into the context $X_2
% : \bW \sigma_2$.
% This makes all the fields after this inductive type
% non-inheritable---which shouldn't be the case because a lot of fields
% might not be directly relying on this concrete $\bW \sigma_1$. 

% Sealing is used to exploit this fact---with sealing, given $X_1 : \bW
% \sigma_1$, we can add well-typed terms $X_1 : \cU \vdash t : T$, into
% the parent family. Later when we want to inherit $t$,
% because $t$ only consider $X_1$ as an arbitrary type, inheritance is
% possible. 

Now, together with sealing, we can read \ruleref{Sig Add} and
\ruleref{Lnkg Add} out clearly: given a constructed linkage $o : \cL\sigma$
of signature $\sigma$, the next added field $t : T$ will have
to be in the context of the abstraction $A$\YZ{Why do Lnkg Add and Sig Add leave A unspecified? I thought this A corresponds to 'self'.}\EDJreply{It is not unspecified. I now change it so that it is more clear. It is parametric as well. Just note that when specifying the abstraction `A', the seal `f' has to be specified at the sametime. (Thus I omitted it initially because it is implicitly specified w.r.t. the speicifcation of `f') }\YZreply{
  Changed what? I think Lnkg Add and Sig Add were not changed.
  I still don't see how sealing converts \cC \{a : \bW sigma ; ..\} to \cC\{a : \cU ; ..\}
  and how the latter is now used as the abstracted A.
}\EDJreply{I added the $\goodType{\Gamma}{A}{}$  as you suggested. \\
\cC \{a : \bW sigma ; ..\} is definitionally equal to a sigma type as Compile rule suggested. \\
If you expand the definition, you will see two sigma type. 
You are asking where is the function \cC \{a : \bW sigma ; ..\} to \cC\{a : \cU ; ..\}, which by definition is requesting (Sigma (a : \bW sigma ; ..)) to (Sigma (a : \cU ; ..)). \\
This is something doable in vanilla MLTT, with the help of transforming \bW sigma to \cU, by rule `Ind-Type'. }
of the compilation $\cC\sigma$ (witnessed by the seal $f$).
The ``concatenation'' of the
$o$ and $t$ leads to a new linkage, of which the signature is the
``concatenation'' of the $\sigma$ and $T$ (we also record the sealing
$f$ for simplicity). The key here is our signature, will \textit{record}
this abstraction witness $f$,\YZ{Why is it necessary to record the witness f? I don't see how p_f nu is needed anywhere.}\EDJreply{1. this is for the sake of eta/beta rule (local soundness + local completeness); 2.It is actually used in the rule Compile (the last one), if Ct is compile a variable, say ``Ct v'', then this ``Ct v = (Ct p_1 v), (t[sf p_f v][...])'', the f will actually be replaced by p_f; 3. p_f can be used by the user. It doesn't have to interact with other typing rules. }
thus any projected member will still be in
the abstracted context and thus possibly \textit{inheritable}.  The
construction of linkage in \ruleref{Lnkg Add} requires $t$ to
\textbf{only} refer to the (abstraction $A$ of) former part of the
defining family $o : \cL\sigma$, this is to avoid inconsistency
mentioned in \ref{chg:consistency} in metatheory.

This sealing is the general version of the sealed family implemented in
the plugin. Our plugin will deduce a sealed ``interface'' (which is the "A" in \ruleref{Sig Add})
for a sealed family using a fixed set of rules, but here sealing in
metatheory can be arbitrary local morphism  $\goodTerm{\Gamma , \cC
\sigma}{\_}{A[\pi_1]}$.
With the definition of sealing judgement in mind, we can see
\ruleref{Sig Add} and \ruleref{Lnkg Add} work exactly as the
implementation. In the implementation, we will have "self__" all around
when defining new fields in our plugin, and this "self__" is exactly the
$A$ in the context of the two fields---in our implementation, sealing
happens only to inductive types (where each inductive type we only know
\mintinline{Coq}{T : Set}).

In summary, with the help of both sealing and $\cC$, we can shift the context from $\cL(\{a~:~\bW \sigma; ..\})$ to $\Sigma a : \cU,..$ and thus achieve code reuse. However, this is just allow \textit{possible} {code reuse}, we still need to solve the mutated tension in \ref{chg:extensible-inductive-type}. To make things concrete, we need to introduce the rules for recursors.

% Since our recursor handlers are closely related to linkages, we can finally talk about the rules of recursor now. 

$$
\Rule[name=Hdler]
{\goodType{\Gamma}{A}{}
\quad \goodType{\Gamma, A}{B}{}
\quad \goodType{\Gamma}{R}{}
}
{\goodType{\Gamma}{"RecSig1"~A~B~R \equiv (\Pi A (\Pi (\Pi B (R[\pi_1\circ\pi_1])) R[\pi_1\circ\pi_1]) )}{}}
\quad 
\Rule[name=Hdlers]
{\goodWSig{\Gamma}{\sigma}{n}
\quad \goodType{\Gamma}{R}{}
}
{\goodSig{\Gamma}{"RecSig"~\sigma~R}{n}}
$$
$$
\Rule[name=Hdler-Proj]
{ \goodWSig{\Gamma}{\sigma}{N}
\quad \goodTerm{\Gamma}{o}{\cL("RecSig"~\sigma~R)}
\quad n < N
}
{\goodTerm{\Gamma}{"prjR"~n~o}{("RecSig1"~(\pi_1^n \sigma)~(\pi_2^n \sigma)~R)[\pi_1]}}
$$
$$
\Rule[name=Rec-Constr]
{ \goodWSig{\Gamma}{\sigma}{N}
\quad \goodTerm{\Gamma}{T}{\bW \sigma}
\quad \goodType{\Gamma}{R}{}
\quad \goodTerm{\Gamma}{r}{\cL("RecSig"~\sigma~R)}
\quad \goodTerm{\Gamma}{w}{El~("W"~T)}
}
{\goodTerm{\Gamma}{"Wrec"~r~w}{R}}\YZ{
(1) Use \tau for inductive types and \sigma for linkage signatures.
(2) Try using the same metavariables (j and n) as in the rules on W-types.
(3) In Rec-Constr, no checking of \Gamma \vdash T : \bW \tau?
(4) Why are RecSig1, RecSig, Wrec, prjR not listed in the syntax figure?
}\EDJreply{Thx. Working on it. I seem to forgot to add inheritance as well.}
$$

In our metatheory, for simplicity we only formulate non-dependent eliminators, i.e.,
\textit{recursors}.
%\YZ{Do dependent eliminators pose technical difficulties, or do you avoid them solely because they require more verbiage?}\EDJreply{I don't think there is technical difficulties to do that. The formulation of course will be much more horrifying if use dependent eliminator here. } 
Like our plugin implementation, each recursor is constructed by a
linkage containing handlers dealing with each constructor, and code
reuse for recursor is delegated to linkage inheritance.
This greatly simplifies the metatheory development.

Intuitively \ruleref{Hdler} is indicating the type of recursor handler
for one specific constructor, and \ruleref{Hdlers} is the linkage type
of the bundle of all recursor handlers of one given inductive type. We
omit the definition of "RecSig" but \ruleref{Hdler-Proj} indicates its
(apparent) internal definition. "prjR" is also the handler selection
from the handler linkage, and is helpful for the formulation of
$\beta$-rule of "Wrec" (omitted here). Finally \ruleref{Rec-Constr} is
used to construct a concrete recursor given a specific linkage of aggregated
handlers. All these rules satisfy substitution laws, which are omitted here.
Thus, we are still using \textit{decoupling} of the syntax of the case
handlers and exhaustiveness checking to resolve
\ref{chg:extensible-inductive-type}. 

Then any field using "Wsup" and "Wrec", directly relying on the
$\bW\sigma$ in the context (can be spotted from \ruleref{Ind-Term} and
\ruleref{Rec-Constr}), and responsible for exhaustiveness checking will be non-inheritable---in these cases, "Wsup"
can be understood as concrete constructors and "Wrec" are
\textit{exhaustiveness checking}. These fields together with inductive
types are the ones sealing is responsible for hiding. After compilation
of linkage types into existential types, we can easily hide the
\textit{concrete} definition of the inductive type while exposing all
the fields using "Wsup" and "Wrec" like an abstract interface.
Apparently, future fields relying on this abstract interface will have no
problem on inheritance. 
For example, $t_{new}$ above cannot be doing \textit{exhaustiveness
checking}, but it can freely use any \textit{exhaustiveness-checked}
recursor, and also inheritable.
Of course, since "Wsup" and "Wrec" directly rely on the concrete inductive definition, we will have to override these fields whenever inductive type is overridden. For "Wsup" we only need to override each constructor and for "Wrec" it is just doing exhaustiveness checking inside each children family. The recursor handlers however, like plugin implementation, can be safely inherited.
\YZ{I suppose the terminology 'sealing' is a reference to ML modules? In
ML, sealing has the connotation of hiding things behind an existential
type. So using the same word may cause the reader to have false
presumptions about what is going on here.}\EDJreply{You are right. Our "Sealing" is not hiding a particular field into an existential type, but our seal is make several fields together into an "existential type". Basically it hides the concrete definition of inductive type so that future fields doesn't have to be defined upon that.}\EDJreply{I will resolve this comment once I add the throughout example and you find it clear---because I haven't changed any text}

There are also cases we don't need to seal anything (i.e., for doing
exhaustiveness checking when using recursor), and thus \ruleref{Seal-Id} is
used. 





Next we talk about inheritance judgement. Note that, there will be a lot of $\sigma_1, A_1$ and $\sigma_2, A_2$, and in these cases, $A_1$ is the result of the sealing of $\sigma_1$, i.e. we assume we have a term $\goodSeal{\Gamma}{f_1}{\sigma_1}{A_1}$, $\goodSeal{\Gamma}{f_2}{\sigma_2}{A_2}$ in the premises of judgements when needed.


\judgebox{\goodInh{\Gamma}{h}{\sigma}{\tau}}

$$
\Rule[name=Inh-Id]
{}
{\goodInh{\Gamma}{"inhid"}{\sigma}{\sigma}}
\quad
\Rule[name=Inh-Override]
{
\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}  
\quad \goodType{\Gamma, A_1}{T_1}{}
\quad \goodType{\Gamma, A_2}{T_2}{}
  \quad \goodTerm{\Gamma, A_2}{t}{T_2}}
{\goodInh{\Gamma}{"inhov" \ h \ t}{(\nu^+ \  \sigma_1 \  T_1)}{(\nu^+ \  \sigma_2\  T_2)}}
$$

$$
\Rule[name=Inh-Ext]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma, A_2}{t}{T}}
{\goodInh{\Gamma}{"inhext" \ h \ t}{\sigma_1}{(\nu^+ \  \sigma_2\  T)}}
\quad
\Rule[name=Inh-Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodType{\Gamma, A_1}{T}{}
\quad \goodTerm{\Gamma, A_2}{\uparrow^s}{A_1[\pi_1]}
}
{\goodInh{\Gamma}{"inhinh" \ h}{(\nu^+ \  \sigma_1 \  T)}{(\nu^+ \  \sigma_2 \  T[(\pi_1, \uparrow^s)])}}
$$
$$
\Rule[name=Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma}{l}{\cL \sigma_1}
}
{\goodTerm{\Gamma}{("inh" \ h \ l)}{\cL \sigma_2}} 
\quad
\Rule[name=Inh+Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma, A_2}{\uparrow^s}{A_1[\pi_1]}
\\\\
\goodInh{\Gamma, A_2}{i}{\tau_1[(\pi_1, \uparrow^s)]}{\tau_2}}
{\goodInh{\Gamma}{"inhnest" \ h \ i}{(\nu^+ \  \sigma_1\  \cL\tau_1)}{(\nu^+ \  \sigma_2\  \cL\tau_2)}}
\quad
$$

$$
\Rule[name=Inh-Inh-beta]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma}{m}{\cL \sigma_1}
  \quad \goodTerm{\Gamma, A_1}{t}{T}
  \quad \goodTerm{\Gamma, A_2}{\uparrow^s}{A_1[\pi_1]}
}
{\goodTerm{\Gamma}{"inh" ("inhinh" \ h) (\mu^+ \ m \  \{f_1\} \ t) \newline  \equiv \mu^+ \ ("inh" \ h \ m) \  \{f_2\} \ t[(\pi_1, \uparrow^s)]}{...}} 
$$

Inheritance are
judgement so naturally second class citizen data (i.e. not something
function can return and cannot be assigned to variables), and it looks
very much like a function that transform a given linkage. Similar to plugin implementation and \ruleref{Lnkg Add}, we resolve \ref{chg:consistency} by making sure corresponding fields are in corresponding context during inheritance, and thus an overriding term can only refer to fields before the overriden field. 

The syntax of the inheritance judgement is very close to how Family is
defined in the surface syntax---a Family with no parent is an
inheritance with empty input; an extended Family can be considered as an
inheritance.
% ---because the parent of an extended Family can be overridden
% thus inheritance should only define upon the ``interface'' instead of a
% concrete family. However, since our current formulation doesn't support
% nested inheritance (i.e. we cannot do inheritance inside a family but only top level), our
% formulation still has some distance to the real family polymorphism. 

"inhid" and "inhext" are simple as expected---the former corresponds to
empty inheritance, and the latter gives the programmer the ability to
add new fields.

"inhinh" is special because it requires user to provide a proof of
``upcasting'' from the context of the child to that of the parent.
In other words, if I want to inherit a specific field from the parent, I
have to convince the type checker that my current context can
``accommodate'' the inherited field. 

Override "inhov" is even more special because in mundane OO programming language, we usually require that the overriding term has the same type/interface as the overriden one.  Here we don't since the very reason we want the same type/interface is that we hope other inherited fields can use this overridden/late-binding field without breaking abstraction, and this reason is already managed by the premises of "inhinh", the upcasting proof $\uparrow^s$. Thus "inhov" is quite like "inhext", where overriding is just throwing away one parent field. This difference also show one of the distinct feature of our vanilla family inheritance compared to the mainstream OO inheritance---family inheritance don't need to introduce the concept of ``subclassing'' between families and thus no bounded polymorphism yet\footnote{Of course once trait and interface comes in, we can have bounded polymorphism back}, and code reuse is mainly achieved by late binding. Without ``subclassing'', there is no way of confusing inheritance and subtyping. Note that, "inhov" is also responsible for ``extending'' inductive type---the extended inductive type directly override the old ones when using metatheory to program, just like how plugin implementation works.

Next, we introduce nested inheritance "inhnest" for dealing with nested families. The rule is mostly direct and we need ``upcasting'' again when dealing with nested family in different but inheriting context.  We also show how to use an inheritance judgement to derive children family and how the beta rule is defined. We omit most of the other substitution laws here.

Finally, we show \ruleref{Inh-Inh-beta} to again emphasize the importance of sealing and its interaction with inheritance. $\goodTerm{\Gamma, A_1}{t}{T}$ is again well-typed in the new abstract context $\goodCtx{\Gamma, A_2}{}$, with the help of upcasting $\uparrow^s$ which is showing compatibility between abstraction. To make sure we have the full information of $t$ including the context $\Gamma, A_1$, we need to have a good sealing $\goodSeal{\Gamma}{f_1}{\sigma_1}{A_1}$.



\subsection{Exemplar Usage of Meta Theory}
\input{syntactic-example.tex}