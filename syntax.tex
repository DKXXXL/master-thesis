Firstly, there are four standard judgement forms in MLTT,
well-typed contexts $\goodCtx{\Gamma}{l}$, well-typed types
$\goodType{\Gamma}{T}{l}$, well-typed terms $\goodTerm{\Gamma}{t}{T}$, and
well-typed substitutions $\goodSub{\Gamma}{\gamma}{\Delta}$. Our presentation
follows the style of~\citet{kaposi2019gluing}, but for readability we
omit universe levels attached to judgements.
After these,
we will have four new kinds of judgement to model our linkage.

Because we formalize our language as a deep embedding in a type theory with QIIT types, every judgement is a (dependent) QIIT \textit{type} and all judgement derivations are well-typed QIIT terms (otherwise how can they be encoded in Agda?)
%\YZ{What's the distinction of judgments vs. sequents?}.\EDJreply{I am not sure about the correct terminology here. Here I want to say "even underivable judgement has to be well-typed". That's the main reason I spell out the fake Agda code there. I actually want the reader to have intrinsic-typed syntax in mind all the time (like read conventional math but acknowledge we are manipulating Agda)}\EDJreply{I rephrase that so there won't be confusion for the future readers. Please check}
Latex-wise, we spell out these \textit{well-formedness rule} of type
judgements and their Agda counterpart to make things more accessible. Of
course, a well-formed judgement is not necessarily derivable, just like
a well-typed QIIT type is not necessarily inhabited.

Due to our intrinsic setting, \textbf{we can and will omit a lot of presumptions of the typing rules}, for example we don't spell out that the rule "Type Universe" requires a well-typed context, even though it did implicitly---because it is not possible to have "not-well-formed" context in our setting.

Among them, sealing judgement $\goodSeal{\Gamma}{\_}{\sigma}{A}$ is the most special one because it is actually just a short hand of term judgement $\goodTerm{\Gamma , \cL \sigma}{\_}{A[\pi_1]}$. 



\newcommand\mathboxtext[1]{
  \fcolorbox{black}{faint-gray}{\ensuremath{#1}}
}

\begin{figure}[!htb]
  \begin{align*}
    &\Gamma~:~"Con"&&\mathboxtext{\goodCtx{\Gamma}{}} &&T~:~"Ty"~\Gamma&&\mathboxtext{\goodType{\Gamma}{T}{}}  &&\sigma~:~"Tms"~\Gamma~\Delta&&\mathboxtext{\goodSub{\Gamma}{\sigma}{\Delta}}  \\ & t~:~"Tm"~\Gamma~T&&\mathboxtext{\goodTerm{\Gamma}{t}{T}} 
    &&\sigma~:~"Sig"~\Gamma~n&&\mathboxtext{\goodSig{\Gamma}{\sigma}{n}}  &&\sigma~:~"WSig"~\Gamma~n&&\mathboxtext{\goodWSig{\Gamma}{\sigma}{n}} \\ &h~:~"Inh"~\Gamma~\sigma~\tau&&\mathboxtext{\goodInh{\Gamma}{h}{\sigma}{\tau}} && f~:~"Seal"~\Gamma~\sigma~A&&\mathboxtext{\goodSeal{\Gamma}{f}{\sigma}{A}}
  \end{align*}
\caption{Judgements and their Agda Encoding}
\end{figure}

\begin{figure}[!htb]
  \begin{minipage}[b]{0.3\linewidth}
      $$
      \Rule[name=Tm]
      {\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{T}{j}}
      {\goodTerm{\Gamma}{\_}{T}}
      $$
      $$
      \Rule[name=Tms]
      {\goodCtx{\Gamma}{i} \quad \goodCtx{\Delta}{i}}
      {\goodSub{\Gamma}{\_}{\Delta} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Sig]
      {\goodCtx{\Gamma}{i} \quad n \in \nat}
      {\goodSig{\Gamma}{\_}{n} \text{ is well-formed}}
      $$
      $$
      \Rule[name=Seal]
      {\goodCtx{\Gamma}{i} \quad \goodSig{\Gamma}{\sigma}{n} 
      \quad \goodType{\Gamma}{A}{} }
      {\goodSeal{\Gamma}{\_}{\sigma}{A} \text{ is well-formed}}
      $$
  \end{minipage}
  \begin{minipage}[b]{0.6\linewidth}
    \begin{minted}[]{agda}
      data Con   : Set 
      data Ty    : Con → Set   
      data Tms   : Con → Con → Set 
      data Tm    : (Γ : Con) → Ty Γ  → Set 
      data Sig  : Con → ℕ → Set
      data WSig : Con → ℕ → Set 
      data Inh  : (Γ : Con) → Sig Γ n → Sig Γ m → Set
      Seal : (Γ : Con) → Sig Γ n → Sig Γ n → Set
    \end{minted}
  \end{minipage}

\caption{Well-formedness of Four New Judgements}
\end{figure}





% \begin{minted}[texcomments]{Coq}
%   Γ : Con  (* $\goodCtx{\Gamma}{}$ *) 
% \end{minted}
% T : Ty Γ (* $\goodType{\Gamma}{T}{}$ *)       σ : Tms Γ Δ {- $\goodSub{\Gamma}{\sigma}{\Delta}$ -}        t : Tm Γ T {- $\goodTerm{\Gamma}{t}{T}$ -}





Now we show selected typing rules: we will have dependent function types
and dependent pair types. Dependent pair type is used to model Coq
module, which is useful when we need to model the ``compilation'' from
linkages to modules. We also have $\beta,\eta$-rule for both dependent
function type and dependent pair type. The subsitution law for these two require \textit{de bruijn lifting}: for $\goodTerm{\Gamma}{\sigma}{\Delta}$, we define its de bruijn lifting $\goodTerm{\Gamma,A[\sigma]}{\sigma^\uparrow}{\Delta, A}$ given $\goodType{\Delta}{A}{}$.

  \label{fig:rules:well-typed-ctx}
\judgebox{\goodCtx{\Gamma}{i}}
$$ 
\Rule[name=Empty Context]{}{\goodCtx{\cdot}{0}} 
\quad
\Rule[name=Context Extension]
{\goodCtx{\Gamma}{i} \quad \goodType{\Gamma}{A}{j}}
{\goodCtx{\Gamma, A}{i \cup j}}  
$$


\judgebox{ \goodType{\Gamma}{T}{i} }
$$
\Rule[name=Type Universe]
{}
{\goodType{\Gamma}{\cU_j}{j + 1}}
\quad 
\Rule[name=Boolean]
{}
{\goodType{\Gamma}{\cB}{0}}
\quad 
\Rule[name=Bottom]
{}
{\goodType{\Gamma}{\bot}{0}}
\quad 
\Rule[name=Function]
{\goodType{\Gamma}{A}{j} 
  \quad \goodType{\Gamma, A}{B}{k}}
{\goodType{\Gamma}{\Pi A B}{j \cup k}}
$$

$$
\quad 
\Rule[name=Func/DPair Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}
\quad \goodType{\Delta}{A}{} 
\quad \goodType{\Delta, A}{B}{}
}
{
  \goodType{\Gamma}{(\Pi A B)[\gamma] \equiv \Pi A[\gamma] B[\gamma^\uparrow] }{j \cup k}
  \quad 
  \goodType{\Gamma}{(\Sigma A B)[\gamma] \equiv \Sigma A[\gamma] B[\gamma^\uparrow] }{j \cup k}
}
$$
%\YZ{What is the requirement on Delta?}
%\EDJreply{ Delta here is of type Con and thus Delta here should be a well-typed Context. This is another issue I want to talk about, in Agda these kinds of stuff is inferred (so the reader can infer them as well). For example, we know delta is at the place of context, so it is a context, but we don't need to specify that it is a ``well-typed context'' because every context is well-typed in this intrinsic-typing. What's more, I think adding this extra judgement here just cause significant code bloat (like what I complained to you before I know how to use implcit variable in agda. For example, TYPE SUBST, there will be two more judgements (with no more information there) ) (Another reason I prefer fake agda formulation) }\YZreply{I was thinking about 'Delta |- A'. I suppose it is also implicitly enforced via intrinsically typed syntax. Seems to me it is worth stating, however, or otherwise the rule appears to say that Delta can be any context as long as Gamma |- gamma : Delta.}\EDJreply{You are absolutely right! I think Delta |- A, even though inferrable, mentioning it is good, also some information are B is also ok, please check, resolve if ok, thanks!}
$$
\Rule[name=Type Subst]
{\goodType{\Delta}{T}{j} 
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodType{\Gamma}{T[\gamma]}{j}}
\quad
\Rule[name=Base Type Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{\cU_j[\gamma] \equiv \cU_j }{j + 1} \quad
  \goodType{\Gamma}{\cB[\gamma] \equiv \cB}{0} \quad 
  \goodType{\Gamma}{\bot[\gamma] \equiv \bot}{0}
}
$$
\judgebox{ \goodTerm{\Gamma}{t}{T} }
$$
\Rule[name=Univ-1]
{\goodType{\Gamma}{T}{j}}
{\goodTerm{\Gamma}{"c" \ T}{\cU_j}
}\quad
\Rule[name=Univ-2]
{\goodTerm{\Gamma}{T}{\cU_j}}
{\goodType{\Gamma}{El \ T}{j}}
\quad
\Rule
{}
{\goodTerm{\Gamma}{"tt", "ff"}{\cB}}
\quad 
\Rule[name=Term Subst]
{\goodTerm{\Delta}{t}{T}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodTerm{\Gamma}{t[\gamma]}{T[\gamma]}}
$$
$$
\Rule[]
{\goodTerm{\Gamma, A}{t}{B}}
{\goodTerm{\Gamma}{\lambda t}{\Pi A B}}
\quad 
\Rule[]
{\goodTerm{\Gamma}{u}{A} 
\quad \goodTerm{\Gamma}{v}{B[(id, u)]}}
{\goodTerm{\Gamma}{(u,v)}{\Sigma A B}}
\quad 
\Rule[]
{\goodTerm{\Gamma}{t}{\Sigma A B}}
{\goodTerm{\Gamma}{"pjl" \ t}{A}
\quad \goodTerm{\Gamma}{"pjr" \  t}{B[(id, "pjl" \  t)]}
}
$$
$$
\Rule
{}
{\goodTerm{\Gamma}{(\lambda t)[\gamma] \equiv \lambda (t[\gamma^\uparrow])}{\Pi A B}
\quad \goodTerm{\Gamma}{(u,v)[\gamma] \equiv (u[\gamma],v[\gamma])}{\Sigma A B}
\quad \goodType{\Gamma}{El \ (T[\gamma]) \equiv (El \ T) [\gamma]}{}
}
$$

$$
\Rule[name=Base Type/Term Subst]
{\goodSub{\Gamma}{\gamma}{\Delta}}
{\goodType{\Gamma}{(El \ T)[\gamma] \equiv El \ (T[\gamma]) }{j} \quad
 \goodTerm{\Gamma}{"tt"[\gamma] \equiv "tt"}{\cB} \quad 
 \goodTerm{\Gamma}{"ff"[\gamma] \equiv "ff"}{\cB} 
}
$$
\judgebox{\goodSub{\Gamma}{\sigma}{\Delta}}
$$
\Rule[name=Empty Subst]
{}{\goodSub{\Gamma}{\epsilon}{\cdot}}
\quad
\Rule[name=Id Subst]
{}{\goodSub{\Gamma}{"id"}{\Gamma}}
\quad
\Rule[name=Subst Extension]
{\goodSub{\Gamma}{\sigma}{\Delta} \quad \goodTerm{\Gamma}{t}{A[\sigma]}}
{\goodSub{\Gamma}{(\sigma, t)}{(\Delta, A)}}
$$

$$
\Rule[name=Proj Subst-1]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_1 \sigma}{\Delta}}
\quad
\Rule[name=Proj Subst-2]
{\goodSub{\Gamma}{\sigma}{(\Delta, A)}}
{\goodSub{\Gamma}{\pi_2 \sigma}{A[\pi_1 \sigma]}}
\quad
\Rule[name=Proj-Ext]
{}
{\goodSub{\Gamma}{(\pi_1 \sigma, \pi_2 \sigma) \equiv \sigma}{\Delta}}
$$

We have shown case some exemplar rules for all four standard type
judgments, and now we focus on the newly introduced facility. 


We have two kinds of signatures, one for inductive type, the other for linkages.



\judgebox{\goodWSig{\Gamma}{\sigma}{n}}
$$
\Rule[name=Emp-WSig]
{}
{\goodWSig{\Gamma}{w\cdot}{0}}
\quad
\Rule[name=WSig-Add]
{\goodWSig{\Gamma}{s}{n}
  \quad \goodType{\Gamma}{A}{i}
  \quad \goodType{\Gamma, A}{B}{i}}
{\goodWSig{\Gamma}{w^+ \  s \  A \  B}{n+1}}
\quad
\Rule[name=Ind-Univ]
{\goodWSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\bW \sigma}{i}}
$$
%\YZ{Is there an introduction rule for terms of type 'bW sigma'?}
%\EDJreply{Yes there is. I omit it because it is a singleton type, please see my newly added explanation below.}

$$
\Rule[name=WSig-Proj]
{\goodWSig{\Gamma}{s}{n} \quad j < n}
{\goodType{\Gamma}{\pi^j_1 s}{i} \quad \goodType{\Gamma, \pi^j_1 s}{\pi^j_2  s}{i}}
\quad
\Rule[name=Ind-Sig]
{\goodWSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodWSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{W (\sigma[\gamma]) \equiv (W \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Ind-Type]
{\goodTerm{\Gamma}{T}{\bW \sigma}}
{\goodTerm{\Gamma}{"W" \ T}{\cU}}
\quad
\Rule[name=Ind-Term]
{\goodTerm{\Gamma}{T}{\bW \sigma}
  \quad \goodTerm{\Gamma}{a}{\pi^j_1\sigma}
  \quad \goodTerm{\Gamma, \pi^j_2\sigma[(id, a)]}{b}{El~("W"~T)}}
{\goodTerm{\Gamma}{"Wsup" \ T \ a \ b}{El~("W"~T)} }
$$


Recall in W-type~\cite{martin1982constructive}, a pair of type $x : A \vdash B(x)$ decides a W-type. To simulate extensible inductive type, we have to equip our inductive type with multiple constructors, and for simplicity, each constructor has a fixed form \mintinline{agda}{cstrᵢ : (x : Aᵢ) → (Bᵢ x → W) → W}. Thus we use a list of pairs of such $A_i, B_i$ as the signature for one inductive type, and given an inductive type signature, we use \ruleref{WSig-Proj} to extract and corresponding $A_i, B_i$.

Of course we need to put an eye on the substitution law for each piece of the syntax. Here $\bW \sigma$ is a large singleton type~\cite{stone2000}, and it only has one ``element'', the inductive type itself, inside. We formulate in this cumbersome way because we want to have inductive type to be a field element and exposing the constructors at the type level for later \textit{pattern-matching coverage checking} (i.e. if an inductive type as field element has type $\cU$, then no information about the inductive type is exposed).\YZ{What is the distinction of 'W T' vs 'El (W T)'?}\EDJreply{(W T) is a term inside the type universe, El (W T) is really a type. They are basically the same thing but (W T) cannot be at the type position in a judgement, i.e. k |- q : (W T) is not allowed, we only have k |- q : El (W T). This is kind of standard notation (at least in both Sterling and Kaposi) so I will avoid explaining in the main text if you think ok?}\YZreply{I think explanation is warranted; readers unfamiliar with that line of work may find it confusing. BTW, is the elimination rule for "El (W T)" omitted?}\EDJreply{Please check the following paragraph for the explanation for El, and also Univ-1 is the elimination rule for "El T" in general. I just didn't write out the two equations c (El T) = T, El (c T) = T}. We follow the style of \textit{type universe à la Tarski} and distinguish types from their \textit{codes or names}, and thus we use $El\ T$ as the type given type name $T : \cU$---in these cases, $T$ is not allowed to locate at type position (i.e. at the right-most position of a term judgement) but $El \ T$ is.  

The formulation of our recursor is closely related to the linkage, so we will postpone their description. 




\judgebox{\goodSig{\Gamma}{\sigma}{n} }
$$
\Rule[name=Lnkg Type/Compile]
{\goodSig{\Gamma}{\sigma}{n}}
{\goodType{\Gamma}{\cL \sigma}{i}
\quad \goodType{\Gamma}{\cC \sigma}{}}
\quad
\Rule[name=Sig/Lnkg Subst]
{\goodSig{\Delta}{\sigma}{n}
  \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
{\goodSig{\Gamma}{\sigma[\gamma]}{n}
  \quad \goodType{\Gamma}{\cL (\sigma[\gamma]) \equiv (\cL \sigma)[\gamma]}{i}}
$$

$$
\Rule[name=Ept Sig]
{}
{\goodSig{\Gamma}{\nu\cdot}{0}}
\quad
\Rule[name=Sig Add]
{\goodSig{\Gamma}{\sigma}{n} 
 \quad \goodSeal{\Gamma}{f}{\sigma}{A}
 \quad \goodType{\Gamma, A}{T}{i}}
{\goodSig{\Gamma}{(\nu^+ \ \sigma \ \{f\} \ T)}{n+1}}
$$

$$ 
\Rule[name=Sig Proj]
{\goodSig{\Gamma}{\sigma}{n+1}}
{\goodSig{\Gamma}{p_1\nu \ \sigma}{n}
\\ \goodType{\Gamma}{p_1\nu' \ \sigma}{}
\\ \goodSeal{\Gamma}{p_f\nu \  \sigma}{p_1\nu \  \sigma}{p_1\nu' \sigma}
\\ \goodType{\Gamma, p_1\nu' \ \sigma}{p_2\nu \ \sigma}{}
}
$$

$$
\Rule[name=Ept Lnkg]
{}
{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot}}
\quad
\Rule[name=Lnkg Add]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
\quad  \goodSeal{\Gamma}{f}{\sigma}{A} 
 \quad \goodTerm{\Gamma, A}{t}{T}
}
{\goodTerm{\Gamma}{(\mu^+ \ o \ \{f\} \ t)}{\cL(\nu^+ \ \sigma \ \{f\} \ T)}}
$$

$$
\Rule[name=Lnkg Proj]
{\goodTerm{\Gamma}{o}{\cL\sigma}}
{\goodTerm{\Gamma}{p_1\mu \ o}{\cL (p_1\nu \ \sigma)}
\\ \goodTerm{\Gamma, p_1\nu' \ \sigma}{p_2\mu \ o}{p_2\nu \ \sigma}
}
\quad 
\Rule[name=Lnkg Compile]
{ \goodTerm{\Gamma}{o}{\cL \sigma} 
}
{
  \goodTerm{\Gamma}{\cCt o}{\cC \sigma}
}
$$

$$
\Rule[name=Compile]
{}
{\goodType{\Gamma}{\cC \nu\cdot \equiv \top}{} 
\\ \goodTerm{\Gamma}{ \cCt \mu\cdot \equiv ()}{\cL \nu\cdot}
\\
\goodType{\Gamma}{\cC (\nu^+ \ \sigma \ \{f\} \ T) \equiv 
    \Sigma (\cC \sigma) T["sf" \ f]}{}
\\\\ \goodTerm{\Gamma}{\cCt \ (\mu^+ \ o \ \{f\}\ t) \equiv ((\cCt \ o), t["sf" \ f][(id, \cCt \ o)]) }{}
}
$$
% $$
% \Rule
% { \goodSeal{\Gamma}{f}{\sigma}{A}
% \\ \goodType{\Gamma, A}{T}{}
% \\ \goodTerm{\Gamma}{t}{T}
% }{}
% $$

$\goodSig{\Gamma}{\sigma}{n}$ means $\sigma$ is a well-typed signature for linkages in the context $\Gamma$ with $n$ fields. We omit the naming/label information for fields in the meta-theory. We can use $\cL$ to retrieve the corresponding types of linkage of a given signature, and $\cC$ to get the compiled linkage type (an existential type). 


The signature (for the linkage) and the linkage rules are quite similar the signature for inductive type.  They are both constructed from the empty stuff, and respect substitution lemma for sure. We have \ruleref{Sig Proj}, \ruleref{Lnkg Proj} projection for each componenet due to harmony~\cite{pfenning2009lecture} thus we have local soundness and local completeness ($\beta,\eta$ rules). We omit them and the substitution laws for either field addition and projection. For $\mu^+,\nu^+$ rules, we will omit $\{f\}$ if possible.\footnote{This omission can be supported by Agda using Implicit Arguments}


Since our recursor handlers are closely related to linkages, we can finally talk about the rules of recursor now. 

$$
\Rule[name=Hdler]
{\goodType{\Gamma}{A}{}
\quad \goodType{\Gamma, A}{B}{}
\quad \goodType{\Gamma}{R}{}
}
{\goodType{\Gamma}{"RecSig1"~A~B~R \equiv (\Pi A (\Pi (\Pi B (R[\pi_1\circ\pi_1])) R[\pi_1\circ\pi_1]) )}{}}
\quad 
\Rule[name=Hdlers]
{\goodWSig{\Gamma}{\sigma}{n}
\quad \goodType{\Gamma}{R}{}
}
{\goodSig{\Gamma}{"RecSig"~\sigma~R}{}}
$$
$$
\Rule[name=Hdler-Proj]
{ \goodWSig{\Gamma}{\sigma}{N}
\quad \goodTerm{\Gamma}{o}{\cL("RecSig"~\sigma~R)}
\quad n < N
}
{\goodTerm{\Gamma}{"prjR"~n~o}{("RecSig1"~(\pi_1^n \sigma)~(\pi_2^n \sigma)~R)[\pi_1]}}
$$
$$
\Rule[name=Rec-Constr]
{ \goodWSig{\Gamma}{\sigma}{N}
\quad \goodType{\Gamma}{T}{\bW \sigma}
\quad \goodType{\Gamma}{R}{}
\quad \goodTerm{\Gamma}{r}{\cL("RecSig"~\sigma~R)}
\quad \goodTerm{\Gamma}{w}{El~("W"~T)}
}
{\goodTerm{\Gamma}{"Wrec"~r~w}{R}}
$$

In our meta-theory, we only formulate non-dependent eliminator, i.e. the
\textit{recursor}. Each recursor is constructed by a linkage containing
functions/handlers/pattern-matching cases dealing with each
constructor. Thus code reuse for recursor is delegated to linkage
inheritance----to reuse one particular pattern-matching case,
we just inherit the function/handler. This greatly simplifies the
metatheory development. 

Intuitively \ruleref{Hdler} is indicating the type of recursor handler for one specific constructor, and \ruleref{Hdlers} is the linkage type of the bundle of all recursor handlers of one given inductive type. We omit the definition of "RecSig" but \ruleref{Hdler-Proj} indicates its (apparent) internal definition. "prjR" is also the handler selection from the handler linkage, and is helpful for the formulation of $\beta$-rule of "Wrec" (omitted here). Finally \ruleref{Rec-Constr} is the used to construct a concrete recursor given a specific linkage of handlers. All these rules satisfy substitution laws and omitted here.


Now, one missing piece for linkage is the sealing judgement, and both of the $\mu^+, \nu^+$ rules relies on that---then what is this sealing judgement for?


\begin{figure}[H]

  \judgebox{[\goodSeal{\Gamma}{s}{\sigma}{A}] 
  = [\goodTerm{\Gamma, \cC\sigma}{s}{A[\pi_1]}] }
  $$
  \Rule[name=Seal Subst]
  {\goodSeal{\Delta}{s}{\sigma}{A}
    \quad {\goodSub{\Gamma}{\gamma}{\Delta}}}
  {\goodSeal{\Gamma}{s[\gamma]}{\sigma[\gamma]}{A[\gamma]}}
  =
  \frac
  {\goodTerm{\Delta, \cC\sigma}{s}{A[\pi_1]}
    \quad  \goodSub{\Gamma}{\gamma}{\Delta}  }
  {\goodTerm{\Gamma,\cC\sigma[\gamma]}{s[\gamma^\uparrow]}{A[\pi_1][\gamma^\uparrow]\equiv A[\gamma][\pi_1]}}
  $$
  $$
  \Rule[name=Seal-Id]
  {}
  {\goodSeal{\Gamma}{id_s}{\sigma}{\cC \sigma}}
  = \goodTerm{\Gamma, \cC\sigma}{\pi_2}{\cC\sigma[\pi_1]}
  $$

\centering
\captionsetup{justification=centering}

\caption{Seal Judgement, and its Agda Representation \\ (or What do we mean when we say one judgement is a short hand of the other)}

\begin{minted}[]{agda}
Seal : (Γ : Con) → (σ : Sig Γ n) → (A : Ty Γ) → Set 
Seal Γ A τ = Tm (Γ, 𝓛σ) A[p₁]

-[-]S : (f : Seal Γ σ A) → (τ : Tms Θ Γ) → Seal Θ σ[τ] A[τ]
f[τ]S = t[τ ↑ A]

idₛ : Seal Γ σ 𝓒σ
idₛ = π₁
\end{minted}

\end{figure}




As we said earlier, $\goodSeal{\Gamma}{\_}{\sigma}{A}$ is actually just
a short hand of term judgement $\goodTerm{\Gamma , \cC
\sigma}{\_}{A[\pi_1]}$, a special form of \textit{local morphism}~\cite{abbott2003category}. The substitution law should be understood as a
lemma, and it is easily derivable using $\gamma^\uparrow$. 

The motivation for sealing judgement is acting like a syntactic sugar helpful for inheritance---due to the presence of inductive type in the context, not everything is inheritable. For example, $ X_1 : \bW \sigma_1 \vdash t : T$ in the parent family will generally not be able to be inherited to the children once we override the inductive type. In other words, there is no way ``transplanting'' $t$ into the context $X_2 : \bW \sigma_2$. This makes all the fields after this inductive type non-inheritable---which shouldn't be the case because a lot of fields might not be directly relying on this concrete $\bW \sigma_1$. 

Sealing is used to exploit this fact---with sealing, we can add well-typed terms $X_1 : \cU \vdash t : T$, into the parent family, in the context of $ X_1 : \bW \sigma_1$. Later when we want to inherit $t$, because $t$ only consider $X_1$ as an arbitrary type, inheritance is plausible.

Of course, any fields using "Wsup" and "Wrec" directly relies on the $\bW(\sigma)$ (can be spotted from \ruleref{Ind-Term} and \ruleref{Rec-Constr}) and thus non-inheritable---in these cases, "Wsup" can be understood as concrete constructors and "Wrec" are \textit{exhaustiveness checking}. These fields together with inductive types are the one sealing responsible for hiding. After compilation of linkage type into existential type, we can easily hide the \textit{concrete} definition of the inductive type while exposing all the fields using "Wsup" and "Wrec" like an abstract interface. Apparently, future fields relies on this abstract interface will have no problem on inheritance. \YZ{Does coverage checking mean exhaustiveness checking?}\EDJreply{Yes. The one make sure every case is handled in pattern-matching. Do you want me to replace the terminology using exhaustiveness checking? }\YZreply{Yes, I think exhaustiveness is standard parlance.}
Of course, since "Wsup" and "Wrec" directly rely on the concrete inductive definition, we will have to override these fields whenever inductive type is overridden. For "Wsup" we only need to override each constructor and for "Wrec" it is just doing exhaustiveness checking inside each children family. The recursor handlers however, can be safely inherited.
\YZ{I suppose the terminology 'sealing' is a reference to ML modules? In
ML, sealing has the connotation of hiding things behind an existential
type. So using the same word may cause the reader to have false
presumptions about what is going on here.}\EDJreply{You are right. Our "Sealing" is not hiding a particular field into an existential type, but our seal is make several fields together into an "existential type". Basically it hides the concrete definition of inductive type so that future fields doesn't have to be defined upon that.}\EDJreply{I will resolve this comment once I add the throughout example and you find it clear---because I haven't changed any text}

\YZ{Can we have a more concrete example of how the judgment is useful?}\EDJreply{it is done in the example section, please check.}

And these are also the cases we don't need to seal anything (i.e. doing exhaustiveness checking when using recursor), and thus the "Seal-Id" is used. For notation clearance, we will sometime use $"sf'"$ to emphasize that we consider that seal $s$ as a term $("sf'" \ s)$. 

With the definition of sealing judgement in mind, we can see
\ruleref{Sig Add} and \ruleref{Lnkg Add} work exactly as the
implementation. In the implementation, we will have "self__" all around
when defining new fields in our plugin, and this "self__" is exactly the
$A$ in the context of the two fields---especially when we don't do any
sealing, this $A = \cC \sigma$, which is exactly how the implementation
exposes "self__" as a module parameter. 



Next we talk about inheritance judgement. Note that, there will be a lot of $\sigma_1, A_1$ and $\sigma_2, A_2$, and in these cases, $A_1$ is the result of the sealing of $\sigma_1$, i.e. we assume we have a term $\goodSeal{\Gamma}{f_1}{\sigma_1}{A_1}$, $\goodSeal{\Gamma}{f_2}{\sigma_2}{A_2}$ in the assumption of judgements when needed.


\judgebox{\goodInh{\Gamma}{h}{\sigma}{\tau}}

$$
\Rule[name=Inh-Id]
{}
{\goodInh{\Gamma}{"inhid"}{\sigma}{\sigma}}
\quad
\Rule[name=Inh-Override]
{
\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}  
\quad \goodType{\Gamma, A_1}{T_1}{}
\quad \goodType{\Gamma, A_2}{T_2}{}
  \quad \goodTerm{\Gamma, \cL \sigma_2'}{t}{T_2}}
{\goodInh{\Gamma}{"inhov" \ h \ t}{(\nu^+ \  \sigma_1 \  T_1)}{(\nu^+ \  \sigma_2\  T_2)}}
$$

$$
\Rule[name=Inh-Ext]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma, \cL \sigma_2'}{t}{T}}
{\goodInh{\Gamma}{"inhext" \ h \ t}{\sigma_1}{(\nu^+ \  \sigma_2\  T)}}
\quad
\Rule[name=Inh-Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodType{\Gamma, A_1}{T}{}
\quad \goodTerm{\Gamma, A_2}{\uparrow^s}{A_1[\pi_1]}
}
{\goodInh{\Gamma}{"inhinh" \ h}{(\nu^+ \  \sigma_1 \  T)}{(\nu^+ \  \sigma_2 \  T[(\pi_1, \uparrow^s)])}}
$$
$$
\Rule[name=Inh+Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma, A_2}{\uparrow^s}{A_1[\pi_1]}
\quad 
\goodInh{\Gamma, A_2}{i}{\tau_1[(\pi_1, \uparrow^s)]}{\tau_2}}
{\goodInh{\Gamma}{"inhnest" \ h \ i}{(\nu^+ \  \sigma_1\  \cL\tau_1)}{(\nu^+ \  \sigma_2\  \cL\tau_2)}}
\quad
$$

$$
\Rule[name=Inh]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
\quad \goodTerm{\Gamma}{l}{\cL \sigma_1}
}
{\goodTerm{\Gamma}{("inh" \ h \ l)}{\cL \sigma_2}} 
\quad 
\Rule[name=Inh-Inh-beta]
{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}
  \quad \goodTerm{\Gamma}{m}{\cL \sigma_1}
  \quad \goodTerm{\Gamma, A_1}{t}{T}
}
{\goodTerm{\Gamma}{"inh" ("inhinh" \ h) (\mu^+ \ m \ t) \equiv \mu^+ \ ("inh" \ h \ m) \ t[(\pi_1, \uparrow^s)]}{}} 
$$

Finally we introduce the inheritance judgement. Inheritance are judgement so naturally second class citizen data (i.e. not something function can return and cannot be assigned to variables), and it looks very much alike a function that transform a given linkage. 

The syntax of the inheritance judgement is very close to how Family is defined in the surface syntax---a Family with no parent is an inheritance with empty input; an extended Family is exactly an inheritance---because the parent of an extended Family can be overridden thus inheritance should only define upon the ``interface'' instead of a concrete family. However, since our current formulation doesn't support further-binding (i.e. we cannot do inheritance inside a family), our formulation still have some distance to the real family polymorphism. 

"inhid" and "inhext" are simple as expected---the former corresponds to empty inheritance, and the latter gives the programmer the ability to add new field. 

"inhinh" is special because it requires user to provide a proof of ``upcasting'' from the context of the children to that of the parent. In other words, if I want to inherit a specific field from the parent, I have to convince the type checker that my current context can ``accommodate'' the inherited field. 

Override "inhov" is even more special because in mundane OO programming language, we usually require that the overriding term has the same type/interface as the overriden one.  Here we don't since the very reason we want the same type/interface is that we hope other inherited fields can use this overridden/late-binding field without breaking abstraction, and this reason is already managed by the assumption of "inhinh", the upcasting proof $\uparrow^s$. Thus "inhov" is quite like "inhext", where overriding is just throwing away one parent field. This difference also show one of the distinct feature of our vanilla family inheritance compared to the mainstream OO inheritance---family inheritance don't need to introduce the concept of ``subclassing'' between families and thus no bounded polymorphism yet\footnote{Of course once trait and interface comes in, we can have bounded polymorphism back}, and code reuse is mainly achieved by late binding. Without ``subclassing'', there is no way of confusing inheritance and subtyping.

Finally we need to introduce nested inheritance "inhnest" for dealing with nested families. The rule is mostly direct and we need "upcasting" again when dealing with nested family in different but inheriting context.  We also show how to use an inheritance judgement to derive children family and how the beta rule is defined. We omit most of the other substitution laws here.



\subsection{Exemplar Usage of Meta Theory}
\input{syntactic-example.tex}