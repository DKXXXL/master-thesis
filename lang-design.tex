Inspired by the above challenges and Family Polymorphism, we propose
the following extension to Coq's Vernacular Commands, and the corresponding STLC example.
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ref\rangle] 
  \quad |\quad "EndFamily" \quad | \quad "SealFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ref\rangle~"motive"~\langle term\rangle~"using"~\langle ref\rangle \\
  & |\quad "FScheme CompEq about"~\langle ref \rangle~|\quad "FScheme " \langle ident\rangle " PRecT about"~\langle ref \rangle\\
  & | \quad "FTheorem"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle \\
  & |\quad ["Extend"]~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Overridable " ["pins " \{ \langle ident\rangle ... \}]]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & |\quad ["Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "FieldClaim"~\langle ident\rangle~":"~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle \quad \\
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\ 
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~"by"~"\{"\langle \text{one tactic expression}\rangle"\}" \\ 
  & | \quad "Family"~\langle ident\rangle~"extends"~\langle ref\rangle~"using"~\langle ref\rangle~"using"~\langle ref\rangle \\ 
  & | \quad "MetaData"~\langle ident\rangle \quad | \quad "EndMetaData" \\ 
\end{align*}


\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC.
 FInductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
 FInductive term : Set := 
  | tm_var : id -> term 
  | tm_abs : id -> term -> term ...
 Family subst_internal.
  Final Field tm_var := ..
  Final Field tm_abs := ..
   ...
 EndFamily.
 FRecursor subst
  about tm motive ..
  using subst_internal.
 ...
 FInductive has_type 
  : context -> term -> type := ...
 FTheorem subst_lemma 
  about has_type 
  motive ...
 Proof.  ...
 Qed.
 FInductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC_bool extends STLC.
 Extend FInductive ty : Set :=
  | bool : ty.

 Extend FInductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
 Extend Family subst_internal.
  Final Field tt := ..
  Final Field ff := ..
  Final Field tif := ..
 EndFamily. (* Automatic inheriting others 
              from STLC.subst_internal *)
 Inherit subst.
(* Plugin will redo exhaustiveness check, in case 
 subst_internal is not extended correctly *)
 Extend FInductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
 Extend FTheorem subst_lemma. Proof.
  ... (* Need to prove extra cases *)
 Qed.


 Extend FInductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example STLC and its extension, in designed syntax}\label{fig:STLC-example2}
\end{figure}

\textbf{Family and Defining Fields.} These are the core extensions we proposed to support \cref{fig:STLC-example}, and we adapt them into \cref{fig:STLC-example2}. We use "Family" and "EndFamily" to scope. "Field" is used to define new members in a family. "FieldClaim" is similar as "Field" but will invoke proof-mode in Coq and thus the user can use tactic programming to define new members.\footnote{We expect "FieldClaim" to be used in a \textit{proof-irrelevant} situation and thus whether overridable or not doesn't matter.} Both "Field" and "FieldClaim" are only allowed to refer to the former fields, to avoid possible inconsistency mentioned in \ref{chg:consistency}.
Nested families are also allowed. 


The user can use "self__A.<path>" to access the former defined fields inside a surrounding defining "Family A".\footnote{Note that, in most of our examples in the paper, these "self__" prefix is too long and verbose so we omitted them.} Note that, "self__A" is only visible in the Vernacular commands from our plugin.\footnote{(In other words, using "Definition" from Coq will not invoke the plugin to prepare "self__A" to be accessible---most original Vernacular command from vanilla Coq will not do such preparation.)}  Once the user closes a \textbf{top} family with "EndFamily", they can access the fields of the closed family by using module syntax. For example, they can access "A.a" to get "1" after "Family A" is defined. This "A" is truly accessible anywhere by vanilla Coq without any plugin preparation, just like a mundane module.

Most programming experiences are preserved from Coq---each term inside the field definition is a well-typed Gallina term in vanilla Coq. Note that, a Family is not a first class value and thus we need to project out the Gallina terms from them.

% Inheritance here
\textbf{Inheritance on Fields.} "Family A extends B" has to appear at
the top level (not inside any Family) and will start to construct the
children "Family B" given the parent "Family A". Every field inside the
derived family will be one of the three kinds of
``inheritance''---extending, overriding, and inheriting.
The syntax of extending a new field is to directly use "Field", while
overriding requires a prefix of "Override" before "Field f : .." and
"Inherit f" will inherit field "f" from the parent. 

To resolve \ref{chg:consistency}, we make sure when inheriting or
overriding on "f" happens, the context of the field "f" is also
``inherited''. Thus the mentioned informal example in
\ref{chg:consistency} will not apply here, because the overriding "f" is
in a context where "self" is empty thus "self.g" doesn't
type-check. Thus, before we inherit "g", the dependee "f" needs to be
inherited.  


\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq, escapeinside={@}{@}]
Family I.
 Field a : nat := 1.
 Field b : a = 1 := eq_refl.
 Overridable Field a' : nat := 1.
 Fail Field c : a' = 1 := eq_refl. (* Fail 1*)
 Overridable Field f : nat -> nat := non_impl.
 Overridable 
  Field p : monotonic f := non_impl.
EndFamily.
\end{lstlisting}
  \end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family I2 extends I.
 
 Inherit Field b.
 Override Field a' : nat := 2.  (* Override *)

 Override Field f : nat -> nat := (+ 1).
 Override pins {f} 
  Field p : monotonic f := ...
 EndFamily. 
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example Code for Inheritance and Reasoning}\label{fig:plugin-example3}
\end{figure}


% % Talk about Final
% \textbf{Final as non-overridable.} Every field is by default
% overridable, reminding us of \ref{chg:definition-relevant-reasoning}.  To
% resolve it, we provide the keyword "Final" to allow the user to specify
% \textit{non-overridability} and give the user the opportunity to choose
% from overriding and exposing the definition.

% Take the field "c" of "Family I" in \cref{fig:plugin-example3} as an 
% example. We can see that the first attempt of proving "a = 1" fails.
% This should fail---because we want to retain the possibility
% to override "a" and inheriting "c" in the future, but they are
% conflicting, since "c" witnesses that "a" is fixed to "1". On the other
% hand, once we decorate \lstinline{a'} as final, the second attempt
% \lstinline{c : a' = 1 := eq_refl} will succeed. Contrary to "a",
% our \lstinline{a'} is not overridable in "Family I2", mediating the
% \ref{chg:definition-relevant-reasoning}.

% This example might sound trivial and contrived. Let's look at the
% example field binary operation "bop" initially set to be addition.
% Now that we only expose the type of "bop", we
% cannot prove its commutativity in "comm_bop" (because we don't have
% access to its concrete definition) but we can override "bop" with
% subtraction function in "Family I2". This makes sense because we
% shouldn't (have the ability to) inherit commutativity property for
% subtraction anyway. This is contrary to how \lstinline{a'} is declared
% "Final": the second "c" can prove that it's equal to 1 but
% \lstinline{a'} is not overridable in the "Family I2". 

% In our example, the seal family "I.MonotonicF" is actually simulating
% interfaces as well.  We have
% \mbox{``\mintinline{Coq}{Axiom non_impl : forall {T : Type}, T.}''},
% and we assigned it to both "f" and "p", and later instantiate in
% "I2" with concrete implementation by overriding this family
% "I.MonotonicF".

% \textbf{Overridable/Sealed Family as better Sigma Type.} Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

% Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

\textbf{Overridable Fields with dependency.}  Each field is by default non-overridable. By the discussion of \ref{chg:definition-relevant-reasoning}, we can simply reason and access the definition about the former fields in a later field, just like Field "a" and "b" in \cref{fig:plugin-example3} and we lose the ability to override. 

However, overridability is useful especially in Coq as programs in Coq are runnable. Consider the sceanrio when we use arbitrary monotonic function as field members \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}, and we make sure that all the following reasoning are only about the monotonicity. Then it should be allowed to swap the implementation of that monotonic function via overriding. 

To resolve, we introduce overridable fields. Each overridable field will only expose its type instead of the concrete definition to the following default (non-overridable) fields. For example, the first failure in \cref{fig:plugin-example3} per the discussion of \ref{chg:definition-relevant-reasoning}: since overridability will break the inheritability of "c" and thus we don't allow such field to exist in the first place. Our plugin will only expose the fact that "a'" is an arbitrary natural number but hiding its concrete definition, and thus "eq_refl" will fail to type-check.

In this stage, this feature is yet too weak since we cannot do definitional-relevant reasoning about overridable fields, like field "c" in the first failure. Thus we introduce \textit{dependency} between overridable fields---in the syntax of \mintinline{Coq}{Overridable pins {x,y,...} Field f := fexp}. In this case, field "f" will depend on the (overridable) field "x,y,...", and semantically, this means the concrete definition of "x,y,..." is \textit{exposed} to "fexp" during the type checking of "fexp". Every overridable field can only depend on former \textit{overridable} and \textit{definition-transparent} (non-"Qed"-Coq-term) fields. 

To override an overridable field, we use the syntax \\ \mintinline{Coq}{Override [pins {x',y',...}] Field f := fexp'} in the definition of the children family. We can change the dependency \textbf{arbitrarily} in the children family if we want, just by specifying the new "pins" component and there is no restriction on the "x',y',..." we choose. The only restriction is that the overriden "f" has to have the same type as the parent field "f". 

However, if we want to inherit any overridable field in the children family, we need to make sure every dependent (overridable) field is \textit{inherited instead of overridden} in the children family. That means, every overriding will lead to a chain of overriding on the depender fields. This coincides with our intuition about the example---when the dependee monotonic function is overridden, the proof about its monotonicity needs to be changed accordingly. 
Look at the field "f" and "p" in \cref{fig:plugin-example3} in both families. Both fields are initially filled with place-holder in the parent family, but then in children family "I2", "f" is overridden by "(+ 1)" and then to prove its monotonicity, we need to expose the concrete definition of "f" and thus we need to \textit{newly} pins "f" when providing the overriding "p".




% if the user wants a given field to be non-overridable. We will later elaborate its detail application.

\textbf{Inheritance on Nested Families.} We also provide extending,
inheriting and overriding for nested family (member). Extension is done
by simply declaring a nested family; the same syntax for inheriting a
field is used in inheriting a family. However, overriding is
special---overriding can only apply to \textit{sealed} nested family in
the parent family. A family is sealed when using "SealFamily" as the
scoping instead of "EndFamily". We will later elaborate the motivation
and details of sealed family.

% Currently, every sealed family can only be direct inherited or overridden as a whole. It cannot be extended.

\textbf{Extensible Inductive Type.} We provide the keyword "FInductive"
to enable extensible inductive type. "Extend FInductive" is used to
support extension of the parent inductive type inside a children family.
The syntax of these two is close to the mundane "Inductive" keyword. 

Unlike how Coq's "Inductive" will automatically generate the eliminator for the inductive type, we require the user to explicit use "FScheme .. PRecT" to generate a \textit{partial recursor} for the "FInductive". We will later explain what a partial recursor is, at this point the reader can just consider it as a mundane eliminator. 


To resolve \ref{chg:extensible-inductive-type}, our first step is to
\textit{decouple} the definition of recursor handlers and the checking
of exhaustiveness. The users will define recursive handlers for one
inductive type by aggregating the (function) handlers into one family.
Then
"FRecursor" will be used to construct a recursor by referring to the handler family.
\mintinline{Coq}{FRecursor recur about T motive f } "using"
"handlers" will generate a new field "recur" that is really doing computation
(using elimination principle of the inductive type "T") with motive "f". The handlers
are located in the family "handlers", similar to a large pattern-matching statement. This way, the reuse and the extension of the case handlers will be delegated by the inheritance of the family. Once recursor is created it will look like any other function fields(e.g. "subst" in \cref{fig:STLC-example2}).




"FTheorem" has a similar functionality but is expected to be used for
theorem proving---the handler and the family will be automatically
constructed during proving.\YZ{Cool. Can the same be done to FRecursor?}\EDJreply{I think last time I have answered it. FRecursor for fixpoint command}

% Explain FScheme
However, "FRecursor" doesn't specify any reduction/computation information until a family is defined completely and closed (e.g. "subst" in \cref{fig:STLC-example2} cannot reduce when application during the definition of the surrounding family). To remedy this, we introduce "FScheme CompEq" that will generate proposition of equations indicating reductions. For example, for "subst", it will generate the equation
\mintinline{Coq}{subst tm_unit = subst_internal.tm_unit}. 

Similarly, the generated partial recursor using "FScheme .. PRecT" doesn't have computation information either, and require "FScheme CompEq" to generate them.

% Explain Mixin

\textbf{Mixin.} For two inheritance with the same parent family, we support mixin the two using "Family ... extends ... using ... using ...". However, the candidates for mixin cannot have any overriding term (i.e. only allow inheritance and extension).   

% We can also use "Family" and "SealFamily" to scope a (nested) family. The resulting family only support direct inheritance or "Override" (i.e. we can only override a sealed family as a whole together)---we will later explain this design decision and its usage, especially on resolving \ref{chg:definition-relevant-reasoning}. What's more, "Override" family can only apply to sealed family as well (not allowed on normal family).

% We can inherit a top-level family "parent" using \mintinline{Coq}{Family ... extends parent} as a new top-level family. As expected, "Override"
% will override a field from the parent. "Inherit" can be used to inherit
% nested families, inductive types, and fields. "Final" is used to claim that the decorated field is non-overridable, and later we will show how it is used to resolve \ref{chg:definition-relevant-reasoning}. The fields inside a family
% are order-sensitive because we have dependent types here. So "Inherit
% Until" is used if the user wants to inherit a range of fields.  "Extend Family" is used only inside a inheriting family. Thus nested
% family can only be inherited or extended together with its belonging family
% (i.e. ultimately top level family), thus our support of family polymorphism is
% incomplete.

We will explain the usage of "Closing Fact" and "MetaData" later---they are \textit{escape-hatches} to resolve \ref{chg:software-engineering} to some extent.
% This incomplete support can already be useful for extending functions.
% Take \cref{fig:plugin-example2} as example, if we want to extend boolean
% inductive type and its negation, we only need to specify the new
% constructor for boolean and how negation deals with the new constructor.
% As a result, the programmer does not have to duplicate code---otherwise
% the user will need to copy and paste the whole original negation
% definition and add a new pattern matching case.
