\YZ{looks more like a 'design space' rather than 'language design' section}\EDJreply{Good point. Do I just change the section name?s}
When adapting Family Polymorphism into dependent types, we choose to
focus only on the essence of family (and inheritance)
structure in \citet{zm2017}, and thus a lot of unrelated features, like
Interface, will be removed. In this case, it will look like module with
late-binding and inheritance as code and proof reuse for module. We also
need it to have good compatibility with inductive types, because we
don't want to lose too much reasoning power of Coq (and its tactic
programming). 

Let's start with a basic example---STLC and its extension in
\cref{fig:STLC-example}---to consider what kind of features are required
and how much of them can be supported by family polymorphism.
% add the example code here

\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize]{Coq}
Family STLC.
Inductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
Inductive term : Set := 
  | var : id -> term 
  | lam : id -> term -> term ...
Fixpoint subst 
  : id -> term -> term := ...
Inductive has_type 
  : context -> term -> type := ...
Proposition subst_lemma :
  has_type (Γ; x ↦ A) t T ->
  has_type Γ u A ->
  has_type Γ (subst x u t) T.
Inductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{minted}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize]{Coq}
Family STLC_bool extends STLC.
Extend Inductive ty : Set :=
  | bool : ty.

Extend Inductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
Extend Fixpoint subst (* Need to handle new term *)
  : id -> term -> term := ...
Extend Inductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
Extend Proposition subst_lemma :
  ... (* Need to prove extra cases *)


Extend Inductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{minted}
  \end{minipage}
  \caption{Example STLC and its extension}\label{fig:STLC-example}
\end{figure}


First and foremost, \textlabel{Req (0)}{langdesign-req0}\textbf{we desire incremental(modular) type checking}. Notice that, the modularity here in Coq is a bit different from other language, because Coq is \textit{interactive} theorem proving so we actually need \textit{statement-wise} incremental type checking, not only for saving the compilation time, but also for the immediate feedback and type-checking for the Coq developer.

% We want to reason about fields in a family.
\textlabel{Req (1)}{langdesign-req1}:\textbf{ we want to be able to
reason about fields in a family}, just like in a module, where a field
can reason about its former fields. More generally, we want to allow a
later field to be type-dependent on the former fields. In the example of
\cref{fig:STLC-example}, "subst", "has_type", "subst_lemma" all require
this feature.\YZ{rephrase Req to Challenges}\EDJreply{But it is not really challenge because I didn't show their difficulty. It is more like requirements.}

% we want extensible inductive type
\textlabel{Req (2)}{langdesign-req2}:\textbf{ we need extensible
inductive types}, to extend "term" and "ty" in \cref{fig:STLC-example}.
Extensible inductive types are not supported by \citet{zm2017}, so
we need further consideration about it on both implementation and
metatheory.

\textlabel{Req (3)}{langdesign-req3}: \textbf{we also want extensible
pattern matching and induction reasoning}, to extend "subst" in
\cref{fig:STLC-example}.
There are actually two kinds of ``pattern matching'', one for data and
the other for induction reasoning, i.e., one uses the eliminator to
\mintinline{Coq}{Set} or \mintinline{Coq}{Type}, and the other uses the
eliminator to \mintinline{Coq}{Prop}. Luckily, in this setting,
extensible pattern matching can be easily expressed with family
extension---we just aggregate all case handlers of pattern matching
into one family (as a bunch of functions), and then one family can
encode one pattern matching, and family inheritance can express adding
case handlers. Then we just need to introduce a primitive that will
``wrap'' that family into a recursive function. Induction reasoning can
be handled in an almost identical way. 

% we want to be able to reason pattern matching as well
However, there is still difference between data recursion and induction
reasoning, because the former one is \textit{proof-relevant}. This
difference leads to another issue: \textlabel{Req (4)}{langdesign-req4}:
\textbf{we need to reason about (the computation about) extensible
pattern matching}, just like "subst_lemma" in \cref{fig:STLC-example}.
When proving "subst_lemma", we have to know "subst" is invariant on
"tt", i.e., \mintinline{Coq}{(subst i x tt) = tt}. This kind of
information requires exposing \textit{computational rules} from the
recursors.\YZ{What goes wrong if subst is not invariant or you do not
know whether subst is invariant?}\EDJreply{Then it is unprovable because substitution lemma need to know this. You can just instantiate the whole lemma -- we want  
has_type (Γ; x ↦ A) tt T ->
has_type Γ u A ->
has_type Γ (subst i x tt) T. But this final goal requires to know the computation of subst.}

% we want tactic programming and certain level of automation
Finally, \textlabel{Req (5)}{langdesign-req5}: \textbf{we desire tactic
programming} to relieve us from the hassle of direct manipulation of
proof terms.\YZ{What about modular type checking?}\EDJreply{Good point! Let me add that.}