\subsection{Design Space}\YZ{I was thinking if the paper should start by talking about the functional encoding of inheritance (namely exposing a self parameter to allow late binding, and later taking the fixpoint of the extensible module when it needs to be accessed outside the family).  I think most readers will benefit from a recap of this encoding.\\
Coq is total but that doesn’t prevent Coq from having a Fixpoint keyword (plus you proved your language is consistent).
}

When adapting Family Polymorphism into dependent types, we choose to
focus only on the essence of family (and inheritance)
structure in \citet{zm2017}, and thus a lot of unrelated features, like
Interface, will be removed. In this case, it will look like module with
late-binding. Inheritance can be considered as code and proof reuse mechanism for module. We also
need it to have good compatibility with inductive types, because we
don't want to retain the idiomatic Coq programming experience
%\YZ{By 'reasoning power of Coq', I suppose you mean the expressive power of Gallina?}\EDJreply{I think the sentence last time was not really making sense because using Church Encoding of inductive doesn't sabotage the expressiveness. I rephrase it now, please check.}
(and its tactic programming). 

Let's start with a basic example---STLC and its extension in
\cref{fig:STLC-example}---to consider what kind of features are required
and how much of them can be supported by family polymorphism.
% add the example code here

\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize,escapeinside=||]{Coq}
Family STLC.|\YZ{Does minted support adding extra keywords such as 'Family' and 'extends'?}|
Inductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
Inductive term : Set := 
  | var : id -> term 
  | lam : id -> term -> term ...
Fixpoint subst 
  : id -> term -> term := ...
Inductive has_type 
  : context -> term -> type := ...
Proposition subst_lemma :
  has_type (Γ; x ↦ A) t T ->
  has_type Γ u A ->
  has_type Γ (subst x u t) T.
Inductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{minted}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize]{Coq}
Family STLC_bool extends STLC.
Extend Inductive ty : Set :=
  | bool : ty.

Extend Inductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
Extend Fixpoint subst (* Need to handle new term *)
  : id -> term -> term := ...
Extend Inductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
Extend Proposition subst_lemma :
  ... (* Need to prove extra cases *)


Extend Inductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{minted}
  \end{minipage}
  \caption{Example STLC and its extension}\label{fig:STLC-example}
\end{figure}



First and foremost, we don't want to throw away some basic good
properties of Coq. \textlabel{Req~(0A)}{langdesign-req0}~\textbf{we
want to retain incremental (modular) type checking}. Notice that, the
modularity here in Coq is a bit different from other languages, because
Coq supports \textit{interactive} theorem proving, so we actually need
\textit{statement-wise} incremental type checking, not only for avoiding
re\-compilation, but also to enable immediate feedback and incremental
type-checking for the Coq developer. We don't want our family to ruin
this conventional routine of interactive development.
\textlabel{Req~(0B)}{langdesign-req0b}~\textbf{we also want to keep the
computational ability of Coq when using families}. Coq, based on constructive
logic, can consider proof as programs. 
We don't want our Family facility to ruin this when incorporated with 
the remaining parts of Coq: 
the developers should be able to project fields of families 
as first-class value just like how they can project fields of Coq's Module.

% We want to reason about fields in a family.
\textlabel{Req (1)}{langdesign-req1}:\textbf{ we want to be able to
reason about fields in a family}, just like in a module, where a field
can reason about its former fields. More generally, we want to allow a
later field to be type-dependent on the former fields. In the example of
\cref{fig:STLC-example}, "subst", "has_type", "subst_lemma" all require
this feature.\YZ{rephrase Req to Challenges}\EDJreply{But it is not really challenge because I didn't show their difficulty. It is more like requirements.}

% we want extensible inductive type
\textlabel{Req (2)}{langdesign-req2}:\textbf{ we need extensible
inductive types}, to extend "term" and "ty" in \cref{fig:STLC-example}.
Extensible inductive types are not supported by \citet{zm2017}, so
we need further consideration about it on both implementation and
metatheory.

\textlabel{Req (3)}{langdesign-req3}: \textbf{we also want extensible
pattern matching and induction reasoning}, to extend "subst" in
\cref{fig:STLC-example}.
There are actually two kinds of ``pattern matching'', one for data and
the other for induction reasoning, i.e., one uses the eliminator to
\mintinline{Coq}{Set} or \mintinline{Coq}{Type}, and the other uses the
eliminator to \mintinline{Coq}{Prop}. Luckily, in this setting,
extensible pattern matching can be easily expressed with family
extension---we just aggregate all case handlers of pattern matching
into one family (as a bunch of functions), and then one family can
encode one pattern matching, and family inheritance can express adding
case handlers. Then we just need to introduce a primitive that will
``wrap'' that family into a recursive function. Induction reasoning can
be handled in an almost identical way. 

% we want to be able to reason pattern matching as well
However, there is still difference between data recursion and induction
reasoning, because the former one is \textit{proof-relevant}. This
difference leads to another issue: \textlabel{Req (4)}{langdesign-req4}:
\textbf{we need to reason about (the computation about) extensible
pattern matching}, just like "subst_lemma" in \cref{fig:STLC-example}.
When proving "subst_lemma", we have to know "subst" is invariant on
"tt", i.e., \mintinline{Coq}{(subst i x tt) = tt}. This kind of
information requires exposing \textit{computational rules} from the
recursors.\YZ{What goes wrong if subst is not invariant or you do not
know whether subst is invariant?}\EDJreply{Then it is unprovable because substitution lemma need to know this. You can just instantiate the whole lemma -- we want  
has_type (Γ; x ↦ A) tt T ->
has_type Γ u A ->
has_type Γ (subst i x tt) T. But this final goal requires to know the
computation of subst.}\YZreply{Seems like what's missing here is to
convince the reader why exposing the definition of subst could be a
problem for family polymorphism.}\EDJreply{Actually I don't see why I need to emphasize this "as a problem". This is just a requirement like any other requirements earlier. I don't know how to show its difficulty at this early stage.}

% we want tactic programming and certain level of automation
Finally, \textlabel{Req (5)}{langdesign-req5}: \textbf{we desire tactic
programming} to relieve us from the hassle of direct manipulation of proof terms.

\subsection{Language Design}
Inspired by our above requirements and Family Polymorphism, we propose
the following extension to Coq's Vernacular Commands.
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ident\rangle] 
  \quad |\quad "EndFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle~"using"~\langle ident\rangle \\
  & |\quad "Extend"~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Final" | "Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "FieldClaim"~\langle ident\rangle~":"~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle \quad | \quad ...
\end{align*}

These are some core extension we proposed to support \cref{fig:STLC-example}. We use "Family" and "EndFamily" to scope, and "Field" is used to define new members in a family. "FieldClaim" is similar as "Field" but will invoke proof-mode in Coq and thus the user can use tactic programming to define new members.\footnote{We expect "FieldClaim" to be used in a \textit{proof-irrelevant} situation and thus whether overridable or not doesn't matter.}
We can define nested families.
Family will also be used to encode recursive handlers. Each case
handling of one inductive type will be aggregated into one family, then
"FRecursor" will be used to construct a recursor using these handlers.
For example, \mintinline{Coq}{FRecursor recur about T motive f} "using"
"handlers" will generate a new field "recur" that is doing induction
(using elimination principle of "T") using motive "f", and the handlers
are located in the family "handlers".

We can inherit a top-level family "parent" using \mintinline{Coq}{Family
... extends parent} as a new top-level family. As expected, "Override"
will override a field from the parent. "Inherit" can be used to inherit
nested families, inductive types, and fields. The fields inside a family
are order-sensitive because we have dependent types here. So "Inherit
Until" is used if the user wants to inherit a range of fields. If the
user wants to extend an inductive type or a nested family from the
parent, then "Extend FInductive" or "Extend Family" is used. Thus nested
family can only be inherited or extended together with its outer family
(and thus top level family), thus our support of family polymorphism is
incomplete.

This incomplete support can already be useful for extending functions.
Take \cref{fig:plugin-example2} as example, if we want to extend boolean
inductive type and its negation, we only need to specify the new
constructor for boolean and how negation deals with the new constructor.
As a result, the programmer does not have to duplicate code---otherwise
the user will need to copy and paste the whole original negation
definition and add a new pattern matching case.
