Inspired by the above challenges and Family Polymorphism, we propose
the following extension to Coq's Vernacular Commands, and the corresponding STLC example.
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ident\rangle] 
  \quad |\quad "EndFamily" \quad | \quad "SealFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle~"using"~\langle ident\rangle \\
  & | \quad "FTheorem"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle \\
  & |\quad ["Extend" | "Override"]~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Final" | "Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "FieldClaim"~\langle ident\rangle~":"~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle \quad \\
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\ 
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~"by"~"\{"\langle \text{one tactic expression}\rangle"\}" \\ 
  & | \quad "MetaData"~\langle ident\rangle \quad | \quad "EndMetaData" \\ 
\end{align*}


\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC.
 FInductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
 FInductive term : Set := 
  | tm_var : id -> term 
  | tm_abs : id -> term -> term ...
 Family subst_internal.
  Final Field tm_var := ..
  Final Field tm_abs := ..
   ...
 EndFamily.
 FRecursor subst
  about tm motive ..
  using subst_internal.
 ...
 FInductive has_type 
  : context -> term -> type := ...
 FTheorem subst_lemma 
  about has_type 
  motive ...
 Proof.  ...
 Qed.
 FInductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family STLC_bool extends STLC.
 Extend FInductive ty : Set :=
  | bool : ty.

 Extend FInductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
 Extend Family subst_internal.
  Final Field tt := ..
  Final Field ff := ..
  Final Field tif := ..
 EndFamily. (* Automatic inheriting others 
              from STLC.subst_internal *)
 Inherit subst.
(* Plugin will redo exhaustiveness check, in case 
 subst_internal is not extended correctly *)
 Extend FInductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
 Extend FTheorem subst_lemma. Proof.
  ... (* Need to prove extra cases *)
 Qed.


 Extend FInductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example STLC and its extension, in designed syntax}\label{fig:STLC-example2}
\end{figure}

\textbf{Family and Defining Fields.} These are the core extensions we proposed to support \cref{fig:STLC-example}, and we adapt them into \cref{fig:STLC-example2}. We use "Family" and "EndFamily" to scope. "Field" is used to define new members in a family. "FieldClaim" is similar as "Field" but will invoke proof-mode in Coq and thus the user can use tactic programming to define new members.\footnote{We expect "FieldClaim" to be used in a \textit{proof-irrelevant} situation and thus whether overridable or not doesn't matter.} Both "Field" and "FieldClaim" are only allowed to refer to the former fields, to avoid possible inconsistency mentioned in \ref{chg:consistency}.
Nested families are also allowed. 


The user can use "self__A.<path>" to access the former defined fields inside a surrounding defining "Family A".\footnote{Note that, in most of our examples in the paper, these "self__" prefix is too long and verbose so we omitted them.} Note that, "self__A" is only visible in the Vernacular commands from our plugin.\footnote{(In other words, using "Definition" from Coq will not invoke the plugin to prepare "self__A" to be accessible---most original Vernacular command from vanilla Coq will not do such preparation.)}  Once the user closes a \textbf{top} family with "EndFamily", they can access the fields of the closed family by using module syntax. For example, they can access "A.a" to get "1" after "Family A" is defined. This "A" is truly accessible anywhere by vanilla Coq without any plugin preparation, just like a mundane module.

Most programming experiences are preserved from Coq---each term inside the field definition is a well-typed Gallina term in vanilla Coq. Note that, a Family is not a first class value and thus we need to project out the Gallina terms from them.

% Inheritance here
\textbf{Inheritance on Fields.} "Family A extends B" has to appear at
the top level (not inside any Family) and will start to construct the
children "Family B" given the parent "Family A". Every field inside the
derived family will be one of the three kinds of
``inheritance''---extending, overriding, and inheriting.
The syntax of extending a new field is to directly use "Field", while
overriding requires a prefix of "Override" before "Field f : .." and
"Inherit f" will inherit field "f" from the parent. 

To resolve \ref{chg:consistency}, we make sure when inheriting or
overriding on "f" happens, the context of the field "f" is also
``inherited''. Thus the mentioned informal example in
\ref{chg:consistency} will not apply here, because the overriding "f" is
in a context where "self" is empty thus "self.g" doesn't
type-check. Thus, before we inherit "g", the dependee "f" needs to be
inherited.  


\begin{figure}[!htb]
  \begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=Coq, escapeinside={@}{@}]
Family I.
 Field a : nat := 1.
 Field b : a = a := eq_refl.
 Fail Field c : a = 1 := eq_refl. (*Fail 1*)

 Final Field a' : nat := 1.
 Field c : a' = 1 := eq_refl.
 Field bop : nat -> nat -> nat := (+).
 Fail Field comm_bop : ...

 Family MonotonicF.
  Field f : nat -> nat := non_impl.
  Field p : monotonic f := non_impl.
 SealFamily. 
EndFamily.
\end{lstlisting}
  \end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family I2 extends I.
 Override Field a : nat := 1. (* Override *)
 Inherit b.                   (* Inherit  *)

 Field d : nat := a.          (* Extend   *)
 Fail Override Field a' : nat := 2. (*Fail 2*)

 Override Field bop := (-).

 Inherits Until MonotonicF.
 Override Family MonotonicF.
  Field f : nat -> nat := (+ 1).
  Field p : monotonic f := ...
 EndFamily. 
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example Code for Inheritance and Reasoning}\label{fig:plugin-example3}
\end{figure}


% Talk about Final
\textbf{Final as non-overridable.} Every field is by default
overridable, reminding us of \ref{chg:definition-relevant-reasoning}.  To
resolve it, we provide the keyword "Final" to allow the user to specify
\textit{non-overridability} and give the user the opportunity to choose
from overriding and exposing the definition.

Take the field "c" of "Family I" in \cref{fig:plugin-example3} as an 
example. We can see that the first attempt of proving "a = 1" fails.
This should fail---because we want to retain the possibility
to override "a" and inheriting "c" in the future, but they are
conflicting, since "c" witnesses that "a" is fixed to "1". On the other
hand, once we decorate \lstinline{a'} as final, the second attempt
\lstinline{c : a' = 1 := eq_refl} will succeed. Contrary to "a",
our \lstinline{a'} is not overridable in "Family I2", mediating the
\ref{chg:definition-relevant-reasoning}.

This example might sound trivial and contrived. Let's look at the
example field binary operation "bop" initially set to be addition.
Now that we only expose the type of "bop", we
cannot prove its commutativity in "comm_bop" (because we don't have
access to its concrete definition) but we can override "bop" with
subtraction function in "Family I2". This makes sense because we
shouldn't (have the ability to) inherit commutativity property for
subtraction anyway. This is contrary to how \lstinline{a'} is declared
"Final": the second "c" can prove that it's equal to 1 but
\lstinline{a'} is not overridable in the "Family I2". 

In our example, the seal family "I.MonotonicF" is actually simulating
interfaces as well.  We have
\mbox{``\mintinline{Coq}{Axiom non_impl : forall {T : Type}, T.}''},
and we assigned it to both "f" and "p", and later instantiate in
"I2" with concrete implementation by overriding this family
"I.MonotonicF".

\textbf{Overridable/Sealed Family as better Sigma Type.} Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
(definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
\mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
because to prove
the latter we need to have concrete definition of "f" in the family type, which
makes "f" non-overridable at all. One option is to use sigma type
\mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
a bundle of stuff with multiple refinements. 

To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

For example, the "MonotonicF" in \cref{fig:plugin-example3}:
we simply seal
\mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
together inside an sealed family.
Because the definition of "f" is exposed inside the family, 
its definition is
transparent and can be used to prove "p".
However, because the enclosing family of "f" is overridable, to swap the
implementation of "f", we just override the whole ``sealed'' family,
like we do in "I2.MonotonicF". 


% if the user wants a given field to be non-overridable. We will later elaborate its detail application.

\textbf{Inheritance on Nested Families.} We also provide extending,
inheriting and overriding for nested family (member). Extension is done
by simply declaring a nested family; the same syntax for inheriting a
field is used in inheriting a family. However, overriding is
special---overriding can only apply to \textit{sealed} nested family in
the parent family. A family is sealed when using "SealFamily" as the
scoping instead of "EndFamily". We will later elaborate the motivation
and details of sealed family.

% Currently, every sealed family can only be direct inherited or overridden as a whole. It cannot be extended.

\textbf{Extensible Inductive Type.} We provide the keyword "FInductive"
to enable extensible inductive type. "Extend FInductive" is used to
support extension of the parent inductive type inside a children family.
The syntax of these two is close to the mundane "Inductive" keyword. 


To resolve \ref{chg:extensible-inductive-type}, our first step is to
\textit{decouple} the definition of recursor handlers and the checking
of exhaustiveness. The users will define recursive handlers for one
inductive type by aggregating the (function) handlers into one family.
Then
"FRecursor" will be used to construct a recursor by referring to the handler family.
\mintinline{Coq}{FRecursor recur about T motive f } "using"
"handlers" will generate a new field "recur" that is really doing computation
(using elimination principle of the inductive type "T") with motive "f". The handlers
are located in the family "handlers", similar to a large pattern-matching statement. This way, the reuse and the extension of the case handlers will be delegated by the inheritance of the family. Once recursor is created it will look like any other function fields(e.g. "subst" in \cref{fig:STLC-example2}).

"FTheorem" has a similar functionality but is expected to be used for
theorem proving---the handler and the family will be automatically
constructed during proving.\YZ{Cool. Can the same be done to FRecursor?}\EDJreply{I think last time I have answered it. FRecursor for fixpoint command}

% We can also use "Family" and "SealFamily" to scope a (nested) family. The resulting family only support direct inheritance or "Override" (i.e. we can only override a sealed family as a whole together)---we will later explain this design decision and its usage, especially on resolving \ref{chg:definition-relevant-reasoning}. What's more, "Override" family can only apply to sealed family as well (not allowed on normal family).

% We can inherit a top-level family "parent" using \mintinline{Coq}{Family ... extends parent} as a new top-level family. As expected, "Override"
% will override a field from the parent. "Inherit" can be used to inherit
% nested families, inductive types, and fields. "Final" is used to claim that the decorated field is non-overridable, and later we will show how it is used to resolve \ref{chg:definition-relevant-reasoning}. The fields inside a family
% are order-sensitive because we have dependent types here. So "Inherit
% Until" is used if the user wants to inherit a range of fields.  "Extend Family" is used only inside a inheriting family. Thus nested
% family can only be inherited or extended together with its belonging family
% (i.e. ultimately top level family), thus our support of family polymorphism is
% incomplete.

We will explain the usage of "Closing Fact" and "MetaData" later---they are here to resolve \ref{chg:software-engineering} to some extent.
% This incomplete support can already be useful for extending functions.
% Take \cref{fig:plugin-example2} as example, if we want to extend boolean
% inductive type and its negation, we only need to specify the new
% constructor for boolean and how negation deals with the new constructor.
% As a result, the programmer does not have to duplicate code---otherwise
% the user will need to copy and paste the whole original negation
% definition and add a new pattern matching case.
