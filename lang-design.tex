\subsection{Design Space}

\YZ{looks more like a 'design space' rather than 'language design' section}\EDJreply{Good point. Do I just change the section name?s}
When adapting Family Polymorphism into dependent types, we choose to
focus only on the essence of family (and inheritance)
structure in \citet{zm2017}, and thus a lot of unrelated features, like
Interface, will be removed. In this case, it will look like module with
late-binding and inheritance as code and proof reuse for module. We also
need it to have good compatibility with inductive types, because we
don't want to lose too much reasoning power of Coq (and its tactic
programming). 

Let's start with a basic example---STLC and its extension in
\cref{fig:STLC-example}---to consider what kind of features are required
and how much of them can be supported by family polymorphism.
% add the example code here

\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize]{Coq}
Family STLC.
Inductive ty : Set :=
  | unit : ty
  | arrow : ty -> ty -> ty.
Inductive term : Set := 
  | var : id -> term 
  | lam : id -> term -> term ...
Fixpoint subst 
  : id -> term -> term := ...
Inductive has_type 
  : context -> term -> type := ...
Proposition subst_lemma :
  has_type (Γ; x ↦ A) t T ->
  has_type Γ u A ->
  has_type Γ (subst x u t) T.
Inductive step : term -> term -> Prop 
  := ...
(* ... and more, end with type safety *)
EndFamily.
\end{minted}
  \end{minipage}
  \begin{minipage}[t]{0.47\linewidth}
\begin{minted}[fontsize=\footnotesize]{Coq}
Family STLC_bool extends STLC.
Extend Inductive ty : Set :=
  | bool : ty.

Extend Inductive term : Set := 
  | tt : term | ff : term 
  | tif : term -> term -> term -> term
Extend Fixpoint subst (* Need to handle new term *)
  : id -> term -> term := ...
Extend Inductive has_type (* .. and new ty too *)
  : context -> term -> type := ...
Extend Proposition subst_lemma :
  ... (* Need to prove extra cases *)


Extend Inductive step : term -> term -> Prop 
  := ... (* Need to expand this binary relation *)
(* ... and more extension *)
EndFamily.
\end{minted}
  \end{minipage}
  \caption{Example STLC and its extension}\label{fig:STLC-example}
\end{figure}


First and foremost, we don't want to throw away some basic good properties from Coq. \textlabel{Req (0A)}{langdesign-req0}~\textbf{we want to retain the incremental(modular) type checking}. Notice that, the modularity here in Coq is a bit different from other language, because Coq is \textit{interactive} theorem proving so we actually need \textit{statement-wise} incremental type checking, not only for saving the compilation time, but also for the immediate feedback and type-checking for the Coq developer. We don't want our family to ruin this conventional routine of interactive development. \textlabel{Req (0B)}{langdesign-req0b}~\textbf{we also want to keep the computational property of Coq when use family}. Coq, as a constructive logic, has been famous for its ability to do calculations and extract programs. We don't want our Family facility to ruin this: the developers should be able to project field from families as first-class value just like how we can treat fields of Coq's Module as first-class values.

% We want to reason about fields in a family.
\textlabel{Req (1)}{langdesign-req1}:\textbf{ we want to be able to
reason about fields in a family}, just like in a module, where a field
can reason about its former fields. More generally, we want to allow a
later field to be type-dependent on the former fields. In the example of
\cref{fig:STLC-example}, "subst", "has_type", "subst_lemma" all require
this feature.\YZ{rephrase Req to Challenges}\EDJreply{But it is not really challenge because I didn't show their difficulty. It is more like requirements.}

% we want extensible inductive type
\textlabel{Req (2)}{langdesign-req2}:\textbf{ we need extensible
inductive types}, to extend "term" and "ty" in \cref{fig:STLC-example}.
Extensible inductive types are not supported by \citet{zm2017}, so
we need further consideration about it on both implementation and
metatheory.

\textlabel{Req (3)}{langdesign-req3}: \textbf{we also want extensible
pattern matching and induction reasoning}, to extend "subst" in
\cref{fig:STLC-example}.
There are actually two kinds of ``pattern matching'', one for data and
the other for induction reasoning, i.e., one uses the eliminator to
\mintinline{Coq}{Set} or \mintinline{Coq}{Type}, and the other uses the
eliminator to \mintinline{Coq}{Prop}. Luckily, in this setting,
extensible pattern matching can be easily expressed with family
extension---we just aggregate all case handlers of pattern matching
into one family (as a bunch of functions), and then one family can
encode one pattern matching, and family inheritance can express adding
case handlers. Then we just need to introduce a primitive that will
``wrap'' that family into a recursive function. Induction reasoning can
be handled in an almost identical way. 

% we want to be able to reason pattern matching as well
However, there is still difference between data recursion and induction
reasoning, because the former one is \textit{proof-relevant}. This
difference leads to another issue: \textlabel{Req (4)}{langdesign-req4}:
\textbf{we need to reason about (the computation about) extensible
pattern matching}, just like "subst_lemma" in \cref{fig:STLC-example}.
When proving "subst_lemma", we have to know "subst" is invariant on
"tt", i.e., \mintinline{Coq}{(subst i x tt) = tt}. This kind of
information requires exposing \textit{computational rules} from the
recursors.\YZ{What goes wrong if subst is not invariant or you do not
know whether subst is invariant?}\EDJreply{Then it is unprovable because substitution lemma need to know this. You can just instantiate the whole lemma -- we want  
has_type (Γ; x ↦ A) tt T ->
has_type Γ u A ->
has_type Γ (subst i x tt) T. But this final goal requires to know the computation of subst.}

% we want tactic programming and certain level of automation
Finally, \textlabel{Req (5)}{langdesign-req5}: \textbf{we desire tactic
programming} to relieve us from the hassle of direct manipulation of proof terms.

\subsection{Language Design}
Inspired by our above requirements and Family Polymorphism, we propose the following extended syntax for Coq Vernacular Commands. 
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ident\rangle] 
  \quad |\quad "EndFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle~"using"~\langle ident\rangle \\
  & |\quad "Extend"~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Final" | "Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle
\end{align*}

We use "Family" and "EndFamily" to scope. Each field in one family is declared and defined by "Field". We can define nested family. Family will also be used to encode recursive handlers. Each case handling of one inductive type will be aggregated into one family, then "FRecursor" will be used to construct a recursor using these handlers. For example, \mintinline{Coq}{FRecursor recur about T motive f} "using" "handlers" will generate a new field "recur" that is doing induction (using elimination principle of "T") using motive "f", and the handlers are located in the family "handlers".

We can inherit a top level family "parent" using \mintinline{Coq}{Family ... extends parent} as a new top level family. As expected, "Override" will override/a field from the parent. "Inherit" can inherit nested family, inductive type and fields. The fields inside a family are order-sensitive because we have dependent type here. So "Inherit Until" is used if the user want to inherit a range of fields. If the user wants to extend an inductive type or a nested family from the parent, then "Extend FInductive" or "Extend Family" is used. Thus nested family can only be inherit or extended together with its outer family (and thus top level family), thus our support of family polymorphism is incomplete.

This incomplete support can already be helpful for extending functions. Take \cref{fig:plugin-example2} as example, if we want to extend boolean inductive type and its negation, we only need to specify the new constructor for boolean and how negation deal with the new constructor. This support provides the user a way to waive the necessity for duplicating code -- otherwise the user will need to copy and paste the whole original negation definition and add a new pattern matching cases.

