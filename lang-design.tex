We present the key ingredients of our design as an extension to the Coq
proof assistant,
though we believe the design could be adapted to other proof assistants such as Lean.
We call our design and implementation \Lang (\underline{f}amily
\underline{\smash{po}}lymorphism for a \underline{\smash{p}}roof assistant).
In this section, we focus on the language design of \Lang.
\cref{sec:coqimpl} describes its implementation as a Coq plugin.

\input{stlc-mechanized.tex}

\cref{fig:stlc-mechanized} shows how STLC and its extension with
fixpoints can be mechanized using \Lang, in a style envisioned in
\cref{fig:stlc-nonmechanized}.
The base family "STLC" hosts the STLC metatheories, from abstract syntax
to the type-safety theorem.
Family "STLCFix", derived from "STLC", makes adjustments as needed by a fixpoints extension:
it adds new constructors to the inductive types (\lsti{FInductive}) and
adds new cases to the recursive functions (\lsti{FRecursion}) and
induction proofs (\lsti{FInduction}).
Existing constructors and cases, as well as those definitions and
theorems that need no adjustments ("ty", "env", "empty", "steps", and
"typesafe"), are automatically inherited and reused.
In particular, executing the last command, \lsti{Check STLCFix.typesafe},
displays the type-safety theorem of the fixpoints extension.

\subsection{Extensible Inductive Types and Exhaustive Recursion/Induction}

\noindentparagraph{Extending inductive types.}

In family "STLCFix", inductive type "tm" \emph{further binds} the "tm" type
in family "STLC". It has five constructors: four inherited from
"STLC" and a fifth called "tm_fix".

Crucially, the meanings of \lsti{tm} and its constructors are
\emph{late bound}, depending on the family in which they are referenced.
Consider \lsti{tm_app}.
It is defined in family \lsti{STLC} and is thus unaware of \lsti{tm_fix}.
Yet in family \lsti{STLCFix}, we can use \lsti{tm_app} to construct
applications of fixpoints, as in
\lsti[mathescape]{tm_app (tm_fix "f" $t_1$) $t_2$}.
This use is justified by \lsti{tm_app}'s type,
\lsti[mathescape]{tm$\,$->$\,$tm$\,$->$\,$tm}.
It allows \lsti{tm_app} to be applied to anything of type \lsti{tm},
which in family "STLCFix" include those constructed from "tm_fix".


\noindentparagraph{Ensuring exhaustivity of induction.}

Ordinarily, an inductive type is not extensible: it is exhaustively
generated by its constructors and has no more inhabitants beyond those
they construct.
This idea is captured by the eliminator (aka \emph{recursor})
associated with an inductive type.
For example, if "tm" were defined as an ordinary inductive type, then
its eliminator would have the following type:

\begin{centered}
\begin{minipage}{.71\textwidth}
\newcommand\hlcase[1]{\tikzmarkin[disable rounded corners=true,set fill color=yellow!18,set border color=yellow!18]{#1}(0.00,-0.05)(-0.00,0.20)}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
tm_rect : \forall (P : tm -> Type), [@\hlcase{tm-recursor-case-unit}@]P tm_unit[@\tikzmarkend{tm-recursor-case-unit}@] -> [@\hlcase{tm-recursor-case-var}@](\forall x, P (tm_var x))[@\tikzmarkend{tm-recursor-case-var}@] ->
         [@\hlcase{tm-recursor-case-abs}@](\forall x t, P t -> P (tm_abs x t))[@\tikzmarkend{tm-recursor-case-abs}@] ->
         [@\hlcase{tm-recursor-case-app}@](\forall t1, P t1 -> \forall t2, P t2 -> P (tm_app t1 t2))[@\tikzmarkend{tm-recursor-case-app}@] -> \forall t, P t
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
The eliminator would enable function definitions by recursion
and proofs by induction, over "tm", that exhaustively
handle the four cases corresponding to each constructor.
The (dependent) return type~"P" is called the \emph{motive} of the recursion.
%Exhaustivity of induction would follow, trivially.

With inductive types made extensible, exhaustivity of induction becomes
in jeopardy, however.
In particular, recursor "tm_rect" should no longer be allowed, because
its type mentions "tm", whose meaning is late bound, yet
"tm_rect" purports to claim \lsti{\forall t, P t} given only four case handlers.

To reconcile the tension without requiring redefinition or rechecking of
case handlers~(\ref{chg:extensible-v-exhaustive}),
our design introduces the \lsti{FRecursion} and \lsti{FInduction} commands.
The key idea is to allow case handlers to be added retroactively, should
inductive types be extended, and to allow recursion and induction (which are defined in terms of case handlers) to be late bound.

As an example, consider the substitution function "subst", defined using
\lsti!FRecursion!.
The \lsti{on} clause specifies that recursion is over "tm".
The \lsti{motive} clause suggests that the recursive function being
defined has type \lsti{tm -> id -> tm -> tm}.
%
The "subst" function in "STLC" is further bound by the "subst" in "STLCFix":
the four cases from "STLC" are automatically inherited and reused,
with "STLCFix" retroactively adding a fifth case to form the new "subst" function.
%
For exhaustivity, it is a static error if the programmer fails to
further bind "subst" and define this fifth case.
The type system does this check in family \lsti{STLCFix}
by examining if the inductive type "tm",
over which "subst" is recursively defined, is further bound in the same family.

The \lsti{FInduction} command is similar to \lsti{FRecursion} but
allows cases to be defined in proof mode.
Consider "weakenlem" as an example.
It is proven by induction on the typing relation "hasty".
Its \lsti{motive} clause shows that the lemma reads as
\lstinline[basicstyle=\fontsize{8}{9}\ttfamily]!\forall G t T, hasty G t T -> \forall G', includedin G G' -> hasty G' t T!.

%\begin{centered}
%\begin{minipage}{.63\textwidth}
%\begin{lstlisting}[basicstyle=\fontsize{8}{9}\ttfamily]
%\forall G t T, hasty G t T -> \forall G', includedin G G' -> hasty G' t T.
%\end{lstlisting}
%\end{minipage}
%\end{centered}

\noindent
Upon entering case "ht_abs", for instance, Coq enters proof mode with the goal

\begin{centered}
\begin{minipage}{.635\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8}{9}\ttfamily]
\forall G', includedin G G' -> hasty G' (tm_abs x t) (ty_arrow T1 T2)
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
and with the induction hypothesis
\lstinline[basicstyle=\fontsize{8}{9}\ttfamily]!\forall G', includedin (extend G x T1) G' -> hasty G' t T2!.
%
The programmer can use tactic programming to discharge the goal.
%The idiomatic programming experience with Coq is largely preserved.
Because the lemma is by \lsti!FInduction! on "hasty" and because "STLCFix" adds
a constructor "ht_fix" to "hasty", the programmer is required in family "STLCFix" to
extend the proof of "substlem" to handle this extra case.


\subsection{Late Binding and Equalities}
\label{sec:latebind}

\noindentparagraph{Late binding of nested names.}

OO inheritance allows the late binding of method names.
Family polymorphism generalizes the power of OO inheritance by allowing the
late binding of all names nested within families, including those referring to types.
We have seen that late binding of "tm" allows the "tm" constructors in "STLC"
to be reused in "STLCFix" to construct terms containing "tm_fix".

As another example, consider the type of "st_beta" in family "STLC".
It refers to "subst", whose meaning is late bound.
When "st_beta" is inherited into family "STLCFix", "st_beta" has a type that now
refers to the "subst" function in "STLCFix", where "subst" is defined
by handling all the five cases known to that family.
Thus, late binding of "subst" allows the derived family to reuse "st_beta"
as the $\beta$-reduction rule for applications possibly constructed from "tm_fix".

Importantly, a name is late bound only within a family that defines or further binds it.
Outside such families, the name can be accessed only by explicitly
specifying a family that contains it.
For example, the last line of \cref{fig:stlc-mechanized} accesses "typesafe"
with a qualifier "STLCFix".
The command prints

\begin{centered}
\begin{minipage}{.880\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
STLCFix.typesafe: \forall t t' T, STLCFix.steps t t' -> STLCFix.hasty STLCFix.empty t T ->
                  STLCFix.value t' \/ \exists t'', STLCFix.step t' t''.
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
In this type, all references to nested names are qualified by "STLCFix", as desired.


\noindentparagraph{Equality on late bound names.}

Consider proving the "ht_unit" case of the substitution lemma, "substlem".
The goal is seemingly trivial: the programmer is asked to prove

\begin{centered}
\begin{minipage}{\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
\forall G' G x t' T', G' = extend G x T' -> hasty empty t' T' -> hasty G (subst tm_unit x t') ty_unit.
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
If "subst" were an ordinary Coq function, then the programmer could
discharge the goal with
\lsti{intros; simpl subst; apply ht_unit.}
The Ltac term \lsti{simpl subst} unfolds \lsti{subst} using its definition
and simplifies \lsti{subst tm_unit x t'} to \lsti{tm_unit}.

But with \lsti{subst} being late bound, \lsti{subst} cannot and should not
be unfolded~(\ref{chg:latebind-v-defeq}):
the definition of \lsti{subst}, as a recursive function,
varies across families, yet a derived family should be able to reuse the
proof of the \lsti{ht_unit} case
even when it has to modify the definition of \lsti{subst}.
Without the ability to unfold \lsti{subst},
how can the programmer make progress in this proof, then?

A key observation is that although late binding
prevents \emph{definitional equality} on \lsti{subst}, it does not
affect \emph{propositional equality}.
That is, \lsti{\forall x t, subst tm_unit x t = tm_unit},
as a proposition (\lsti{Prop}), should still hold.
After all, how \lsti{subst} is defined on \lsti{tm_unit} does not vary
from a base family to a derived family.
%\EDJ{I think the reviewer might ask : what if the subst late-bound tm_unit case/why the subst cases cannot be late-bound? it not necessary return tm_unit in those case. 
%\\ What the plugin generates is actually subst tm_unit x t = subst.tm_unit. In other words, it points back to the handler instead of the concrete constructor. That is one of the advantage of looking FRecursion as a family.}\YZreply{Currently the paper is taking the position that case handlers cannot be further bound, to make the story simpler.}
What varies is \lsti{subst} itself as a recursive function combining the case handlers.
%
Based on this insight, \Lang automatically generates
a propositional equality for each case handler defined within \lsti{FRecursion},
making the equalities and the recursive function available as axioms for use by the rest of the current family.
\Lang also provides a tactic \lsti{fsimpl} that enables, for instance,
simplifying \lsti{subst tm_unit x t'} to \lsti{tm_unit}.
Under the hood, \lsti{fsimpl} works by rewriting applications of the
axiomatized recursive function using the axiomatized propositional equalities.

Note that the definitional equality on \lsti{subst} is available
\emph{outside} those families that contain "subst".
Within those families, the meaning of \lsti{subst} is late bound
(i.e., polymorphic to the enclosing family), so only
propositional equality is available.
In contrast, outside those families, \lsti{subst} is always referenced
by specifying a family that contains it, %\EDJ{I think the reviewer without background of Family Polymorphism will be confused at this paragraph. i.e. Why inside family it is late-bound but not outside? }
as in \lsti{STLC.subst} and \lsti{STLCFix.subst}.
As far as the type checker is concerned, \lsti{tm_unit} and
\lsti{STLCFix.subst tm_unit x t'} are the same thing---the type checker
equates them definitionally by unfolding \lsti{STLCFix.subst} and
performing normalization.


\subsection{Overriding}
\label{sec:override}
%\noindentparagraph{Overriding.}

In an OO language, a subclass can override methods of a superclass.
Similar expressiveness is useful for metatheory mechanization, too.
%
For example, in a derived family, rather than adding new cases to an
induction proof, the programmer may prefer overriding the proof
entirely, as we observe in our case studies (\cref{sec:casestudies}).
%
Overriding is potentially incompatible with having equalities on late bound names, however.

Coq distinguishes \emph{opaque} definitions from \emph{transparent} ones.
\Lang supports the overriding of opaque definitions, which
include most proofs.
It is safe to override opaque definitions, because the type checker will
never attempt to unfold them.
For transparent definitions, the common case is that the programmer does
not want to override them.
In \cref{fig:stlc-mechanized}, "env", "empty", "subst", and "steps" are
transparent---that is, they are not defined with \lsti{Qed}.
\Lang treats transparent definitions as non-overridable by default.
Thus, the definitional equalities on "env", "empty", and "steps",
as well as the propositional equality on "subst", are available to the
type checker for type-checking the families.

\Lang does allow the overriding of transparent definitions
explicitly marked as \lsti{Overridable} by the programmer.
Overriding is made safe by requiring that when an overridable field is
overridden, code whose type checking involves unfolding that field
should be overridden too.
We expect this feature to be used occasionally.


\subsection{Sound Logical Reasoning}
\label{sec:sound}

%\noindentparagraph{Sound logical reasoning.}

In \cref{fig:stlc-mechanized}, just because the "typesafe" theorem in
"STLC" is inherited and reused by "STLCFix", it does not follow that
in "STLCFix" the programmer can use "typesafe" to prove "progress".
If the programmer did, then they would be committing the logical fallacy
of circular reasoning: the proof of "progress" would depend on "typesafe",
yet the proof of "typesafe" depends on "progress".
%
Such circularity would easily lead to logical inconsistency:
%\YZ{Mention non-exhaustivity/overriding already poses challenges to ensuring consistency.}

\begin{centered}
\definecolor{codecomment-color}{HTML}{556B2F}
\begin{minipage}{36ex}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
Family A.[@\tanc{A-inconsistency-start}@]
FLemma f : False. Proof. Admitted.
FLemma g : False. Proof. apply f. Qed.
End A.[@\tanc{A-inconsistency-end}@]
\end{lstlisting}
\end{minipage}
\makeline[22pt]{A-inconsistency-start}{A-inconsistency-end}[codecomment-color!50]
\hspace{3.5em}
\definecolor{codecomment-color}{HTML}{FF00FF}
\begin{minipage}{36ex}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
Family B extends A.[@\tanc{B-inconsistency-start}@]
FLemma f : False. Proof. apply g. Qed.
End B.[@\tanc{B-inconsistency-end}@]
[@~@]
\end{lstlisting}
\end{minipage}
\makeline[.5\textwidth+23pt]{B-inconsistency-start}{B-inconsistency-end}[codecomment-color!50]
\end{centered}

\noindent
In the program above, family~"B" extends~"A", overriding lemma~"f" by
proving it using lemma~"g".
Lemma~"g" is in turn inherited from family "A", where it is proven using
a late bound reference to lemma~"f".
Circularity between "f" and "g" allows proving \lsti{False}!

To ensure the soundness of logical reasoning (\ref{chg:self-v-consistency}),
the type system requires that in a derived family, the context in which
a field is defined be preserved from the base family.
In "STLC", "progress" is in the context of "typesafe".
Per the requirement, this relationship must be preserved into
"STLCFix", which prevents the proof of "progress" from depending on
"typesafe" in "STLCFix".

Note that the requirement still allows a derived family to introduce
new declarations into the context of a field. %\EDJ{Maybe a better wording is ``the relative order between fields are preserved during inheritance''?}
For example, the left column of \cref{fig:stlc-isorec-prod} shows an
extension of STLC with iso-recursive types, where "tysubst" is
introduced into the context of "hasty".
%
In the event that \Lang cannot infer where the programmer intends to place a new field,
annotation is required. 

\input{stlc-isorec-prod.tex}


\subsection{Composing Families as Mixins}

%\noindentparagraph{Composing families.}

Families can be readily reused to construct larger extensions that
\emph{mix in}~\cite{mixin-1990} the functionalities of the individual
families.
A family like \lsti{STLCFix} can be viewed as a family-to-family functor---%
and hence a mixin, in the sense of \cite{flatt1998mixin}---that
transforms any family providing the base STLC functionalities into a new
family additionally supporting fixpoints.
%\EDJ{I feel this paragraph will cause more confusion---because it is inheritance judgement/linkage transformer being mixed in, not family itself. Conceptually not distinguishing family and linkage transfomer will make reader wonder what this magic black box here actually is}

In \cref{fig:stlc-isorec-prod}, "STLCFixIsorec" is declared as
an "STLC" extension that mixes in "STLCFix" and "STLCIsorec".
The family is declared with minimal verbiage, yet
\lsti{STLCFixIsorec.typesafe} is automatically a proof of the type-safety
theorem of an STLC equipped with fixpoints and iso-recursive types.

Mixin composition is a form of multiple inheritance, which may lead to
name conflicts in general.
\Lang requires the programmer to resolve conflicts by
explicitly overriding conflicted fields.

In the presence of extensible inductive types, mixin composition may
also create an obligation to retrofit the mixins with new case handlers.
In \cref{fig:stlc-isorec-prod}, family "STLCProdIsorec" is composed
of two mixins: "STLCProd", which extends the inductive type "ty" with a
new constructor "ty_prod", and "STLCIsorec", which introduces a
function "tysubst" recursively defined on "ty".
Hence, for exhaustivity, it is required that a composition of
"STLCProd" and "STLCIsorec" should additionally handle the "ty_prod"
case in "tysubst".

%\YZ{
%Family IDENT.
%
%Family IDENT extends IDENT_0.
%
%Family IDENT extends IDENT_0 using IDENT_1, IDENT_2, ..., IDENT_n.
%
%Semantically, family IDENT is the composition λ IDENT_0. IDENT_n(…(IDENT_2(IDENT_1(IDENT_0)))…).
%
%IDENT_0 is called the immediate superfamily of IDENT.
%
%If the using-clause is present, then for each i > 0, IDENT_0 must be the same as, or a derived family of, the immediate superfamily of IDENT_i.
%
%If there is any name conflict among nested fields, then either the programmer has to resolve it or the composition is rejected upon attempting to close the family.
%}


\subsection{Injectivity and Disjointness of Constructors via Partial Recursors}

\noindentparagraph{Tactics support for constructors.}

Coq provides tactics for proving injectivity and disjointness of constructors
(i.e., \lsti{injection} and \lsti{discriminate}).
The proof terms generated by the tactics involve exhaustively
matching on the constructors of an inductive type, so
they do not work for extensible inductive types (\ref{chg:extensible-v-exhaustive}).
%
In principle, the programmer could use \lsti{FInduction} to prove
injectivity and disjointness.
But this workaround is unsatisfying:
it is tedious, it forces the programmer to revisit
the induction proofs every time an inductive type is extended,
and above all, why should a property like
\lsti{\neg(tm_var "x" = tm_abs "y" t)} have anything to do with "tm_fix"?

To provide a streamlined programming experience (\ref{chg:tooling}),
\Lang offers two tactics, \lsti{finjection} and \lsti{fdiscriminate}.
For example, in a proof state that contains a manifestly false assumption
\lsti{H : tm_var "x" = tm_abs "y" t}, the programmer can use
\lsti{fdiscriminate H} to obtain \lsti{False} and thus discharge
the current goal, just as they would with \lsti{discriminate H} if "tm"
were not extensible.


\noindentparagraph{Partial recursors.}

We make the observation
that injectivity and disjointness of existing constructors ought to hold
regardless of future addition of constructors.
%
This insight motivates the design of \emph{partial recursors}, which
power the \lsti{finjection} and \lsti{fdiscriminate} tactics.
Partial recursors are automatically generated for all inductive types
defined with \lsti{FInductive}.

As analyzed earlier, ordinary recursors, such as "tm_rect", are impossible
within a family in which the name of the inductive type is late bound.
However,
a key observation is that extensible inductive types still admit a
weakened elimination principle where the motive is an \lsti{option} type.
For example, within family "STLC", the partial recursor for
"tm" has the following type:

\begin{centered}
\begin{minipage}{.97\textwidth}
\newcommand\hlcase[1]{\tikzmarkin[disable rounded corners=true,set fill color=yellow!18,set border color=yellow!18]{#1}(0.00,-0.05)(-0.00,0.20)}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
tm_prect_STLC : \forall (P : tm -> Type), [@\hlcase{tm-partialrec-case-unit}@]option (P tm_unit)[@\tikzmarkend{tm-partialrec-case-unit}@] -> [@\hlcase{tm-partialrec-case-var}@](\forall x, option (P (tm_var x)))[@\tikzmarkend{tm-partialrec-case-var}@] ->
                [@\hlcase{tm-partialrec-case-abs}@](\forall x t, option (P t) -> option (P (tm_abs x t)))[@\tikzmarkend{tm-partialrec-case-abs}@] ->
                [@\hlcase{tm-partialrec-case-app}@](\forall t1, option (P t1) -> \forall t2, option (P t2) -> option (P (tm_app t1 t2)))[@\tikzmarkend{tm-partialrec-case-app}@] ->
                \forall t, option (P t)
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
As expected, "tm_prect_STLC" is axiomatized along with
four (propositional) equalities, one for each constructor of "tm".
For instance, the equality for constructor "tm_abs" is as follows:

\begin{centered}
\begin{minipage}{\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
tm_abs_eq_STLC: \forall x t P H1 H2 H3 H4,
                tm_prect_STLC P H1 H2 H3 H4 (tm_abs x t) = H3 x t (tm_prect_STLC P H1 H2 H3 H4 t)
\end{lstlisting}
\end{minipage}
\end{centered}

%\noindent
Importantly, unlike the standard "tm_rect" recursor, the partial recursor
"tm_prect_STLC" is compatible with the late binding of "tm" in its type.
When "tm_prect_STLC" is inherited into family "STLCFix", all the previous four equalities
still hold, and a trivial, fifth equality is made available:

\begin{centered}
\begin{minipage}{.88\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
tm_fix_eq_STLC : \forall x t P H1 H2 H3 H4, tm_prect_STLC P H1 H2 H3 H4 (tm_fix x t) = None
\end{lstlisting}
\end{minipage}
\end{centered}

Partial recursors appear weaker than ordinary recursors,
but there is power in restraint.
Partial recursors serve as extensional characterizations of inductive types allowing future extension.
In particular,
they offer a principled, uniform way to derive injectivity and disjointness of
constructors:
they enable injective mappings from a late bound inductive
type, like "tm", to an ordinary inductive type, like \lsti{\nat},
the injectivity and disjointness of whose constructors are readily
available.
%
For example, in a proof state with the assumption \lsti{H : tm_var "x" = tm_abs "y" t},
running \lsti{fdiscriminate H} first applies an injective mapping to
both sides of~\lsti{H}, obtaining

\begin{centered}
\begin{minipage}{.98\textwidth}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
tm_prect_STLC (\lambda[@\,@]_, \nat) (\lambda[@\,@]_, Some 1) (Some 2) (\lambda[@\,@]_[@\,@]_[@\,@]_, Some 3) (\lambda[@\,@]_[@\,@]_[@\,@]_[@\,@]_, Some 4) (tm_var "x") =
tm_prect_STLC (\lambda[@\,@]_, \nat) (\lambda[@\,@]_, Some 1) (Some 2) (\lambda[@\,@]_[@\,@]_[@\,@]_, Some 3) (\lambda[@\,@]_[@\,@]_[@\,@]_[@\,@]_, Some 4) (tm_abs "y" t)
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
and then rewrites the above equality using two of the axiomatized
equalities about "tm_prect_STLC",
%(namely "tm_var_eq_STLC" and "tm_abs_eq_STLC"),
obtaining \lsti{Some 1 = Some 4},
from which \lsti{False} easily follows.

Note that the proof term generated by \lsti{fdiscriminate H} in "STLC"
is reusable by family "STLCFix", because the partial recursor and its
equalities are compatible with the late binding of "tm".
Also note that within family "STLCFix", a second partial recursor
(called "tm_prect_STLCFix") and its equalities are available,
allowing properties about "tm_fix",
such as \lsti{\neg(tm_var "x" = tm_fix "y" t)}, to be proved.

%\noindentparagraph{Limitations.}


\ifShowOldWriting

\newpage

Inspired by the above challenges and Family Polymorphism, we propose
the following extension to Coq's Vernacular Commands, and the corresponding STLC example.
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ref\rangle] 
  \quad |\quad "EndFamily" \quad | \quad "SealFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ref\rangle~"motive"~\langle term\rangle~"using"~\langle ref\rangle \\
  & |\quad "FScheme CompEq about"~\langle ref \rangle~|\quad "FScheme " \langle ident\rangle " PRecT about"~\langle ref \rangle\\
  & | \quad "FTheorem"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle \\
  & |\quad ["Extend"]~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Overridable " ["pins " \{ \langle ident\rangle ... \}]]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & |\quad ["Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "FieldClaim"~\langle ident\rangle~":"~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle \quad \\
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\ 
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~"by"~"\{"\langle \text{one tactic expression}\rangle"\}" \\ 
  & | \quad "Family"~\langle ident\rangle~"extends"~\langle ref\rangle~"using"~\langle ref\rangle~"using"~\langle ref\rangle \\ 
  & | \quad "MetaData"~\langle ident\rangle \quad | \quad "EndMetaData" \\ 
\end{align*}

\textbf{Family and Defining Fields.} These are the core extensions we proposed to support \cref{fig:STLC-example}, and we adapt them into \cref{fig:STLC-example2}. We use "Family" and "EndFamily" to scope. "Field" is used to define new members in a family. "FieldClaim" is similar as "Field" but will invoke proof-mode in Coq and thus the user can use tactic programming to define new members.\footnote{We expect "FieldClaim" to be used in a \textit{proof-irrelevant} situation and thus whether overridable or not doesn't matter.} Both "Field" and "FieldClaim" are only allowed to refer to the former fields, to avoid possible inconsistency mentioned in \ref{chg:self-v-consistency}.
Nested families are also allowed. 


The user can use "self__A.<path>" to access the former defined fields inside a surrounding defining "Family A".\footnote{Note that, in most of our examples in the paper, these "self__" prefix is too long and verbose so we omitted them.} Note that, "self__A" is only visible in the Vernacular commands from our plugin.\footnote{(In other words, using "Definition" from Coq will not invoke the plugin to prepare "self__A" to be accessible---most original Vernacular command from vanilla Coq will not do such preparation.)}  Once the user closes a \textbf{top} family with "EndFamily", they can access the fields of the closed family by using module syntax. For example, they can access "A.a" to get "1" after "Family A" is defined. This "A" is truly accessible anywhere by vanilla Coq without any plugin preparation, just like a mundane module.

Most programming experiences are preserved from Coq---each term inside the field definition is a well-typed Gallina term in vanilla Coq. Note that, a Family is not a first class value and thus we need to project out the Gallina terms from them.

% Inheritance here
\textbf{Inheritance on Fields.} "Family A extends B" has to appear at
the top level (not inside any Family) and will start to construct the
children "Family B" given the parent "Family A". Every field inside the
derived family will be one of the three kinds of
``inheritance''---extending, overriding, and inheriting.
The syntax of extending a new field is to directly use "Field", while
overriding requires a prefix of "Override" before "Field f : .." and
"Inherit f" will inherit field "f" from the parent. 

To resolve \ref{chg:self-v-consistency}, we make sure when inheriting or
overriding on "f" happens, the context of the field "f" is also
``inherited''. Thus the mentioned informal example in
\ref{chg:self-v-consistency} will not apply here, because the overriding "f" is
in a context where "self" is empty thus "self.g" doesn't
type-check. Thus, before we inherit "g", the dependee "f" needs to be
inherited.  


\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq, escapeinside={@}{@}]
Family I.
 Field a : nat := 1.
 Field b : a = 1 := eq_refl.
 Overridable Field a' : nat := 1.
 Fail Field c : a' = 1 := eq_refl. (* Fail 1*)
 Overridable Field f : nat -> nat := non_impl.
 Overridable 
  Field p : monotonic f := non_impl.
EndFamily.
\end{lstlisting}
  \end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family I2 extends I.
 
 Inherit Field b.
 Override Field a' : nat := 2.  (* Override *)

 Override Field f : nat -> nat := (+ 1).
 Override pins {f} 
  Field p : monotonic f := ...
 EndFamily. 
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example Code for Inheritance and Reasoning}\label{fig:plugin-example3}
\end{figure}


% % Talk about Final
% \textbf{Final as non-overridable.} Every field is by default
% overridable, reminding us of \ref{chg:latebind-v-defeq}.  To
% resolve it, we provide the keyword "Final" to allow the user to specify
% \textit{non-overridability} and give the user the opportunity to choose
% from overriding and exposing the definition.

% Take the field "c" of "Family I" in \cref{fig:plugin-example3} as an 
% example. We can see that the first attempt of proving "a = 1" fails.
% This should fail---because we want to retain the possibility
% to override "a" and inheriting "c" in the future, but they are
% conflicting, since "c" witnesses that "a" is fixed to "1". On the other
% hand, once we decorate \lstinline{a'} as final, the second attempt
% \lstinline{c : a' = 1 := eq_refl} will succeed. Contrary to "a",
% our \lstinline{a'} is not overridable in "Family I2", mediating the
% \ref{chg:latebind-v-defeq}.

% This example might sound trivial and contrived. Let's look at the
% example field binary operation "bop" initially set to be addition.
% Now that we only expose the type of "bop", we
% cannot prove its commutativity in "comm_bop" (because we don't have
% access to its concrete definition) but we can override "bop" with
% subtraction function in "Family I2". This makes sense because we
% shouldn't (have the ability to) inherit commutativity property for
% subtraction anyway. This is contrary to how \lstinline{a'} is declared
% "Final": the second "c" can prove that it's equal to 1 but
% \lstinline{a'} is not overridable in the "Family I2". 

% In our example, the seal family "I.MonotonicF" is actually simulating
% interfaces as well.  We have
% \mbox{``\mintinline{Coq}{Axiom non_impl : forall {T : Type}, T.}''},
% and we assigned it to both "f" and "p", and later instantiate in
% "I2" with concrete implementation by overriding this family
% "I.MonotonicF".

% \textbf{Overridable/Sealed Family as better Sigma Type.} Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

% Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

\textbf{Overridable Fields with dependency.}  Each field is by default non-overridable. By the discussion of \ref{chg:latebind-v-defeq}, we can simply reason and access the definition about the former fields in a later field, just like Field "a" and "b" in \cref{fig:plugin-example3} and we lose the ability to override. 

However, overridability is useful especially in Coq as programs in Coq are runnable. Consider the sceanrio when we use arbitrary monotonic function as field members \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}, and we make sure that all the following reasoning are only about the monotonicity. Then it should be allowed to swap the implementation of that monotonic function via overriding. 

To resolve, we introduce overridable fields. Each overridable field will only expose its type instead of the concrete definition to the following default (non-overridable) fields. For example, the first failure in \cref{fig:plugin-example3} per the discussion of \ref{chg:latebind-v-defeq}: since overridability will break the inheritability of "c" and thus we don't allow such field to exist in the first place. Our plugin will only expose the fact that "a'" is an arbitrary natural number but hiding its concrete definition, and thus "eq_refl" will fail to type-check.

In this stage, this feature is yet too weak since we cannot do definitional-relevant reasoning about overridable fields, like field "c" in the first failure. Thus we introduce \textit{dependency} between overridable fields---in the syntax of \mintinline{Coq}{Overridable pins {x,y,...} Field f := fexp}. In this case, field "f" will depend on the (overridable) field "x,y,...", and semantically, this means the concrete definition of "x,y,..." is \textit{exposed} to "fexp" during the type checking of "fexp". Every overridable field can only depend on former \textit{overridable} and \textit{definition-transparent} (non-"Qed"-Coq-term) fields. 

To override an overridable field, we use the syntax \\ \mintinline{Coq}{Override [pins {x',y',...}] Field f := fexp'} in the definition of the children family. We can change the dependency \textbf{arbitrarily} in the children family if we want, just by specifying the new "pins" component and there is no restriction on the "x',y',..." we choose. The only restriction is that the overriden "f" has to have the same type as the parent field "f". 

However, if we want to inherit any overridable field in the children family, we need to make sure every dependent (overridable) field is \textit{inherited instead of overridden} in the children family. That means, every overriding will lead to a chain of overriding on the depender fields. This coincides with our intuition about the example---when the dependee monotonic function is overridden, the proof about its monotonicity needs to be changed accordingly. 
Look at the field "f" and "p" in \cref{fig:plugin-example3} in both families. Both fields are initially filled with place-holder in the parent family, but then in children family "I2", "f" is overridden by "(+ 1)" and then to prove its monotonicity, we need to expose the concrete definition of "f" and thus we need to \textit{newly} pins "f" when providing the overriding "p".




% if the user wants a given field to be non-overridable. We will later elaborate its detail application.

\textbf{Inheritance on Nested Families.} We also provide extending,
inheriting and overriding for nested family (member). Extension is done
by simply declaring a nested family; the same syntax for inheriting a
field is used in inheriting a family. However, overriding is
special---overriding can only apply to \textit{sealed} nested family in
the parent family. A family is sealed when using "SealFamily" as the
scoping instead of "EndFamily". We will later elaborate the motivation
and details of sealed family.

% Currently, every sealed family can only be direct inherited or overridden as a whole. It cannot be extended.

\textbf{Extensible Inductive Type.} We provide the keyword "FInductive"
to enable extensible inductive type. "Extend FInductive" is used to
support extension of the parent inductive type inside a children family.
The syntax of these two is close to the mundane "Inductive" keyword. 

Unlike how Coq's "Inductive" will automatically generate the eliminator for the inductive type, we require the user to explicit use "FScheme .. PRecT" to generate a \textit{partial recursor} for the "FInductive". We will later explain what a partial recursor is, at this point the reader can just consider it as a mundane eliminator. 


To resolve \ref{chg:extensible-v-exhaustive}, our first step is to
\textit{decouple} the definition of recursor handlers and the checking
of exhaustiveness. The users will define recursive handlers for one
inductive type by aggregating the (function) handlers into one family.
Then
"FRecursor" will be used to construct a recursor by referring to the handler family.
\mintinline{Coq}{FRecursor recur about T motive f } "using"
"handlers" will generate a new field "recur" that is really doing computation
(using elimination principle of the inductive type "T") with motive "f". The handlers
are located in the family "handlers", similar to a large pattern-matching statement. This way, the reuse and the extension of the case handlers will be delegated by the inheritance of the family. Once recursor is created it will look like any other function fields(e.g. "subst" in \cref{fig:STLC-example2}).




"FTheorem" has a similar functionality but is expected to be used for
theorem proving---the handler and the family will be automatically
constructed during proving.

% Explain FScheme
However, "FRecursor" doesn't specify any reduction/computation information until a family is defined completely and closed (e.g. "subst" in \cref{fig:STLC-example2} cannot reduce when application during the definition of the surrounding family). To remedy this, we introduce "FScheme CompEq" that will generate proposition of equations indicating reductions. For example, for "subst", it will generate the equation
\mintinline{Coq}{subst tm_unit = subst_internal.tm_unit}. 

Similarly, the generated partial recursor using "FScheme .. PRecT" doesn't have computation information either, and require "FScheme CompEq" to generate them.

 

% We can also use "Family" and "SealFamily" to scope a (nested) family. The resulting family only support direct inheritance or "Override" (i.e. we can only override a sealed family as a whole together)---we will later explain this design decision and its usage, especially on resolving \ref{chg:latebind-v-defeq}. What's more, "Override" family can only apply to sealed family as well (not allowed on normal family).

% We can inherit a top-level family "parent" using \mintinline{Coq}{Family ... extends parent} as a new top-level family. As expected, "Override"
% will override a field from the parent. "Inherit" can be used to inherit
% nested families, inductive types, and fields. "Final" is used to claim that the decorated field is non-overridable, and later we will show how it is used to resolve \ref{chg:latebind-v-defeq}. The fields inside a family
% are order-sensitive because we have dependent types here. So "Inherit
% Until" is used if the user wants to inherit a range of fields.  "Extend Family" is used only inside a inheriting family. Thus nested
% family can only be inherited or extended together with its belonging family
% (i.e. ultimately top level family), thus our support of family polymorphism is
% incomplete.

We will explain the usage of "Closing Fact" and "MetaData" later---they are \textit{escape-hatches} to resolve \ref{chg:tooling} to some extent.
% This incomplete support can already be useful for extending functions.
% Take \cref{fig:plugin-example2} as example, if we want to extend boolean
% inductive type and its negation, we only need to specify the new
% constructor for boolean and how negation deals with the new constructor.
% As a result, the programmer does not have to duplicate code---otherwise
% the user will need to copy and paste the whole original negation
% definition and add a new pattern matching case.


% Explain Mixin

Finally, \textbf{Mixin.} For two children family with the same parent family, we support mixin the two using "Family ... extends ... using ... using ...". (In this case, it is better to consider the children family itself as \textit{an inheritance object}.) However, the candidates for mixin cannot have any overriding term (i.e. only allow inheritance and extension).  

\fi