We use a plugin to the Coq proof assistant to demonstrate the key
ingredients of our design,
though we believe our design could be adapted to other proof assistants such as Lean.

\input{stlc-mechanized.tex}

\cref{fig:stlc-mechanized} shows how STLC and its extension with
fixpoints can be mechanized using our plugin, in a style envisioned in
\cref{fig:stlc-nonmechanized}.
The base family "STLC" hosts the STLC metatheories, from abstract syntax
to the type-safety theorem.
Family "STLC_fix", derived from "STLC", makes adjustments as needed by a fixpoints extension:
it adds new constructors to the inductive types (\lsti{FInductive}) and
adds new cases to the recursive functions (\lsti{FRecursion}) and
induction proofs (\lsti{FInduction}).
Existing constructors and cases, as well as those definitions and
theorems that need no adjustments ("ty", "env", "empty", "steps", and
"typesafe"), are automatically inherited and reused.
For example, executing the last line, \lsti{Check STLC_fix.typesafe}, will
display the type-safety theorem of the fixpoints extension.


\noindentparagraph{Extending inductive types.}

In family "STLC_fix", inductive type "tm" \emph{further binds} the "tm" type
in family "STLC". It is generated by five constructors: four inherited from
"STLC" and a fifth called "tm_fix".

Crucially, the types of the constructors are polymorphic to their enclosing family---%
their meaning is \emph{late bound}.
For example, although "tm_app" is defined in the base family,
it can be used to construct applications of fixpoints in the derived family:
%such as \lsti[mathescape]{tm_app (tm_fix "f" (tm_abs "x" $\dadada$)) tm_unit},
its type \lsti{tm -> tm -> tm} says "tm_app" can be applied to any
Gallina terms of type "tm",
which in family "STLC_fix" include those constructed from "tm_fix".


\noindentparagraph{Ensuring exhaustivity of induction.}

Ordinarily, an inductive type is not extensible: it is exhaustively
generated by its constructors and has no more inhabitants beyond those
they construct.
This idea is captured by the eliminator (aka recursor) associated with
an inductive type.
For example, if "tm" were defined as an ordinary inductive type, then
its eliminator would have the following type:

\begingroup
\newcommand\hlcase[1]{\tikzmarkin[disable rounded corners=true,set fill color=yellow!18,set border color=yellow!18]{#1}(0.00,-0.05)(-0.00,0.20)}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
\forall (P : tm -> Type), [@\hlcase{tm-recursor-case-var}@](\forall x, P (tm_var x))[@\tikzmarkend{tm-recursor-case-var}@] -> [@\hlcase{tm-recursor-case-unit}@]P tm_unit[@\tikzmarkend{tm-recursor-case-unit}@] -> [@\hlcase{tm-recursor-case-abs}@](\forall x t, P t -> P (tm_abs x t))[@\tikzmarkend{tm-recursor-case-abs}@] ->
  [@\hlcase{tm-recursor-case-app}@](\forall t1 t2, P t1 -> P t2 -> P (tm_app t1 t2))[@\tikzmarkend{tm-recursor-case-app}@] -> \forall t, P t
\end{lstlisting}
\endgroup

\noindent
The eliminator would allow for function definitions by recursion
and proofs by induction, over "tm", that exhaustively
handle the four cases corresponding to each constructor.
The (dependent) return type~"P" is called the \emph{motive} of the recursion.
%Exhaustivity of induction would follow, trivially.

With inductive types made extensible, exhaustivity of induction becomes
in jeopardy, however.
To reconcile the tension without requiring redefinition or rechecking of
case handlers (challenge \ref{chg:extensible-v-exhaustive}),
our design introduces the \lsti{FRecursion} and \lsti{FInduction} commands.
The key idea is to allow case handlers to be added retroactively, should
inductive types be extended, and to allow recursion and induction (which are defined in terms of case handlers) to be late bound.

As an example, consider the substitution function "subst", defined using
\lsti!FRecursion!.
The \lsti{on} clause specifies that recursion is over "tm".
The \lsti{motive} clause suggests that the recursive function being
defined has type \lsti{tm -> id -> tm -> tm}.
%
The "subst" function in "STLC" is further bound by the "subst" in "STLC_fix":
the four cases from "STLC" are automatically inherited and reused,
with "STLC_fix" retroactively adding a fifth case to form the new "subst" function.
%
For exhaustivity, it is a static error if the programmer fails to
further bind "subst" and define this fifth case.
The type system does this check by examining if the inductive type "tm",
over which "subst" is recursively defined, is further bound in the same family.

The \lsti{FInduction} command is similar to \lsti{FRecursion} but
allows cases to be defined in proof mode.
Consider "weakenlem" as an example.
It is proven by induction on the typing relation "hasty".
Its \lsti{motive} clause suggests that the lemma reads as

\begin{lstlisting}[basicstyle=\fontsize{8}{9}\ttfamily]
\forall G t T, hasty G t T -> \forall G', includedin G G' -> hasty G' t T.
\end{lstlisting}

\noindent
Upon entering case "ht_abs", for instance, Coq enters proof mode with the goal

\begin{lstlisting}[basicstyle=\fontsize{8}{9}\ttfamily]
  \forall ...
\end{lstlisting}

\noindent
The programmer can use tactic programming to discharge the goal.
%The idiomatic programming experience with Coq is largely preserved.
Because the lemma is by induction on "hasty" and because "STLC_fix" adds
a constructor to "hasty", the programmer is required to handle this extra case
in the proof of "substlem" in family "STLC_fix".


\noindentparagraph{Late binding of nested names.}

OO inheritance allows the late binding of method names.
Family polymorphism generalizes the power of OO inheritance by allowing the
late binding of all names nested within families, including those referring to types.
We have seen that late binding of "tm" allows the "tm" constructors in "STLC"
to be reused in "STLC_fix" to construct terms containing "tm_fix".

As another example, consider the type of "st_beta" in family "STLC".
It refers to "subst", whose meaning is late bound.
When "st_beta" is inherited into family "STLC_fix", "st_beta" has a type that now
refers to the "subst" function in "STLC_fix", where "subst" is defined
by handling all the five cases known to that family.
Thus, late binding of "subst" allows the derived family to reuse "st_beta"
to $\beta$-reduce abstractions whose body is a fixpoint.

Importantly, a name is late bound only within a family that defines or extends it.
Outside such families, the name can be accessed only by explicitly
specifying a family that contains it.
For example, the last line of \cref{fig:stlc-mechanized} accesses "typesafe"
with "STLC_fix.typesafe".
Executing the command prints

\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
STLC_fix.typesafe: \forall t t' T, STLC_fix.steps t t' -> STLC_fix.hasty STLC_fix.empty t T ->
                   STLC_fix.value t' \/ \exists t'', STLC_fix.step t' t''.
\end{lstlisting}

\noindent
In this type, all references to nested names are qualified by "STLC_fix", as desired.


\noindentparagraph{Equality on late bound names.}

Consider proving the "ht_unit" case of the substitution lemma, "substlem".
The goal is seemingly trivial: the programmer is asked to prove

\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
\forall G' G x t' T', G' = extend G x T' -> hasty empty t' T' -> hasty G (subst tm_unit x t') ty_unit.
\end{lstlisting}

\noindent
If "subst" were an ordinary Coq function, then the programmer could
discharge the goal with
\lsti{intros; simpl subst; apply ht_unit.}
The Ltac term \lsti{simpl subst} unfolds \lsti{subst} using its definition
and simplifies \lsti{subst tm_unit x t'} to \lsti{tm_unit}.

However, with \lsti{subst} being late bound, \lsti{subst} can no longer
be unfolded (challenge~\ref{chg:latebind-v-defeq}):
the definition of \lsti{subst}, as a recursive function,
varies across families, yet a derived family should be able to reuse the
proof of the \lsti{ht_unit} case
even when it has to modify the definition of \lsti{subst}.
Without the ability to unfold \lsti{subst},
how can the programmer make progress in this proof, then?

A key observation is that although late binding
prevents \emph{definitional equality} on \lsti{subst}, it does not
affect \emph{propositional equality}.
That is, \lsti{subst tm_unit x t' = tm_unit}, as a proposition
(\lsti{Prop}), can still be proved.
After all, how \lsti{subst} is defined on \lsti{tm_unit} does not vary
from a base family to a derived family.
%
Based on this insight, our plugin automatically generates and proves
propositional equalities for recursive functions defined with \lsti{FRecursion}.
The plugin also provides a tactic \lsti{fsimpl} that enables, for instance,
simplifying \lsti{subst tm_unit x t'} to \lsti{tm_unit}.
Under the hood, \lsti{fsimpl} works by rewriting using the generated
propositional equalities.

Note that the definitional equality on \lsti{subst} is available
outside those families that contain "subst".
Within those families, the meaning of \lsti{subst} is late bound.
In contrast, outside those families, \lsti{subst} can be referenced only
by specifying a family that contains it,
such as \lsti{STLC.subst} or \lsti{STLC_fix.subst}.
So as far as Coq's type checker is concerned, \lsti{tm_unit} and
\lsti{STLC_fix.subst tm_unit x t'} are the same thing---Coq equates them
definitionally by unfolding \lsti{STLC_fix.subst} and performing
$\beta$-reduction.

\noindentparagraph{Overriding.}

In an OO language, a subclass can override methods of a superclass.
Similar expressiveness is useful for metatheory mechanization, too.
%
For example, in a derived family, the programmer may want to override
the proof of a lemma with a different proof strategy than it was proved
in the base family.
%
Overriding is potentially in conflict with having equalities on late bound names.

Coq distinguishes \emph{opaque} definitions from \emph{transparent} ones.
Our plugin supports the overriding of opaque definitions, which
include most proofs.
It is safe to override opaque definitions, because Coq will never attempt to unfold them.
For transparent definitions, the common case is that the programmer does
not want to override them.
In \cref{fig:stlc-mechanized}, "env", "empty", "subst", and "steps" are
transparent---that is, they are not defined with \lsti{Qed}.
Our plugin treats transparent definitions as non-overridable by default.
Thus, the definitional equalities on "env", "empty", and "steps",
as well as the propositional equality on "subst", are available to the
type checker for type-checking the families.

Our plugin does allow the overriding of transparent definitions that are
explicitly marked as \lsti{Overridable} by the programmer.
Overriding is made safe by requiring that when an overridable field is
overridden, code whose type checking requires unfolding that field
should be overridden too.
We give an example in a supplemental appendix.


\noindentparagraph{Sound logical reasoning.}

In \cref{fig:stlc-mechanized}, just because the "typesafe" theorem in
"STLC" is inherited and reused by "STLC_fix", it does not follow that
in "STLC_fix" the programmer can use "typesafe" to prove "progress".
If the programmer did, then they would be committing the logical fallacy
of circular reasoning: the proof of "progress" would depend on "typesafe",
yet the proof of "typesafe" depends on "progress".
%
Such circularity would easily lead to logical inconsistency:

\begin{centered}
\begin{minipage}{36ex}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
Family A.
FLemma f : False. Proof. Admitted.
FLemma g : False. Proof. apply f. Qed.
End A.
\end{lstlisting}
\end{minipage}
\hspace{3.5em}
\begin{minipage}{36ex}
\begin{lstlisting}[basicstyle=\fontsize{8.25}{9}\ttfamily]
Family B extends A.
FLemma f : False. Proof. apply g. Qed.
End A.
[@~@]
\end{lstlisting}
\end{minipage}
\end{centered}

\noindent
In the program above, family~"B" extends~"A", overriding lemma~"f" by
proving it using lemma~"g".
Lemma~"g" is in turn inherited from family "A", where it is proven using
a late bound reference to lemma~"f".
Circularity between "f" and "g" allows proving \lsti{False}!

To ensure the soundness of logical reasoning, the type system requires
that in a derived family, the context in which a field is defined be
preserved from the base family.
In "STLC", "progress" is in the context of "typesafe".
Per the requirement, this relationship must be preserved into
"STLC_fix", which prevents the proof of "progress" from depending on
"typesafe" in "STLC_fix".

Note that the requirement still allows a derived family to introduce
new dependencies into the context of a field.
For example, consider an extension of STLC with iso-recursive types
(left column of \cref{fig:stlc-isorec-prod}).
Family "STLC_isorec" introduces "tysubst" into the context of "hasty".
\input{stlc-isorec-prod.tex}

\noindentparagraph{Composing families.}

\noindentparagraph{Tactics for eliminating inductive types.}


\noindentparagraph{Limitations.}

\newpage




Inspired by the above challenges and Family Polymorphism, we propose
the following extension to Coq's Vernacular Commands, and the corresponding STLC example.
% basically write down the specification of surface Coq commandline
%   and then explain  how the language design makes the programmer’s life easier
\begin{align*}
  V := \quad &"Family"~\langle ident\rangle~["extends"~\langle ref\rangle] 
  \quad |\quad "EndFamily" \quad | \quad "SealFamily" \\
  & |\quad "FRecursor"~\langle ident\rangle~"about"~\langle ref\rangle~"motive"~\langle term\rangle~"using"~\langle ref\rangle \\
  & |\quad "FScheme CompEq about"~\langle ref \rangle~|\quad "FScheme " \langle ident\rangle " PRecT about"~\langle ref \rangle\\
  & | \quad "FTheorem"~\langle ident\rangle~"about"~\langle ident\rangle~"motive"~\langle term\rangle \\
  & |\quad ["Extend"]~"Family"~\langle ident\rangle \\ 
  & |\quad ["Extend"]~"FInductive"~\langle ident\rangle \\ 
  & |\quad ["Overridable " ["pins " \{ \langle ident\rangle ... \}]]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & |\quad ["Override"]~"Field"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\
  & | \quad "FieldClaim"~\langle ident\rangle~":"~\langle term \rangle \\
  & | \quad "Inherit"~\langle ident\rangle \quad | \quad "Inherit Until"~\langle ident\rangle \quad \\
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~":="~\langle term \rangle \\ 
  & | \quad "Closing Fact"~\langle ident\rangle~":"~\langle term \rangle~"by"~"\{"\langle \text{one tactic expression}\rangle"\}" \\ 
  & | \quad "Family"~\langle ident\rangle~"extends"~\langle ref\rangle~"using"~\langle ref\rangle~"using"~\langle ref\rangle \\ 
  & | \quad "MetaData"~\langle ident\rangle \quad | \quad "EndMetaData" \\ 
\end{align*}

\textbf{Family and Defining Fields.} These are the core extensions we proposed to support \cref{fig:STLC-example}, and we adapt them into \cref{fig:STLC-example2}. We use "Family" and "EndFamily" to scope. "Field" is used to define new members in a family. "FieldClaim" is similar as "Field" but will invoke proof-mode in Coq and thus the user can use tactic programming to define new members.\footnote{We expect "FieldClaim" to be used in a \textit{proof-irrelevant} situation and thus whether overridable or not doesn't matter.} Both "Field" and "FieldClaim" are only allowed to refer to the former fields, to avoid possible inconsistency mentioned in \ref{chg:self-v-consistency}.
Nested families are also allowed. 


The user can use "self__A.<path>" to access the former defined fields inside a surrounding defining "Family A".\footnote{Note that, in most of our examples in the paper, these "self__" prefix is too long and verbose so we omitted them.} Note that, "self__A" is only visible in the Vernacular commands from our plugin.\footnote{(In other words, using "Definition" from Coq will not invoke the plugin to prepare "self__A" to be accessible---most original Vernacular command from vanilla Coq will not do such preparation.)}  Once the user closes a \textbf{top} family with "EndFamily", they can access the fields of the closed family by using module syntax. For example, they can access "A.a" to get "1" after "Family A" is defined. This "A" is truly accessible anywhere by vanilla Coq without any plugin preparation, just like a mundane module.

Most programming experiences are preserved from Coq---each term inside the field definition is a well-typed Gallina term in vanilla Coq. Note that, a Family is not a first class value and thus we need to project out the Gallina terms from them.

% Inheritance here
\textbf{Inheritance on Fields.} "Family A extends B" has to appear at
the top level (not inside any Family) and will start to construct the
children "Family B" given the parent "Family A". Every field inside the
derived family will be one of the three kinds of
``inheritance''---extending, overriding, and inheriting.
The syntax of extending a new field is to directly use "Field", while
overriding requires a prefix of "Override" before "Field f : .." and
"Inherit f" will inherit field "f" from the parent. 

To resolve \ref{chg:self-v-consistency}, we make sure when inheriting or
overriding on "f" happens, the context of the field "f" is also
``inherited''. Thus the mentioned informal example in
\ref{chg:self-v-consistency} will not apply here, because the overriding "f" is
in a context where "self" is empty thus "self.g" doesn't
type-check. Thus, before we inherit "g", the dependee "f" needs to be
inherited.  


\begin{figure}[!htb]
  \begin{minipage}[t]{0.47\linewidth}
\begin{lstlisting}[language=Coq, escapeinside={@}{@}]
Family I.
 Field a : nat := 1.
 Field b : a = 1 := eq_refl.
 Overridable Field a' : nat := 1.
 Fail Field c : a' = 1 := eq_refl. (* Fail 1*)
 Overridable Field f : nat -> nat := non_impl.
 Overridable 
  Field p : monotonic f := non_impl.
EndFamily.
\end{lstlisting}
  \end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\begin{lstlisting}[language=Coq,  escapeinside={@}{@}]
Family I2 extends I.
 
 Inherit Field b.
 Override Field a' : nat := 2.  (* Override *)

 Override Field f : nat -> nat := (+ 1).
 Override pins {f} 
  Field p : monotonic f := ...
 EndFamily. 
EndFamily.
\end{lstlisting}
  \end{minipage}
  \caption{Example Code for Inheritance and Reasoning}\label{fig:plugin-example3}
\end{figure}


% % Talk about Final
% \textbf{Final as non-overridable.} Every field is by default
% overridable, reminding us of \ref{chg:latebind-v-defeq}.  To
% resolve it, we provide the keyword "Final" to allow the user to specify
% \textit{non-overridability} and give the user the opportunity to choose
% from overriding and exposing the definition.

% Take the field "c" of "Family I" in \cref{fig:plugin-example3} as an 
% example. We can see that the first attempt of proving "a = 1" fails.
% This should fail---because we want to retain the possibility
% to override "a" and inheriting "c" in the future, but they are
% conflicting, since "c" witnesses that "a" is fixed to "1". On the other
% hand, once we decorate \lstinline{a'} as final, the second attempt
% \lstinline{c : a' = 1 := eq_refl} will succeed. Contrary to "a",
% our \lstinline{a'} is not overridable in "Family I2", mediating the
% \ref{chg:latebind-v-defeq}.

% This example might sound trivial and contrived. Let's look at the
% example field binary operation "bop" initially set to be addition.
% Now that we only expose the type of "bop", we
% cannot prove its commutativity in "comm_bop" (because we don't have
% access to its concrete definition) but we can override "bop" with
% subtraction function in "Family I2". This makes sense because we
% shouldn't (have the ability to) inherit commutativity property for
% subtraction anyway. This is contrary to how \lstinline{a'} is declared
% "Final": the second "c" can prove that it's equal to 1 but
% \lstinline{a'} is not overridable in the "Family I2". 

% In our example, the seal family "I.MonotonicF" is actually simulating
% interfaces as well.  We have
% \mbox{``\mintinline{Coq}{Axiom non_impl : forall {T : Type}, T.}''},
% and we assigned it to both "f" and "p", and later instantiate in
% "I2" with concrete implementation by overriding this family
% "I.MonotonicF".

% \textbf{Overridable/Sealed Family as better Sigma Type.} Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

% Non-overridable fields are still not expressive enough to achieve the full power of dependent type programming. There are cases where overriding and
% (definition-relevant) reasoning are both needed. For example, we may want a monotonic function as a overridable field member. We cannot split into two fields
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f},
% because to prove
% the latter we need to have concrete definition of "f" in the family type, which
% makes "f" non-overridable at all. One option is to use sigma type
% \mintinline{Coq}{{f | monotonic f}}, but that can be cumbersome when we have
% a bundle of stuff with multiple refinements. 

% To resolve this, we provide \textit{family sealing} mechanism to simulate the sigma type. In a sealed family, every field will expose its definition inside the sealed family but a family as a whole will be ``sealed'' with a ``relaxed family type''---it is an aggregation of the types instead of the concrete definitions of all the field. Thus we can override one sealed family as a whole and change the internal implementation as long as they can satisfy the ``relaxed family type''. 

% For example, the "MonotonicF" in \cref{fig:plugin-example3}:
% we simply seal
% \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}
% together inside an sealed family.
% Because the definition of "f" is exposed inside the family, 
% its definition is
% transparent and can be used to prove "p".
% However, because the enclosing family of "f" is overridable, to swap the
% implementation of "f", we just override the whole ``sealed'' family,
% like we do in "I2.MonotonicF". 

\textbf{Overridable Fields with dependency.}  Each field is by default non-overridable. By the discussion of \ref{chg:latebind-v-defeq}, we can simply reason and access the definition about the former fields in a later field, just like Field "a" and "b" in \cref{fig:plugin-example3} and we lose the ability to override. 

However, overridability is useful especially in Coq as programs in Coq are runnable. Consider the sceanrio when we use arbitrary monotonic function as field members \mintinline{Coq}{f : nat → nat} and \mintinline{Coq}{p : monotonic f}, and we make sure that all the following reasoning are only about the monotonicity. Then it should be allowed to swap the implementation of that monotonic function via overriding. 

To resolve, we introduce overridable fields. Each overridable field will only expose its type instead of the concrete definition to the following default (non-overridable) fields. For example, the first failure in \cref{fig:plugin-example3} per the discussion of \ref{chg:latebind-v-defeq}: since overridability will break the inheritability of "c" and thus we don't allow such field to exist in the first place. Our plugin will only expose the fact that "a'" is an arbitrary natural number but hiding its concrete definition, and thus "eq_refl" will fail to type-check.

In this stage, this feature is yet too weak since we cannot do definitional-relevant reasoning about overridable fields, like field "c" in the first failure. Thus we introduce \textit{dependency} between overridable fields---in the syntax of \mintinline{Coq}{Overridable pins {x,y,...} Field f := fexp}. In this case, field "f" will depend on the (overridable) field "x,y,...", and semantically, this means the concrete definition of "x,y,..." is \textit{exposed} to "fexp" during the type checking of "fexp". Every overridable field can only depend on former \textit{overridable} and \textit{definition-transparent} (non-"Qed"-Coq-term) fields. 

To override an overridable field, we use the syntax \\ \mintinline{Coq}{Override [pins {x',y',...}] Field f := fexp'} in the definition of the children family. We can change the dependency \textbf{arbitrarily} in the children family if we want, just by specifying the new "pins" component and there is no restriction on the "x',y',..." we choose. The only restriction is that the overriden "f" has to have the same type as the parent field "f". 

However, if we want to inherit any overridable field in the children family, we need to make sure every dependent (overridable) field is \textit{inherited instead of overridden} in the children family. That means, every overriding will lead to a chain of overriding on the depender fields. This coincides with our intuition about the example---when the dependee monotonic function is overridden, the proof about its monotonicity needs to be changed accordingly. 
Look at the field "f" and "p" in \cref{fig:plugin-example3} in both families. Both fields are initially filled with place-holder in the parent family, but then in children family "I2", "f" is overridden by "(+ 1)" and then to prove its monotonicity, we need to expose the concrete definition of "f" and thus we need to \textit{newly} pins "f" when providing the overriding "p".




% if the user wants a given field to be non-overridable. We will later elaborate its detail application.

\textbf{Inheritance on Nested Families.} We also provide extending,
inheriting and overriding for nested family (member). Extension is done
by simply declaring a nested family; the same syntax for inheriting a
field is used in inheriting a family. However, overriding is
special---overriding can only apply to \textit{sealed} nested family in
the parent family. A family is sealed when using "SealFamily" as the
scoping instead of "EndFamily". We will later elaborate the motivation
and details of sealed family.

% Currently, every sealed family can only be direct inherited or overridden as a whole. It cannot be extended.

\textbf{Extensible Inductive Type.} We provide the keyword "FInductive"
to enable extensible inductive type. "Extend FInductive" is used to
support extension of the parent inductive type inside a children family.
The syntax of these two is close to the mundane "Inductive" keyword. 

Unlike how Coq's "Inductive" will automatically generate the eliminator for the inductive type, we require the user to explicit use "FScheme .. PRecT" to generate a \textit{partial recursor} for the "FInductive". We will later explain what a partial recursor is, at this point the reader can just consider it as a mundane eliminator. 


To resolve \ref{chg:extensible-v-exhaustive}, our first step is to
\textit{decouple} the definition of recursor handlers and the checking
of exhaustiveness. The users will define recursive handlers for one
inductive type by aggregating the (function) handlers into one family.
Then
"FRecursor" will be used to construct a recursor by referring to the handler family.
\mintinline{Coq}{FRecursor recur about T motive f } "using"
"handlers" will generate a new field "recur" that is really doing computation
(using elimination principle of the inductive type "T") with motive "f". The handlers
are located in the family "handlers", similar to a large pattern-matching statement. This way, the reuse and the extension of the case handlers will be delegated by the inheritance of the family. Once recursor is created it will look like any other function fields(e.g. "subst" in \cref{fig:STLC-example2}).




"FTheorem" has a similar functionality but is expected to be used for
theorem proving---the handler and the family will be automatically
constructed during proving.

% Explain FScheme
However, "FRecursor" doesn't specify any reduction/computation information until a family is defined completely and closed (e.g. "subst" in \cref{fig:STLC-example2} cannot reduce when application during the definition of the surrounding family). To remedy this, we introduce "FScheme CompEq" that will generate proposition of equations indicating reductions. For example, for "subst", it will generate the equation
\mintinline{Coq}{subst tm_unit = subst_internal.tm_unit}. 

Similarly, the generated partial recursor using "FScheme .. PRecT" doesn't have computation information either, and require "FScheme CompEq" to generate them.

 

% We can also use "Family" and "SealFamily" to scope a (nested) family. The resulting family only support direct inheritance or "Override" (i.e. we can only override a sealed family as a whole together)---we will later explain this design decision and its usage, especially on resolving \ref{chg:latebind-v-defeq}. What's more, "Override" family can only apply to sealed family as well (not allowed on normal family).

% We can inherit a top-level family "parent" using \mintinline{Coq}{Family ... extends parent} as a new top-level family. As expected, "Override"
% will override a field from the parent. "Inherit" can be used to inherit
% nested families, inductive types, and fields. "Final" is used to claim that the decorated field is non-overridable, and later we will show how it is used to resolve \ref{chg:latebind-v-defeq}. The fields inside a family
% are order-sensitive because we have dependent types here. So "Inherit
% Until" is used if the user wants to inherit a range of fields.  "Extend Family" is used only inside a inheriting family. Thus nested
% family can only be inherited or extended together with its belonging family
% (i.e. ultimately top level family), thus our support of family polymorphism is
% incomplete.

We will explain the usage of "Closing Fact" and "MetaData" later---they are \textit{escape-hatches} to resolve \ref{chg:tooling} to some extent.
% This incomplete support can already be useful for extending functions.
% Take \cref{fig:plugin-example2} as example, if we want to extend boolean
% inductive type and its negation, we only need to specify the new
% constructor for boolean and how negation deals with the new constructor.
% As a result, the programmer does not have to duplicate code---otherwise
% the user will need to copy and paste the whole original negation
% definition and add a new pattern matching case.


% Explain Mixin

Finally, \textbf{Mixin.} For two children family with the same parent family, we support mixin the two using "Family ... extends ... using ... using ...". (In this case, it is better to consider the children family itself as \textit{an inheritance object}.) However, the candidates for mixin cannot have any overriding term (i.e. only allow inheritance and extension).  