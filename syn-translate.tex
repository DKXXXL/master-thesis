The implementation described in \cref{sec:coqimpl} has hinted the fact that
linkage can be translated into dependent tuple type.
The described compilation strategy can be considered as
a \textit{type preserving syntactic translation}, a function mapping from our syntactic
model(typed Abstract Syntax Tree(AST)) to a ``subpart''\footnote{Not exactly subpart---the only
difference lies in "Wrec". In our metatheory, it is constructed
using linkage; in ``subpart'', it will be using $\Sigma$-types (translation
of the linkage).} of our syntactic model(typed AST) \textit{without
linkages}.

This ``subpart'' is the standard MLTT with our
(unconventional) formulation of W-types,
and recursors that use $\Sigma$-types to aggregate handlers.

Basically, we can compile away (the derivation of) judgement $\goodSig{\Gamma}{v}{n}$,
the type $\cL$, $\cP$, and related terms, by transforming them into
corresponding $\Sigma$-types.

 

% \newcommand{\denotesT}[1]{{{\llbracket {#1} \rrbracket}_T}}
% \newcommand{\Sigr}[2]{{ "Sig"^r~{#1}~{#2} }}

We use $\denotesT{}$ as the translation. This translation behaves like identity
\YZ{What does "invariant" mean?}\EDJreply{behaves like identity. Sorry I should have said "subpart is invariant under this translation" instead}
under the subpart. Since we are in an intrinsic setting, everything here
is well-typed (well-formed)including this translation. Thus
$\denotesT{T}$ means the same as $\denotesT{\goodType{\Gamma}{T}{}}$
(i.e. every type is tracking its context). In other words, every
derivation of any judgement will track its ``context''. 


\begin{align*}
  \text{We first define a new type }& \goodType{\Gamma}{\Sigr{\Gamma}{n}}{}  \text{ when } \goodCtx{\Gamma}{}  \text{ is well-formed and } n \in \mathbb{N} \\
  \text{such that } &\goodTerm{\Gm}{\denotesT{\goodSig{\Gamma}{\lsig}{n}}}{\Sigr{\Gm}{n}} \\
  \text{We make } & ({\Sigr{\Gamma}{n}}), \text{ and } \ \denotesT{\TyTkg {-}} \text{ mutually recursive, } \\
  & \text{defined by induction on $n$ and the signature length} \\  
  % \denotesT{\goodSig{\Gamma}{\_}{n}} &= (\goodTerm{\Gamma}{\_}{\Sigr{\Gamma}{n}}) \\ 
  % &\text{, and thus } \denotesT{\goodSig{\Gamma}{\sigma}{n}} \text{ defined} \iff \goodTerm{\Gamma}{\denotesT{\sigma}}{\Sigr{\Gamma}{n}} \\ 
  {\Sigr{\Gamma}{(n+1)}} &= 
    \Sigma~(\Sigr{\Gamma}{n})
          ~(\Sigma~\cU
                  ~(\Sigma~(\Pi(\denotesT{\TyTkg {("var"_0[p^1])}})(El~"var"_0[p^1]))~\cU)) \\
  \Sigr{\Gamma}{0} &= \top \\
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}}, \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} &\text{ defines upon } \denotesT{\sigma} 
  \text{ and inductively on the signature length} \\
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}} &= \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} = \top \quad
      \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}} \\ 
  \denotesT{\goodType{\Gamma}{\TyTkg {\sigma}}{}} &= 
    \Sigma~\denotesT{\TyTkg {(\lsigproj{1}{\sigma})}}~(El \ (\app{("pjr"^3~\denotesT{\sigma})})[(p^1, \app{(\fst{("pjr"^2~{\denotesT{\sigma}})})})]) \\
  \denotesT{\goodType{\Gamma}{\TyLkg{\sigma}}{}} &=
  \denotesT{\TyLkg{(\lsigproj{1}{\sigma})}} \times \Pi(El~(\fst{(\snd{\denotesT{\sigma}})}))(El~(\app{("pjr"^3~\denotesT{\sigma})} )) \\
  &\text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}} \\
  \denotesT{\goodSig{\Gamma}{\LSigEmp}{0}} &= \unit \\ 
  \denotesT{\goodSig{\Gamma}{\LSigAdd{\sigma}{f}{T}}{n+1}} &= (\denotesT{\sigma}, \codety{A}, \lam{f}, \lam{(\codety{T})}) \\ 
  \denotesT{\goodTerm{\Gamma}{\LkgEmp}{\TyLkg{\LSigEmp}}} &= \unit \\ 
  \denotesT{\goodTerm{\Gamma}{\mu^+~m~t}{\TyLkg{(\LSigAdd{\sigma}{s}{T})}}} &= (\denotesT{m}, \lam{t}) \\ 
  \denotesT{\goodTerm{\Gamma}{\Tkg{m}}{\TyTkg {\sigma}}} & \text{ is defined upon } \denotesT{m} \text{ and inductively on the signature length} \\ 
  \denotesT{\goodTerm{\Gamma}{\Tkg {m}}{\TyTkg {\sigma}}} &= () \quad \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{0}} \\
  \denotesT{\goodTerm{\Gamma}{\Tkg {m}}{\TyTkg {\sigma}}} &= 
  (\denotesT{\Tkg {o}}, t[(\SubstExt{p^1}{f})][(\SubstExt{"id"}{\denotesT{\Tkg {o}}})]) \\
  & \text{given } \denotesT{\goodSig{\Gamma}{\sigma}{n+1}}, \text{ where } o = \lsigproj{1}{m}, t = \app{(\snd{\denotesT{m}})}, f = p_f\nu~\sigma 
\end{align*}
% \begin{align*}
%   \denotesT{\goodInh{\Gamma}{\_}{\sigma_1}{\sigma_2}} &= \goodTerm{\Gamma, \TyLkg{\sigma_1}}{\_}{\TyLkg{\sigma_2[p^1]}} \\ \text{ and thus } \denotesT{\goodInh{\Gamma}{h}{\sigma_1}{\sigma_2}} &\iff  \goodTerm{\Gamma, \TyLkg{\sigma_1}}{h}{\TyLkg{\sigma_2[p^1]}} \\
%   \denotesT{\goodInh{\Gamma}{"inhinh"~h~T~\uparrow^s}{(\LSigAdd {\sigma_1} {s_1}{T})}{(\LSigAdd {\sigma_2} {s_2} {T[(p^1, \uparrow^s)]})}} &= \mu^+~(h[(p^1,\lkgproj{1}{"var"_0})])\\ &\quad \quad \{f_2[p^1]\}~(\lkgproj{2}{"var"_0})[(p^1, \uparrow^s[{p^1}^{\uparrow}])] \\
% \end{align*}



The main idea of this syntactic translation is that, we make sure
$\goodSig{\Gamma}{\nu^+ \_ }{n+1}$ and $\goodSig{\Gamma}{\mu^+ \_}{n+1}$
wrapped into a dependent pair. These two definitions decide the
syntactic translation for $\goodSig{\Gamma}{\_}{n}$ and $\cL$. The
syntactic translation for $\cP$ are decided by their
$\beta$-rules. 

% We use the local morphism\cite{abbott2003category} (the same one for encoding the Sealing
% judgements) to translate inheritance judgement. This is mainly due to
% the existence of \ruleref{Inh} rule. 
% Here we only typeset the overriding
% and inheritance rule, but all of the translation for inh judgment are
% induced by the $\beta$-rule of \ruleref{Inh}.

We omit all the validation of equational rules ($\beta,\eta$ and substitution) here.
However, when we mutual recursively define
$\denotesT{\goodSig{\Gamma}{\_}{n}}$, ${\Sigr{\Gamma}{n}} $, and
$\denotesT{\cP}$ above, we actually have to prove the substitution laws
$\sub{(\TyTkg{\lsig})}{\gm}\equiv \TyTkg{\sub{\lsig}{\gm}}$ and $\sub{(\Sigr{\Delta}{n})}{\gm}
\equiv \Sigr{\Gamma}{n}$ together. 
% The details (of all the equational rules) can be found in the appendices written in (pseudo-)Agda form. We encourage the reader to read that (pseudo-)Agda-style proof because it is more friendly to type theorists, easy to do type checking and
% validate the proof and it is clearer on the mathematical object each
% translation uses.


Ultimately, we have constructed a model for our syntax using only a
``subpart'' of our syntax -- without these linkages. It is also
possible to compile our $\goodWSig{\Gamma}{w}{n}$ and W-type into a more
conventional formulation, but the recursor will always require a sigma
type as handler and thus the elimination rule for our W-type is still
non-conventional.

This translation justifies the intuition -- a linkage is actually a
module \textbf{with universal quantification wrapping its fields to
achieve late binding}. 

After syntactic translation, we can directly have consistency and
canonicity \textit{if we assume the consistency and canonicity of the
``subpart''}. However, due to our non-conventional formulation of the
inductive type, it is better we don't impose such assumption and
directly give a consistency and canonicity proof.


