\noindentparagraph{\TT as a programming language.}  Conventionally, the operational semantics sketches \emph{the interpreter} of a given formalization of a programming language. However, compared to this traditional setup, a careful reader will notice the absence of operational semantics in our \TT and doubt if \TT can really be considered as a programming language.

Indeed, for \TT, we only have syntactic term and their judgemental equality (conversion rules) between them. However, we still can have \emph{an interpreter} about our \TT in our ambient meta-logic. For a programmer, this is just like writting a Haskell meta-circular interpreter~\cite{abelson1996structure} that interpret an abstract syntax tree into Haskell's data structure. For a logician, this is just interpreting the syntactic $\goodTerm{\cdot}{t}{\cB}$ to an element $t \in \{\true, \false \}$. For a formal semanticist, this can be considered as a naive form of denotational semantic. 

This interpreter is in the form of our canonicity theorem~\cref{thm:canonicity} in the light of Curry-Howard Correspondence, as any closed program of type $\cB$ is evaluated to either $\true$ or $\false$ under this theorem.
What's more, our canonicity theorem not only return the evaluation result, but also \emph{reflects} this computational traces into \TT as a proof term of the derivation $t \equiv \true$ or $t \equiv \false$.  