This appendix supplements \cref{sec:metatheory2} with the details of the syntax
and the proofs of the main results.

Unlike in \cref{sec:metatheory2}, which uses named binders, in this appendix we
use \citeauthor{debruijn1964} indices and \emph{explicit
substitutions}~\cite{abadi1989subst,substcalculus}:
substitutions~$\gm$ and their applications (e.g., \sub{T}{\gm}, which
applies~$\gm$ to the type~$T$) are part of the syntax rather than
meta-operations. 
We work in an intrinsically typed setting: terms are well typed by construction.
This style of syntax formulation follows a recent
trend~\cite{altkap2016,coquand2018canonicity,gratzer-sterling-birkedal-2019}
known as the ``algebraic presentation'' of MLTT.
%We introduce judgmental equality ($\equiv$)
%for derivations (of all kinds of judgements). In other words, we will have judgemental equality between terms, 
%contexts, explicits substitutions, and etc. 
%This style of syntax formulation has been carried out by the recent trend~\cite{altkap2016,coquand2018canonicity,gratzer-sterling-birkedal-2019} dubbed as ``algebraic presentation'' of MLTT. 
Moreover, universe levels are explicit in this appendix. 


Other aspects of the syntax remain the same as in \cref{sec:metatheory2}.
In particular,
%following \citet{altkap2016,coquand2018canonicity,gratzer-sterling-birkedal-2019},
the syntax is still considered as being quotiented by the judgmental equalities.
Quotienting facilitates coercion along equalities.
Furthermore, the semantic model we develop in this appendix respects these
judgmental equalities by construction.
%This means 
%(1) our model have to respect the judgemental equalities to be a legitimate model for the quotiented syntax, and (2) we have convertibility for free---when we have definitionally equal $A \equiv B$, thanks to the quotient syntax, the derivation of $t : A$ is the same as the derivation of $t : B$.

%After the syntax, we detail the models and proofs for syntactic translation (that translate away linkages),  consistency and canonicity. 


\subsection{MLTT with Explicit Substitutions and Universe Levels}
\label{sec:mltt-full}

We review the base MLTT fragment of \TT first.
\input{all-mltt-typing}

\noindentparagraph{De Bruijn Indices and Explicit Substitution.}

\Citeauthor{debruijn1964} indices and explicit substitutions make details about
binders and substitutions explicit.
%
Using explicit substitutions obviates the need for special treatment of
substitutions in the proofs, as substitutions are part of the syntax.
%The change of the syntax formulation is important to the simplicity of our
%proof, as we want to handle the proof about substitutions and terms
%uniformly---thus making substitution as part of the syntax (explicit
%substitution) will be helpful. 
%
The form \var{n} represents a variable bound by the $n$-th closest enclosing binder.
For example, $\lambda x.\,\lambda y.\,x$ is $\lam{\lam{\var{1}}}$.
%
Substitutions are typed with the form 
$\goodSub{\Gm}{\gm}{\Dl}$.
The idea is that applying~$\gm$ to terms valid in the context~$\Dl$
yields terms valid in~$\Gm$ (\ruleref{tm/sub} and \ruleref{ty/sub}).
%
The two main forms of substitutions are weakening (\ruleref{sub/wk}) and extension (\ruleref{sub/ext}):
\sub{t}{\SubstWeak{n}} introduces $n$ free variables into the context of $t$, and
\sub{t}{\SubstExt{\gm}{t'}} substitutes~$t'$ for~$\var{0}$ in~$t$ and
then applies~$\gm$.
For example, rule \ruleref{tm/snd} states that if $t$ is a dependent pair
that has type $\TySigma{A}{B}$, then $\snd{t}$ has type
$\sub{B}{\SubstExt{\SubstWeak{0}}{\fst{t}}}$,
where $\SubstId$ is the identity substitution (\ruleref{sub/id}).

To simplify, $\SubstWeak{n}$ is a short hand for $\pi_1^n~"id"$ and $\var{n}$ is a short hand for $\pi_2~\pi_1^{n}$. Thus during meta-theoretic reasoning, we will only deal with $\pi_1$ and $\pi_2$.

Consequently, function application changes to a equivalent formulation, and becomes a ``direct inverse'' of typing rule for function abstraction. For example, the named notation $\napp{f}{t}$ can be equivalently represented by $\sub{\app{f}}{\SubstExt{\SubstId}{t}}$.

Finally, we have \ruleref{sub/dbj/shift} defined using \ruleref{sub/wk} and \ruleref{tm/var}. This rule applying substitution $\gm$ on the earlier part of the context. We usually omit $A$ in the $\gm^{\uparrow A}$ because it can be inferred from the context.



\noindentparagraph{Universe levels.}

Universe levels address the size issue---it is unsound to have a set of all sets
(or a universe of all types)~\cite{hurkens1995simplification}.
The level of a universe specifies ``how large'' that universe is.
%that is basically what universe level is measuring. 

%The treatment of universe levels follows \citet{altkap2016, kaposi2019gluing}.
The judgment form $\goodType{\Gm}{T}{i}$ indicates that (the code of) the type $T$
inhabits universe~$\cU_i$.
Similarly, $\goodCtx{\Gm}{i}$ indicates that (the codes of) the types in $\Gm$
inhabit universe~$\cU_i$.
The notation $i \lcup j$ denotes $\max(i,j)$.

%Since we work in an intrinsic-typed setting, some required premises can be omitted without ambiguity. For omitted context judgement $\goodCtx{\Gm}{k}$, the universe level is always $k$, hinted at the figure of judgement specification. Similar for type judgement $\goodType{\Gm}{T}{j}$.



% Copy and Paste Intuition of MLTT from other places to here
\subsection{\TT}
\label{sec:fmltt-full}

\TT extends the MLTT in \cref{sec:mltt-full} with W-type signatures and W-types,
linkage signatures and linkages, and linkage transformers.

\input{all-fmltt-typing}

% Copy and Paste Intuition of FMLTT from other places to here


% Deal with intuition
\noindentparagraph{Why $\TyTkg{\cdot}$?} 

%As shown by the equality rule \ruleref{tyeq/pk/add},
%for a given linkage signature $\lsig \coloneq \LSigAdd{\cdot}{\cdot}{\cdot}$,
%the type $\TyTkg{\lsig}$ is structurally similar to the linkage type $\TyLkg{\lsig}$
%except that $\TyTkg{\lsig}$ is a dependent tuple type---%
%it packages the fields of $\lsig$ into a dependent tuple type.
%
%We have computed several examples in
%\cref{fig:stlc-linkage-typing}, where the reader should also notice the high
%similarity between $\TyTkg{\lsig}$ and $\TyLkg{\lsig}$.

$\TyTkg{\lsig}$ is needed in rules $\ruleref{lsig/add}$ and $\ruleref{l/add}$:
these rules have a premise  $\goodTerm{\Gm,x : \TyTkg{\lsig}}{\seal}{A}$
responsible for possibly hiding W-type signatures (in $\TyTkg{\lsig}$) behind $\cU$ (in $A$);
see $\seal_6$ in \cref{fig:stlc-linkage-typing} for an example.
Here, both $\TyTkg{\lsig}$ and $A$ are dependent tuple types rather than linkage types.

%Thus the mystery of $\TyTkg{\cdot}$ really lies in its necessity. $\TyTkg{\cdot}$ is indispensible because \emph{we cannot do abstraction with $\TyLkg{\cdot}$ alone}, which in turn is due to the fact that an abstraction $A$ inside $\ruleref{lsig/add}$ and $\ruleref{l/add}$ is \emph{usually a dependent tuple type}. 

An alternative to $\TyTkg{\lsig}$ would be to use linkage types $\TyLkg{\cdot}$ in this premise.
However, this alternative is infeasible.
We illustrate using a simple example.
Consider the linkage signature $\lsig$ below (it is written using the record
syntax for illustration but should not be confused with records, as a later field
is universally quantified over a $\mathit{self}$ variable).
The job is to hide the W-types $\TyS{\wcode{\wsig_1}}$ and
$\TyS{\wcode{\wsig_2}}$ in $\lsig$ behind $\cU$ in $\lsig^A$:
%
\begin{align*}
  \lsig &\coloneq \{ T_A : \TyS{\wcode{\wsig_1}}; &&T_B : \TyS{\wcode{\wsig_2}}; &&f : \El{\getfield{\mathit{self}}{T_A}} \to \El{\getfield{\mathit{self}}{T_B}} \} \\
  \lsig^A &\coloneq \{T_A : \cU; &&T_B : \cU; &&f : \El{\getfield{\mathit{self}}{T_A}} \to \El{\getfield{\mathit{self}}{T_B}} \} \\
  & && \goodTerm{x : \TyLkg{\lsig}}{\seal}{\TyLkg{\lsig^A}}
\end{align*}

%We illustrate with a small example using named convention, say given two inductive type $\wsig_1$ and $\wsig_2$ and a function $f$ maps from the first to the second type. Then we will have a linkage $\goodTerm{\cdot}{\ell}{\TyLkg{\lsig}}$. Say we want to add a new field into this linkage, and in $\ruleref{l/add}$, we chose $A$ to abstract both inductive type to $\cU$, resulting something like $\lsig^A$. The question now is whether $A$ is a linkage type $\TyLkg{\lsig^A}$ or a dependent tuple type $\TyTkg{\lsig^A}$; and for each case we will intuitively choose the following approach to do abstraction (choose $s$).

The problem lies in that the type $\TyLkg{\lsig^A}$ above cannot be inhabited.
Suppose there is some $\lkg^A$ such that $\cdot \vdash \lkg^A : \TyLkg{\lsig^A}$.
Then it follows from the self-parameterization that projecting out the last field~$f$
has the typing
$\goodTerm{T_A : \cU, T_B: \cU}{\lkgproj{2}{\lkg^A}}{\El{T_A} \to \El{T_B}}$.
This typing means that there is a function of type
$\nTyPi{T_A}{\cU}{\nTyPi{T_B}{\cU}{\El{T_A}
\to \El{T_B}}}$, i.e., a function from an arbitrary type to another arbitrary
type. We can easily derive inconsistency from this function:
we can apply it to $\top$ and $\bot$ and get $\top \to \bot$.

%\begin{align*}
%  & \text{doing abstraction (choosing appropriate $s$ in \ruleref{l/add})} \\ 
%  \text{\textcolor{red}{Approach $\alpha$}}  \quad&\quad {\color{red} \TyLkg{\lsig} \longrightarrow \TyLkg{\lsig^A}} \\
%  \text{Approach } \beta \quad&\quad  \TyLkg{\lsig} \longrightarrow \TyTkg{\lsig} \longrightarrow \TyTkg{\lsig^A}\\
%\end{align*}
%
%However, the seemingly easier approach $\alpha$ is impossible because linkage
%$\TyLkg{\lsig^A}$ is uninhabited---%
%say we have $\ell^A : \TyLkg{\lsig^A}$, then by projection we will have an impossible term $\goodTerm{T_A : \cU, T_B: \cU}{\ell^A.f}{\El{T_A} \to \El{T_B}}$ due to the nature of overridability of linkage. To make the inconsistency clearer, by double abstraction we will have an impossible function $g \coloneq \goodTerm{\cdot}{\nlam{T_A}{\nlam{T_B}{\ell^A.f}}}{\nTyPi{T_A}{\cU}{\nTyPi{T_B}{\cU}{\El{T_A} \to \El{T_B}}}} $, i.e. a function maps from arbitrary type to another arbitrary type . We can easily derive inconsistency by applying $\napp{\napp{g}{\top}}{\bot} : \top \to \bot$. 
%
%Thus we can only choose the approach $\beta$ instead, which justifies why we have $\TyTkg{\cdot}$ in our typing rule, as $\TyTkg{\lsig}$ is usually the first step to do abstraction.

Thus, it is critical that the hiding of W-type signatures operate on dependent
tuple types rather than linkage types.
To this end, we introduce the syntax $\TyTkg{\lsig}$ and its computation rules
(e.g., \ruleref{tyeq/pk/add}) to make it convenient to package linkage signatures
into dependent tuple types.

%To summarize, the reason we need dependent tuple type is because of the overridability nature of our linkages, together with the frequent usage of universe type in the context of dependent type programming. Once we want to abstract a type in a signature, we may have to use dependent tuple type as the abstraction instead of linkages. Since abstraction is usually dependent tuple type, we introduce $\TyTkg{\cdot}$ and its computation rules to make the process of doing abstraction in \TT easier.




\noindentparagraph{Linkage transformers as syntactic sugar.}


%Observe the syntax, linkage transformer and its judgement is defined above 
%other parts. 
%
%So we can inductively define the syntax sugar $\goodInh{\Gm}{h}{\lsig_1}{\lsig_2}$ using constructors $\InhExt{}{}$, $\InhOv{}{}$, $\InhInh{}$, $\InhNest{}{}$. Then we define the $\inh{h}{\ell}$ and the explicit substitution for linkage transformer $\sub{h}{\gm}$ by induction on the structure of linkage transformer $h$, based on the equality
%%\EDJ{Add substitution equalities for linkage transformers} 
%given in the syntax. In that way, the explicit substituon for linkage transformer becomes meta-level substitution again; and $\inh{h}{\ell}$ is not itself a syntax but a meta-level computation that leads to a syntax.

As mentioned in \cref{sec:metatheory2}, the five forms of linkage transformers can be
thought of as a library of functions that are used to construct linkages from other
linkages.
In particular, their typing rules are defined in terms of the rest of the typing
rules in \TT.
Thus, linkage transformers $\goodInh{\Gm}{h}{\lsig_1}{\lsig_2}$ can be defined
as syntactic sugar via an inductive type (in the meta\-logic) with four constructors
%\YZ{I reinterpreted what you wrote, but this sentence doesn't sound right to me. If linkage transformers are meta-level inductive types, aren't they just part of the syntax?}\EDJreply{I think the reason that they are syntactic sugar is because they can be interpreted using FMLTT syntax(without them), it is fine either the syntactic sugar is defined via inductive type (and then interpreted), or directly interpreted. Maybe I should remove this misleading sentence? \\ What's more, the specification/definition of syntactic sugar itself, is inductive type. Because a linkage transformer looks inductive. Maybe I should directly separate the typing rules for linkage transformer as another figure to emphasize it as an inductive construction on the rest FMLTT syntax?}
$\InhExt{}{}$, $\InhOv{}{}$, $\InhInh{}$, and $\InhNest{}{}$.
Moreover, $\inh{h}{\ell}$ and $\sub{h}{\gm}$ can be defined
as recursive functions (in the meta\-logic) by induction on this inductive type.
We will treat linkage transformers as syntactic sugar in the meta\-theoretic development
in the rest of \cref{sec:complete-fmltt}.

\subsection{A Translation that Compiles Linkages Away}


\input{syn-translate.tex}

% \subsection{Standard Model for Consistency}

% \input{standardmodel.tex}


\subsection{A Proof Relevant Logical-Relations Model for Canonicity}
\label{sec:canonicity-model}
\input{canonicitymodel.tex}

