Once we have the syntax of our theory, the first question is if our theory is consistent, i.e., if we can syntactically derive bottom in our theory. We prove the consistency by extending the standard model from \citep{altenkirch2016type,kaposi2017type, kaposi2019gluing} and their formalization, where they formally resort to the concept of \textit{algebra} of QIIT, here we only consider inductively interpreting each syntax piece into naive set theory that is also respecting judgemental equalities\footnote{In our appendix, we still interpret into Agda component to be more precise and less error-prone, also we need the inductive facility from Agda.} The main idea of the proof is that: 1. we use $\denotesS{}$ to map each intrinsic well-typed syntax piece into a mathematical object; 2. we define proof-irrelevant proposition $\models_S$ for each syntactical $\vdash$, and derive compatibility lemma. We will mainly focus on the definition of $\denotesS{}$ and omit the verification of $\models_S$\footnote{Actually our 1 is acting exactly as an interpretation function, and in our agda formulation we only do 1 because 2 is automatic; here we make 2 explicit to make our formulation more accessible and uniform}, and also we omit the verification of equality (i.e. the judgementally-equal syntax needs to be mapped to the same data for well-defined-ness).

Note that, since every piece is intrinsic well-typed, $\denotesS{t}$ means the same as $\denotesS{\goodTerm{\Gamma}{t}{T}}$ (i.e. every term is tracking its context and type)

Here we will only show some interpretation and also omit the universe level to sketch out the idea, please refer to appendix for the complete version. 

\newcommand{\goodCtxS}[2]{{ {#1} \ \models_S }}
\newcommand{\goodTypeS}[3]{{ {#1} \models_S {#2} }}
\newcommand{\goodTermS}[3]{{ {#1} \models_S {#2} : {#3} }}
\newcommand{\goodSubS}[3]{{ {#1} \models_S {#2} : {#3} }}
\newcommand{\goodSigS}[3]{{ {#1} \models_S {#2} \ \  Sig^{#3} }}
\newcommand{\goodWSigS}[3]{{ {#1} \models_S {#2} \ \ WSig^{#3} }}
\newcommand{\goodSealS}[4]{{ {#1} \models_S {#2} : {#3} \  |\  {#4} }}
\newcommand{\goodInhS}[4]{{ {#1} \models_S {#2} : {#3} \twoheadrightarrow {#4}}}

\begin{align*}
  \denotesS{\goodCtx{\Gamma}{i}} & \text{ is a Set and we define } \goodCtxS{\Gamma}{i} :\iff \denotesS{\goodCtx{\Gamma}{i}} \text{ is defined} \\
  \denotesS{\goodType{\Gamma}{T}{i}} & \text{ is a family of sets indexed by } \denotesS{\goodCtx{\Gamma}{i}} \\
  & \text{ and we define } \goodTypeS{\Gamma}{T}{i} : \iff \denotesS{\goodType{\Gamma}{T}{i}} \text{ is defined } \\
  \denotesS{\goodCtx{\cdot}{i}} &= \{\star\} \quad \text{ a specific singleton set} \\
  \denotesS{\goodCtx{\Gamma, A}{i}} &= \{(\gamma, a) : \gamma \in \denotesS{\goodCtx{\Gamma}{}}, a \in \denotesS{\goodType{\Gamma}{A}{}}(\gamma)\}
  \\
  \denotesS{\goodSub{\Gamma}{\_}{\Delta}} & \text{ is a Set and we define }  {\goodSubS{\Gamma}{\gamma}{\Delta}} : \iff \denotesS{\gamma} \in \denotesS{\goodSub{\Gamma}{\_}{\Delta}} \\
  \denotesS{\goodSub{\Gamma}{\_}{\Delta}} & = \denotesS{\goodCtx{\Gamma}{i}} \rightarrow \denotesS{\goodCtx{\Delta}{j}} \\
  \denotesS{\goodTerm{\Gamma}{\_}{T}} & \text{ is a Set (of dependent function) } \\& \text{and we define }  {\goodTermS{\Gamma}{t}{T}} : \iff \denotesS{t} \in \denotesS{\goodTerm{\Gamma}{\_}{T}} \\
  \denotesS{\goodTerm{\Gamma}{\_}{T}} & = \prod_{\gamma \in \denotesS{\goodCtx{\Gamma}{i}}}\denotesS{T}(\gamma) \\
  \denotesS{\goodType{\Gamma}{\Sigma A B}{}} &\text{ is a family of sets, defined dependent on } \denotesS{A}, \denotesS{B} \\
  \denotesS{\goodType{\Gamma}{\Sigma A B}{}}(\gamma) &:= \sum_{a \in \denotesS{A}\gamma} \denotesS{B}(\gamma, a) \\
  \denotesS{\goodSig{\Gamma}{\_}{n}} & \text{ is a Set  and we define  } {\goodSigS{\Gamma}{\sigma}{n}} :\iff \denotesS{\sigma} \in  \denotesS{\goodSig{\Gamma}{\_}{n}} \\
  \denotesS{\goodType{\Gamma}{\cC \sigma}{}} & \text{ is a family of sets, dependent on and defined inductively on } \denotesS{\sigma} \\   
  \denotesS{\goodSig{\Gamma}{\_}{n+1}} &= \{
    (\denotesS{\sigma}, \denotesS{A}, \denotesS{f}, \denotesS{T}) :
      {\goodSigS{\Gamma}{\sigma}{n}}
      \land  {\goodTypeS{\Gamma}{A}{}} \\  
      & \quad \quad \quad \land  {\goodSealS{\Gamma}{f}{\sigma}{A}}
      \land  {\goodTypeS{\Gamma, A}{T}{i}} 
  \} \\ 
  \denotesS{\goodSig{\Gamma}{\_}{0}} &= \{\star\} \quad \text{ a specific singleton set} \\
  \denotesS{\goodType{\Gamma}{\cC \sigma}{}} &= \denotesS{\Sigma} \denotesS{\goodType{\Gamma}{\cC \tau}{}} \denotesS{T[sf \ f]} \\
  & \quad \text{when } \denotesS{\sigma} = (\denotesS{\tau}, \denotesS{A}, \denotesS{f} , \denotesS{T}) \in \denotesS{\goodSig{\Gamma}{\_}{n+1}} \\
  \denotesS{\goodType{\Gamma}{\cC \sigma}{i}}&= \denotesS{\top}\quad \text{ when } \denotesS{\sigma} \in \denotesS{\goodSig{\Gamma}{\_}{0}} \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} & \text{ is a family of sets, dependent on } \denotesS{\sigma}  \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} (\gamma)&= \{(m, t) :  m \in \denotesS{\cL \tau}(\gamma) \land t \in \prod_{m' \in \denotesS{A}(\gamma)}\denotesS{T}(\gamma, m')  \}  \\
  & \quad \text{when } \denotesS{\sigma} = (\denotesS{\tau}, \denotesS{A}, \_, \denotesS{T}) \in \denotesS{\goodSig{\Gamma}{\_}{n+1}} \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} \ (\gamma)&= \{\star\} \text{ when } \denotesS{\sigma} \in \denotesS{\goodSig{\Gamma}{\_}{0}} \\
  \denotesS{\goodSig{\Gamma}{\nu\cdot}{0}} &= \star \\
  \denotesS{\goodSig{\Gamma}{\nu^+ \ \sigma \ f \ T}{n+1}} &= (\sigma, A, f, T) \\
  \denotesS{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot} } \ (\gamma) &= \star \\
  \denotesS{\goodTerm{\Gamma}{\mu^+ \ o \ t}{\cL(\nu^+ \ \sigma  \ T)}} \ (\gamma)&= (o(\gamma), (\lambda \ m' . t'(\gamma, m'))) \\
  \denotesS{\goodTerm{\Gamma}{\cCt \{\sigma\} o}{\cC\sigma}} & \text{ is a dependent function, defined inductively on } \denotesS{\sigma} \\
  \denotesS{\goodTerm{\Gamma}{\cCt o}{\cC\sigma}}
  &= \denotesS{\goodTerm{\Gamma}{\cCt (p_1\mu \ o)}{...}}, \denotesS{(p_2\mu \ o)[sf \ f][(id, \cCt (p_1\mu \ o))]} \\
  & \text{ when } \denotesS{\sigma} \in \denotesS{\goodSig{\Gamma}{\_}{n+1}} \\
  \denotesS{\goodTerm{\Gamma}{\cCt o}{\cC\sigma}}
  &= \star \quad \text{ when } \denotesS{\sigma} \in \denotesS{\goodSig{\Gamma}{\_}{0}} \\
  \denotesS{\goodType{\Gamma}{\bot}{i}} \ (\gamma) &= \emptyset \\
  \denotesS{\goodType{\Gamma}{\cB}{i}} \ (\gamma) &= \{0, 1\} \quad \text{a specific two element set} \\
  \denotesS{\goodWSig{\Gamma}{\_}{n}} &\text{ is a Set of list of pairs of type interpretation of length } n \\
  & \text{ and we define } \goodWSigS{\Gamma}{w}{n} :\iff \denotesS{\goodWSig{\Gamma}{w}{n}} \in \denotesS{\goodWSig{\Gamma}{\_}{n}}\\
  \denotesS{\goodWSig{\Gamma}{w\cdot}{0}} &= [] \quad \text{ an empty list} \\ 
  \denotesS{\goodWSig{\Gamma}{(w^+ \ A \ B \ w)}{n+1}}
  &= (\denotesS{A}, \denotesS{B})~"::"~\denotesS{\goodWSig{\Gamma}{w}{n}} \\ 
  \denotesS{\goodType{\Gamma}{\pi^j_1~\sigma}{}} &= "fst"~({\denotesS{\sigma}}_{j})\\
  \denotesS{\goodType{\Gamma, \pi^j_1~\sigma}{\pi^j_2~\sigma}{}} &= "snd"~({\denotesS{\sigma}}_j)\\
\end{align*}


We encourage the reader to read the (fake) Agda-style proof in our appendix because most of the parts are similar but with more type annotation so it is clearer about the mathematical object doing the interpretation. Here, we need to clarify some ambiguity in our conventional formulation. For example, when we wrote ``$\denotesS{\goodType{\Gamma}{\cC \sigma}{}}$ defined inductively on $\denotesS{\Sigma}$'', the best way to understand is to consider we are defining a function $\denotesS{\goodType{\Gamma}{\cC \_}{}}$ as the interpretation for $\goodType{\Gamma}{\cC \_}{}$ that mapping $\denotesS{\sigma}$ to $\denotesS{\goodType{\Gamma}{\cC \sigma}{}}$ also defined inductively on the length of the signature. The case is similar for $\denotesS{\cL \_}$, $\denotesS{\cCt \_}$ and  $\denotesS{\Sigma \ \_ \ \_}$. \textbf{This is actually the formulation in Agda} -- QIIT syntax consider $\cC : "Sig"~\Gamma~n \to "Ty"~\Gamma$ as a constructor and our model needs to interpret this constructor to a function $\cC^S : "Sig"^S \Gamma^S~n \to "Ty"^S~\Gamma^S$ with each judgement type also interpreted. 

Basically in Agda, we are simply constructing a function that mapping our QIIT data-type to some other data -- it maps $"Con"$ to $"Con"^S$, "Ty : Con → Set" to "Ty$^S$ : Con$^S$ → Set" and etc. What's more, since judgemental equality in our meta-theory is represented by equality in QIIT, and the well-defined-ness of this mapping-out function implies that ``judgementally equal syntax is interpreted by the same semantic in the model''. 

Notice that $\denotesS{\goodSig{\Gamma}{s}{n}}$ and $\denotesS{\goodType{\Gamma}{\cC\sigma}{i}}$ is mutual recursively defined together -- because $\goodSealS{\Gamma}{f}{\sigma}{A}$ relies on $\cC$. 

\begin{figure}
  \centering
\begin{minipage}{0.8\linewidth}
  \begin{minted}[mathescape, escapeinside=||]{Agda}
    data MW {i}{j} (σ : |$\denotesS{\texttt{WSig i }\cdot\texttt{ S}}$|) : Set (lsuc i) where
      MWsup : |$n$| < S → (a : |$\pi^n_1$| σ) → ((|$\pi^n_2$| σ) a → MW σ) 
              → MW σ
      \end{minted}
\end{minipage}
\caption{Modeling Inductive Type}\label{fig:model-ind-type}
\end{figure}

We sketch the model for the inductive type and inheritance judgement here, and both of them require inductive facility in meta-logic. In set theory, that would be using \textit{Rule sets}~\citep{timany2017consistency,aczel1998relating}, but we are using Agda's Inductive facility instead. Both of them are somewhat ``interpreted by themselves'' in Agda, because their syntactic definition is pretty ``well-founded''. For inductive type, for each grounded signature, we have an inductive type using introduction rule of W-type as constructor, shown in Figure \ref*{fig:model-ind-type}. This "MWsup" when applying to $n$ will use the $n$-th constructor specify in the signature. This grounded-ness is required to verify the substitution laws. For inheritance judgement, we simply construct a term model of inheritance judgement using vanilla inductive type (instead of QIIT). Then we use meta-level substitution to model the explicit substitution, and we can define $\denotesS{"inh"~\_ ~\_}$ by induction on this term model. 

% As expected, we use an inductive type in the meta-logic with the constructor from W-type to model our inductive type, and the recursor for the inductive type in the meta-logic is directly modelling the recursor for our inductive type in our theory. For inheritance judgement, we inductively define an almost-identical syntactic structure as model, (but not a QIIT), and we inductively define meta-level substitution to implement the explicit substitution. We also define $inh$ operation by induction strictly following $\beta$-law. Basically both ideas are using the syntax of themselves in meta-logic to model, because its definition is pretty "well-founded". Most importantly, this doesn't affect our aim to model bottom type using empty set to derive consistency.


The verification of validity of this model is largely omitted here and we refer the reader to the appendix. To verify our model preserve the judgemental equality, usually unpacking the definition is enough -- for example, to verify $\beta$-rule for linkage projection, we only need to see that $\denotesS{\goodTerm{\Gamma}{p_1\mu~(\mu^+~o~t)}{\cL\sigma}} = \denotesS{\goodTerm{\Gamma}{o}{\cL\sigma}}$. One exception is for $\cC$ and $\goodSig{\_}{\_}{n}$, the substitution law around these two are also proved together by induction because they were mutual-recursively defined together. The compatibility lemmas can be verified directly -- for example $\frac{\goodSigS{\Gamma}{\sigma}{n+1}\quad\goodTermS{\Gamma}{o}{\cL\sigma}}{\goodTermS{\Gamma}{p_1\mu~o}{\cL(p_1\nu~\sigma)}}$ is proved by simply unfolding the definition.


Since all the compatibility lemmas hold (by simply changing $\vdash$ into $\models$ in the syntactic rules then we would have all the compatibility lemmas\footnote{Apparently, in our (fake) Agda formulation, we don't need this extra step.}), we have constructed a model.
Finally, notice that we interpret the bottom type using empty set, and thus we know it is not possible to derive $\cdot \vdash t : \bot$: otherwise we have $\cdot \models_S t : \bot$ which exactly means $\denotesS{t}(\star) \in \denotesS{\bot}(\star) = \emptyset$ 
and that is a contradiction.

The full model formulated in (fake) Agda syntax can be found in the appendix.

