Once we have the syntax of our theory, the first question is if our theory is consistent, i.e., if we can syntactically derive bottom in our theory. We prove the consistency by extending the standard model from \citep{kaposi2017type, kaposi2019gluing}, where they formally resort to the concept of \textit{algebra} of QIIT, here we only consider inductively interpreting each syntax piece into naive set theory that is also respecting judgemental equalities for accessibility\footnote{In our appendix, we still interpret into Agda component to be more precise and less error-prone, also we need the inductive facility from Agda.} The main idea of the proof is that: 1. we use $\denotesS{}$ to map each intrinsic well-typed syntax piece into a mathematical object; 2. we define proof-irrelevant proposition $\models_S$ for each syntactical $\vdash$, and derive compatibility lemma. We will mainly focus on the definition of $\denotesS{}$ and omit the verification of $\models_S$\footnote{Actually our 1 is acting exactly as an interpretation function, and in our agda formulation we only do 1 because 2 is automatic; here we make 2 explicit to make our formulation more accessible and uniform}, and also we omit the verification of equality (i.e. the judgementally-equal syntax needs to be mapped to the same data for well-defined-ness).

Note that, since every piece is intrinsic well-typed, $\denotesS{t}$ means the same as $\denotesS{\goodTerm{\Gamma}{t}{T}}$ (i.e. every term is tracking its context and type)

Here we will only show some interpretation and also omit the universe level to sketch out the idea, please refer to appendix for the complete version. 

\newcommand{\goodCtxS}[2]{{ {#1} \ \models_S }}
\newcommand{\goodTypeS}[3]{{ {#1} \models_S {#2} }}
\newcommand{\goodTermS}[3]{{ {#1} \models_S {#2} : {#3} }}
\newcommand{\goodSubS}[3]{{ {#1} \models_S {#2} : {#3} }}
\newcommand{\goodSigS}[3]{{ {#1} \models_S {#2} \ \  Sig^{#3} }}
\newcommand{\goodWSigS}[3]{{ {#1} \models_S {#2} \ \ WSig^{#3} }}
\newcommand{\goodSealS}[4]{{ {#1} \models_S {#2} : {#3} \  |\  {#4} }}
\newcommand{\goodInhS}[4]{{ {#1} \models_S {#2} : {#3} \twoheadrightarrow {#4}}}

\begin{align*}
  \denotesS{\goodCtx{\Gamma}{i}} & \text{ is a Set and we define } \goodCtxS{\Gamma}{i} :\iff \denotesS{\goodCtx{\Gamma}{i}} \text{ is defined} \\
  \denotesS{\goodCtx{\cdot}{i}} &= \{\star\} \quad \text{ a specific singleton set} \\
  \denotesS{\goodType{\Gamma}{T}{i}} & \text{ is a family of sets indexed by } \denotesS{\goodCtx{\Gamma}{i}} \\
  & \text{ and we define } \goodTypeS{\Gamma}{T}{i} : \iff \denotesS{\goodType{\Gamma}{T}{i}} \text{ is defined } \\
  \denotesS{\goodSub{\Gamma}{\_}{\Delta}} & \text{ is a Set and we define }  {\goodSubS{\Gamma}{\gamma}{\Delta}} : \iff \denotesS{\gamma} \in \denotesS{\goodSub{\Gamma}{\_}{\Delta}} \\
  \denotesS{\goodSub{\Gamma}{\_}{\Delta}} & = \denotesS{\goodCtx{\Gamma}{i}} \rightarrow \denotesS{\goodCtx{\Delta}{j}} \\
  \denotesS{\goodTerm{\Gamma}{\_}{T}} & \text{ is a Set (of dependent function) } \\& \text{and we define }  {\goodTermS{\Gamma}{t}{T}} : \iff \denotesS{t} \in \denotesS{\goodTerm{\Gamma}{\_}{T}} \\
  \denotesS{\goodTerm{\Gamma}{\_}{T}} & = \prod_{\gamma \in \denotesS{\goodCtx{\Gamma}{i}}}\denotesS{T}(\gamma) \\
  % 
  \denotesS{\goodSig{\Gamma}{\_}{n}} & \text{ is a Set  and we define  } {\goodSigS{\Gamma}{\sigma}{n}} :\iff \denotesS{\sigma} \in  \denotesS{\goodSig{\Gamma}{\_}{n}} \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} & \text{ is a family of sets, dependent on } \denotesS{\sigma}  \\
  \denotesS{\goodSig{\Gamma}{\_}{n+1}} &= \{
    (\denotesS{\sigma}, \denotesS{\sigma'}, \denotesS{f}, \denotesS{T}) :
      {\goodSigS{\Gamma}{\sigma}{n}}
      \land  {\goodSigS{\Gamma}{\sigma'}{n}} \\  
      & \quad \quad \quad \land  {\goodSealS{\Gamma}{f}{\sigma}{\sigma'}}
      \land  {\goodTypeS{\Gamma, \cL \sigma'}{T}{i}} 
  \} \\ 
  \denotesS{\goodSig{\Gamma}{\_}{0}} &= \{\star\} \quad \text{ a specific singleton set} \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} (\gamma)&= \{(m, f) :  m \in \denotesS{\cL \tau}(\gamma) \land f \in \prod_{m' \in \denotesS{\cL \tau'}(\gamma)}\denotesS{T}(\gamma, m')  \}  \\
  & \quad \text{when } \denotesS{\sigma} = (\denotesS{\tau}, \denotesS{\tau'}, \_ , \denotesS{T}) \in \denotesS{\goodSig{\Gamma}{\_}{n+1}} \\
  \denotesS{\goodType{\Gamma}{\cL \sigma}{i}} \ (\gamma)&= \{\star\} \text{ when } \denotesS{\sigma} \in \denotesS{\goodSig{\Gamma}{\_}{0}} \\
  \denotesS{\goodSig{\Gamma}{\nu\cdot}{0}} &= \star \\
  \denotesS{\goodSig{\Gamma}{\nu^+ \ \sigma \ f \ T}{n+1}} &= (\sigma, \sigma', f, T) \\
  \denotesS{\goodTerm{\Gamma}{\mu\cdot}{\cL \nu\cdot} } \ (\gamma) &= \star \\
  \denotesS{\goodTerm{\Gamma}{\mu^+ \ o \ t}{\cL(\nu^+ \ \sigma  \ T)}} \ (\gamma)&= (o(\gamma), (\lambda \ m' . t'(\gamma, m'))) \\
  \denotesS{\goodType{\Gamma}{\bot}{i}} \ (\gamma) &= \emptyset \\
  \denotesS{\goodType{\Gamma}{\cB}{i}} \ (\gamma) &= \{0, 1\} \quad \text{a specific two element set} \\
\end{align*}


We will take some examples on the verification of validity of this model: 1. to verify compatibility lemma ; 2. to verify the well-defined-ness of this model,  

Notice that $\denotesS{\goodSig{\Gamma}{s}{n}}$ and $\denotesS{\goodType{\Gamma}{\cL\sigma}{i}}$ is mutual recursively defined together. What's more, the substitution law around these two are also proved together by induction.

% We omit the model here for extensible inductive type and inheritance judgement because they require inductive facility in meta-logic. 
We spell-out the model for extensible type and inheritance judgement here, and both of them require inductive facility in meta-logic. In set theory, that would be using \textit{Rule sets}~\citep{timany2017consistency,aczel1998relating}, but we are using Agda's Inductive facility instead. 
% In appendix we will use the native inductive notion from Agda to construct models. 
As expected, we use an inductive type with the constructor from W-type to model our extensible inductive type, and the recursor for the inductive type is directly modelling the recursor for our extensible inductive type. For inheritance judgement, we inductively define an almost-identical syntactic structure as model, (but not a QIIT), and we inductively define meta-level substitution to implement the explicit substitution. We also define $inh$ operation by induction strictly following $\beta$-law. Basically both ideas are using the syntax of themselves in meta-logic to model, because its definition is pretty "well-founded". Most importantly, this doesn't affect our aim to model bottom type using empty set to derive consistency.



Notice that we interpret the bottom type using empty set, and thus we know it is not possible to derive $\cdot \vdash t : \bot$: otherwise we have $\cdot \models_S t : \bot$ which exactly means $\denotesS{t}(\star) \in \denotesS{\bot}(\star) = \emptyset$ 
and that is a contradiction.