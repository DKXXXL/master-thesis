We provide two examples here for illustration and evaluation. 

\subsection{Type Safety for STLC}
We start with the very basic type safety proof of STLC, largely adapted from Software Foundation, which is also one of the primal motivating example of this project. 

Our emphasis here is that, we singled out some programming language features from STLC and prove the type safety for each feature separately, following the style of the examples in MTC\citep{delaware2013,forsta2020}. And we use a \textit{not-yet-completely-defined} \textbf{mix-in} feature to mix the semantic and properties of two programming language feature -- product and boolean -- with vanilla STLC. This way, we can say precisely, \textit{a programming language feature itself is a piece of data/inheritance judgement/inherited family}. Compared to MTC, our example uses small-step operational semantic by exploiting the extensible inductive type, and most of the proof is directly adapted from the one in Software Foundation, resulting a more accessible proof. 
% In related work, Coq/Metatheory a la carte/Tion embedding can be emphasized as a more "semantic approach" because they encode the meaning using a special design pattern (for example, open recursive inductive type for extension), compared to our more syntactic approach. Their advantage is the transferability of this technique accross different proof assistants, and their disadvantage is that their approach are less accessible and unfriendly to amateur Coq users -- which can be reflected from the distance of their approach and text-book Software Foundation proof. 

% We have problem on inversion lemma. Check if it is the same problem as MTC
We use `Closing Fact' to state and prove the inversion lemma instead of using the extensible proving mechanism `FTheorem'. The reason is that 1. it introduce much less boilerplate code because the proof for these inversion lemma should be just simple case analysis and we should rely on Coq to auto-generate them; 2. it shouldn't bother us in the future because any extension on the syntax should still satisfy these inversion lemmas; 3. most importantly, we believe this inversion ``lemma'' should be part of the definition of the syntax instead of considering the syntax as a mere concrete inductive type. We should postulate this inversion ``lemma'' like \textit{a constraint} and post-hoc-ly verify that our inductive definition did satisfy the constraint, which is exactly what we expect from `Closing Fact'.

\subsection{Abstract Interpreters for Imp}
The second example is adapted and modified from the Familia\citep{zhang2017familia}
% citation needed here
-- contrary to our first example, we use big-step interpreter and fuel to indicate the operational semantic on an imperative language with side-effect, and we specify the abstract interpretation and prove its soundness, with some of postulation on both computation and property. Then we extend the language feature and we instantiate the postulation on computation for both concrete interpreters and abstract interpreters. Thanks to the compilation, we can directly run the resulting abstract interpreters.