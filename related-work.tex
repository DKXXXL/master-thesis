This section discusses related work.




\textbf{Modular Mechanized Metatheory: Syntactic Approach} We group the work that achieves modular mechanized metatheory by extending surface syntax of proof assistants as \textit{syntactic approach}. 

The closest work to ours might be \citet{boite2004proo}--they try to support \textit{extended} inductive type and related proof reuse in Coq. This biggest difference lies in our (incomplete) adaption of Family Polymorphism -- we support proof reuse and extension by inheritance, but also support implementation swapping using overriding, and we also argue that Family Polymorphism can provide a better and cleaner way of organizing mechanized metatheory development. The other difference lies in the handling of the extension of the inductive type. In our paradigm, the discussion of \textit{extensible} inductive type and partial recursor is unavoidable, which characterizes all possible extension of a given inductive type. In their work, without using Family to organized the code, the extended inductive type can be considered as a different inductive type than the original one, possibly leading to more expression problem~\cite{wadler-ep}.

\textbf{Modular Mechanized Metatheory: Semantic Approach} We group the work using certain algebraic encoding (e.g. Church Encoding, datatype-generic programming) without modify the surface syntax of the proof assistants as \textit{semantic approach}, that includes \citet{delaware2013,forsta2020,liwei2022,schwaab2013modular, keuchel2013generic} and so on. Their advantages are various: this technique is more general and thus can be applied across different (dependent-typed) proof assistants and this technique can be easily distributed like a library and thus doesn't need to alter the core of the proof assistants. The downsides are mainly about the threshold: they are not friendly for the junior Coq development and these indirect encoding of datatype might lead to worse readability and accessibility compared to the direct style like ours.




\textbf{Solution to The Expression Problem}
% Have no idea how to write this :(